# LeetCode Queue & Deque Patterns

A focused guide to the most important **Queue** and **Deque** patterns in coding interviews (LeetCode focus, 2024–2026 trends) — excluding classic BFS tree/grid traversal.

**Queue** → FIFO (First In, First Out)  
**Deque** → Double-ended queue (O(1) add/remove from both ends) → ideal for monotonic structures & sliding windows.

These two patterns cover many high-frequency queue/deque problems:

1. **Monotonic Deque** → Sliding Window Minimum / Maximum & optimization problems
2. **Simulation & Design with Queue / Deque**

---

## Pattern 1: Monotonic Deque – Sliding Window Min / Max & Variants

**Core Idea**  
Maintain a deque of **indices** (usually) in strictly/weakly increasing (for min) or decreasing (for max) order.  
- Pop from **back** elements that are useless (worse than incoming element)  
- Pop from **front** elements that fall outside the current window  
- The front of the deque is always the min/max candidate for the current window

**When to use**  
- "sliding window maximum / minimum"
- "maximum / minimum in every window of size k"
- Shortest subarray with sum ≥ k
- Jump game with window constraint
- DP optimization with sliding window maximum

**Real-life analogy**  
A moving review window on a product page — only the highest/lowest rating in the visible reviews matters; others get ignored as better ones arrive.

### 20+ LeetCode Problems – Monotonic Deque

| #  | Problem Name                                   | Link                                                                 | Difficulty | Key Technique                              |
|----|------------------------------------------------|----------------------------------------------------------------------|------------|--------------------------------------------|
| 1  | Sliding Window Maximum                         | https://leetcode.com/problems/sliding-window-maximum                 | Hard       | Decreasing deque of indices                |
| 2  | Sliding Window Minimum                         | https://leetcode.com/problems/sliding-window-minimum                 | Hard       | Increasing deque of indices                |
| 3  | Shortest Subarray with Sum at Least K          | https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k  | Hard       | Monotonic increasing prefix sums           |
| 4  | Constrained Subsequence Sum                    | https://leetcode.com/problems/constrained-subsequence-sum            | Hard       | Decreasing deque storing dp values         |
| 5  | Jump Game VI                                   | https://leetcode.com/problems/jump-game-vi                           | Hard       | Decreasing deque for max score in window   |
| 6  | Maximum Erasure Value                          | https://leetcode.com/problems/maximum-erasure-value                  | Medium     | Sliding window + set (deque alternative)   |
| 7  | Max Consecutive Ones III                       | https://leetcode.com/problems/max-consecutive-ones-iii               | Medium     | Sliding window (at most k zeros)           |
| 8  | Longest Repeating Character Replacement        | https://leetcode.com/problems/longest-repeating-character-replacement| Medium     | Sliding window + freq map                  |
| 9  | Minimum Window Substring                       | https://leetcode.com/problems/minimum-window-substring               | Hard       | Two pointers (can combine deque ideas)     |
|10  | Find All Anagrams in a String                  | https://leetcode.com/problems/find-all-anagrams-in-a-string          | Medium     | Fixed-size sliding window                  |
|11  | Sliding Window Median                          | https://leetcode.com/problems/sliding-window-median                  | Hard       | Two heaps + delayed deletion (deque alt)   |
|12  | Longest Subarray of 1's After Deleting One Element | https://leetcode.com/problems/longest-subarray-of-1s-after-deleting-one-element | Medium | Sliding window at most one 0            |
|13  | Maximum Performance of a Team                  | https://leetcode.com/problems/maximum-performance-of-a-team          | Hard       | Sort + min-heap (deque variant possible)   |
|14  | Remove K Digits                                | https://leetcode.com/problems/remove-k-digits                        | Medium     | Monotonic increasing (stack/deque)         |
|15  | Find the Most Competitive Subsequence          | https://leetcode.com/problems/find-the-most-competitive-subsequence  | Medium     | Monotonic increasing + k limit             |
|16  | Create Maximum Number                          | https://leetcode.com/problems/create-maximum-number                  | Hard       | Monotonic stack + merge                    |
|17  | Shortest Subarray to be Removed to Make Array Sorted | https://leetcode.com/problems/shortest-subarray-to-be-removed-to-make-array-sorted | Hard | Two pointers + monotonic ideas          |
|18  | Sum of Subarray Minimums (window variant)      | https://leetcode.com/problems/sum-of-subarray-minimums               | Medium     | Monotonic + contribution (can adapt)       |
|19  | Online Stock Span (deque variant)              | https://leetcode.com/problems/online-stock-span                      | Medium     | Previous greater (monotonic stack/deque)   |
|20  | Number of Valid Subarrays                      | https://leetcode.com/problems/number-of-valid-subarrays              | Medium     | Monotonic stack for contribution           |
|21  | Minimum Cost to Make Array Equalindromic       | Variants / recent problems                                           | Hard       | Monotonic deque for optimization           |
|22  | Maximum Sum of Almost Unique Subarray          | https://leetcode.com/problems/maximum-sum-of-almost-unique-subarray  | Medium     | Sliding window + set                       |

---

## Pattern 2: Simulation & Design with Queue / Deque

**Core Idea**  
Use queue/deque to model sequential processing, history, circular behavior, cooldowns, or to implement custom data structures.

**When to use**  
- Design circular queue / deque
- Moving average from stream
- Task scheduling with cooldown / frequency
- Implement stack using queues (and vice versa)
- Recent events / timestamp-based cleanup
- Command / operation history simulation

**Real-life analogy**  
A print queue or call center queue — jobs/tasks are processed in order, sometimes with priority or expiration.

### 20+ LeetCode Problems – Queue / Deque Simulation & Design

| #  | Problem Name                                   | Link                                                                 | Difficulty | Key Technique                              |
|----|------------------------------------------------|----------------------------------------------------------------------|------------|--------------------------------------------|
| 1  | Design Circular Queue                          | https://leetcode.com/problems/design-circular-queue                  | Medium     | Array + head & tail pointers               |
| 2  | Design Circular Deque                          | https://leetcode.com/problems/design-circular-deque                  | Medium     | Array / doubly linked list                 |
| 3  | Moving Average from Data Stream                | https://leetcode.com/problems/moving-average-from-data-stream        | Easy       | Queue + running sum                        |
| 4  | Implement Stack using Queues                   | https://leetcode.com/problems/implement-stack-using-queues           | Easy       | Two queues (or rotate one)                 |
| 5  | Implement Queue using Stacks                   | https://leetcode.com/problems/implement-queue-using-stacks           | Easy       | Two stacks (input → output)                |
| 6  | Task Scheduler                                 | https://leetcode.com/problems/task-scheduler                         | Medium     | Max-heap + cooldown queue                  |
| 7  | Rearrange String k Distance Apart              | https://leetcode.com/problems/rearrange-string-k-distance-apart      | Medium     | Max-heap + cooldown queue                  |
| 8  | Number of Recent Calls                         | https://leetcode.com/problems/number-of-recent-calls                 | Easy       | Queue + remove timestamps > 3000           |
| 9  | Design Hit Counter                             | https://leetcode.com/problems/design-hit-counter                     | Medium     | Queue or bucketed timestamps               |
|10  | Design Front Middle Back Queue                 | https://leetcode.com/problems/design-front-middle-back-queue         | Medium     | Two deques (front & back)                  |
|11  | Design Authentication Manager                  | https://leetcode.com/problems/design-authentication-manager          | Medium     | Queue + expiration cleanup                 |
|12  | First Unique Character in a Stream (design)    | Variants / company-tagged                                            | Medium     | Queue + frequency map                      |
|13  | Design Compressed String Iterator              | https://leetcode.com/problems/design-compressed-string-iterator      | Easy       | Queue-like iterator for repeated chars     |
|14  | LFU Cache (queue component)                    | https://leetcode.com/problems/lfu-cache                              | Hard       | Doubly linked list + freq map              |
|15  | Design Underground System                      | https://leetcode.com/problems/design-underground-system              | Medium     | Maps + average (queue simulation alt)      |
|16  | Design Twitter                                 | https://leetcode.com/problems/design-twitter                         | Medium     | Priority queue / timestamp ordering        |
|17  | Design Most Recently Used Queue                | Company-tagged variants                                              | Medium     | Doubly linked list + map                   |
|18  | Design Movie Ticket Booking System (waitlist)  | Variants                                                             | Medium     | Queue for FIFO waitlist                    |
|19  | Design a Food Rating System                    | https://leetcode.com/problems/design-a-food-rating-system            | Medium     | Maps + priority queues                     |
|20  | Design a Stack With Increment Operation        | https://leetcode.com/problems/design-a-stack-with-increment-operation| Medium     | Array + lazy propagation (queue alt)       |
|21  | Design Bitset (simulation)                     | https://leetcode.com/problems/design-bitset                          | Medium     | Array simulation (queue not core)          |
|22  | Design a Todo List                             | Company-tagged / variants                                            | Medium     | Maps + priority queue for ordering         |

---

## Quick Tips for Queue / Deque Problems

- Use **`collections.deque`** in Python — fast append/pop from both ends.
- In monotonic deque: almost always store **indices** (to check if front is still in window).
- Each element is added/removed O(1) times on average → usually **O(n)** time.
- For design problems: handle edge cases (full/empty, wrap-around in circular).
- High-frequency starters:  
  - Sliding Window Maximum  
  - Design Circular Queue  
  - Task Scheduler  
  - Moving Average from Data Stream

