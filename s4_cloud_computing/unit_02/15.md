# **15: Platform as a Service (PaaS) — Architecture & Usage**

*(How modern cloud applications are actually built and scaled)*

---

## 1. Why PaaS Matters Architecturally

In IaaS, you design **infrastructure first** and then place applications on top.

PaaS flips this approach.

> With PaaS, **the application becomes the center of the architecture**, and infrastructure adapts around it.

This shift is the reason most modern backend systems prefer PaaS for:

* APIs
* microservices
* internal tools
* rapid product iteration

---

## 2. Where PaaS Lives in the Cloud Stack

PaaS sits **above IaaS** and **below SaaS**.

![Image](https://nordicapis.com/wp-content/uploads/PaaS-cloud-stack-nordic-apis.png)

![Image](https://dachou.github.io/assets/20110326-cloudmodels.png)

Architecturally:

* infrastructure exists, but is hidden
* operating systems are managed
* runtimes are standardized
* scaling is automated

This abstraction is **intentional**, not a limitation.

---

## 3. Core Architectural Idea of PaaS

The single most important idea in PaaS is:

> **Stateless application instances + managed stateful services**

What this means:

* your application instances do not store user data locally
* databases, caches, and storage are external services
* instances can be created or destroyed at any time

This enables:

* horizontal scaling
* fast recovery
* predictable behavior

---

## 4. Anatomy of a Typical PaaS-Based Architecture

Let’s break a standard PaaS system into parts.

![Image](https://i.pinimg.com/736x/91/78/b6/9178b64b54239374c3fa81167f5e8eca.jpg)

![Image](https://www.researchgate.net/publication/236134071/figure/fig1/AS%3A299301772251139%401448370511819/Overview-of-the-Multi-Cloud-PaaS-Architecture.png)

### Components:

1. Load balancer (managed)
2. Application instances (stateless)
3. Managed database
4. Managed cache (optional)
5. Centralized logging & monitoring

Key point:

* no instance is special
* all instances are replaceable

---

## 5. Request Lifecycle in PaaS (Step-by-Step)

Understanding this flow prevents many production issues.

![Image](https://www.researchgate.net/publication/303640574/figure/fig4/AS%3A367387489652740%401464603411741/Generic-PaaS-application-lifecycle.png)

![Image](https://www.researchgate.net/publication/235531838/figure/fig5/AS%3A669221054844944%401536566141552/Proposed-PaaS-architecture.png)

### Flow:

1. Client sends request
2. Managed load balancer receives it
3. Request routed to any healthy instance
4. Application processes logic
5. Data fetched from managed services
6. Response returned

Your application **must not assume**:

* which instance it runs on
* how long it will live

---

## 6. Scaling in PaaS (Why It Feels Effortless)

PaaS scaling is **signal-driven**.

Common signals:

* CPU usage
* memory usage
* request rate
* response latency

When thresholds are crossed:

* new instances are created
* traffic is redistributed automatically

![Image](https://docs.aws.amazon.com/images/autoscaling/ec2/userguide/images/elb-tutorial-architecture-diagram.png)

![Image](https://d2908q01vomqb2.cloudfront.net/fc074d501302eb2b93e2554793fcaf50b3bf7291/2021/09/10/Figure-2.-Deployment-architecture-of-Starburst-platform-on-AWS-1024x649.png)

This is why PaaS works extremely well for:

* bursty traffic
* unpredictable workloads
* consumer-facing APIs

---

## 7. Why PaaS Forces Better Application Design

PaaS **removes unsafe assumptions**:

* local file storage disappears
* instance affinity disappears
* manual restarts disappear

As a result, developers are pushed toward:

* stateless APIs
* externalized configuration
* idempotent requests
* graceful startup and shutdown

These are **good engineering practices**, not constraints.

---

## 8. Failure Handling in PaaS

In PaaS:

* instances are expected to fail
* restarts are normal
* upgrades happen transparently

![Image](https://www.researchgate.net/publication/236134071/figure/fig1/AS%3A299301772251139%401448370511819/Overview-of-the-Multi-Cloud-PaaS-Architecture.png)

![Image](https://media.geeksforgeeks.org/wp-content/uploads/20221220171221/Data-lifecycle-phases.png)

Architectural implication:

> If your app cannot restart cleanly, it is **not PaaS-ready**.

Design for:

* fast startup
* safe retries
* no in-memory state dependence

---

## 9. Comparing PaaS Architecture with IaaS Architecture

| Aspect             | IaaS              | PaaS         |
| ------------------ | ----------------- | ------------ |
| Instance lifetime  | Long-lived        | Short-lived  |
| Scaling            | Manual / scripted | Automatic    |
| State handling     | Often local       | Externalized |
| OS control         | Full              | None         |
| Architecture style | Server-centric    | App-centric  |

This table explains why PaaS is preferred for **modern services**.

---

## 10. When PaaS Is the Right Architectural Choice

Choose PaaS when:

* you’re building APIs or services
* traffic patterns are unpredictable
* rapid iteration matters
* ops team is small
* reliability must be built-in

Avoid PaaS when:

* OS-level tuning is required
* legacy software cannot be modified
* strict platform constraints exist

---

## 11. Mental Model to Remember

> **PaaS is not “my server in the cloud.”
> PaaS is “my code running in a constantly changing environment.”**

Design for replacement, not permanence.

---

## Quick Recap

* PaaS centers architecture around applications
* Infrastructure and OS are abstracted away
* Stateless design enables auto-scaling
* Failures and restarts are normal
* PaaS enforces good engineering discipline

---

