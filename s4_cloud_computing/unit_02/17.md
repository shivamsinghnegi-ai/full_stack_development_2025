# **17: Using PaaS Application Frameworks**

*(What actually happens after you deploy your application)*

---

Up to now, we’ve discussed **architectural choices**:

* IaaS vs PaaS
* SaaS vs PaaS
* where each fits

Now we go **one level deeper**.

This article answers a very practical question:

> **What really happens inside a PaaS platform after I deploy my application?**

Understanding this prevents:

* unexpected crashes
* scaling surprises
* production-only bugs
* incorrect assumptions about “servers”

---

## 2. What Is a PaaS Application Framework?

A **PaaS application framework** is the system that:

* accepts your application code
* prepares a runtime environment
* runs your app in isolated instances
* manages scaling, restarts, and routing
* exposes logs and metrics

You never interact with servers directly.
You interact with **the framework**.

![Image](https://www.researchgate.net/publication/317004540/figure/fig6/AS%3A495381142306816%401495119476324/PaaS-platform-architecture.png)

![Image](https://media2.dev.to/dynamic/image/width%3D800%2Cheight%3D%2Cfit%3Dscale-down%2Cgravity%3Dauto%2Cformat%3Dauto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2F1wziffwe3yyg82ipct2x.png)

Think of it as:

> a highly automated manager that constantly watches your application.

---

## 3. Application Deployment Lifecycle (Step-by-Step)

Let’s slow this down and walk through the **exact lifecycle**.

### Step 1: Code Submission

You deploy your app via:

* Git push
* CLI command
* build pipeline

At this point:

* no server is running yet
* the platform only has your code

---

### Step 2: Runtime Detection

The PaaS platform:

* inspects your project
* identifies the language (Node.js, Java, Python, etc.)
* selects a compatible runtime version

Why this matters:

* incorrect runtime versions cause failures
* explicit configuration is safer than defaults

---

### Step 3: Build Phase

If required, the platform:

* installs dependencies
* runs build commands
* creates a runnable artifact

![Image](https://learn.microsoft.com/en-us/azure/devops/pipelines/architectures/media/azure-devops-ci-cd-architecture.svg?view=azure-devops)

![Image](https://docs.cloud.google.com/build/images/devops.png)

Most deployment failures occur **here**, not at runtime.

---

### Step 4: Instance Creation

The platform now:

* creates one or more application instances
* assigns CPU and memory limits
* isolates them from other apps

Each instance:

* runs the same application
* is independent
* can be destroyed at any time

This is where **horizontal scaling begins**.

---

## 4. How Requests Reach Your Application

Understanding request flow is mandatory.

![Image](https://www.tutorialspoint.com/cloud_computing/images/cloud_computing-paas.jpg)

![Image](https://docs.aws.amazon.com/images/prescriptive-guidance/latest/load-balancer-stickiness/images/roundtrip.png)

Flow:

1. Client sends request
2. Platform load balancer receives it
3. Request is routed to a healthy instance
4. Application processes logic
5. Response is returned

Important implication:

> **You do not control which instance handles a request.**

---

## 5. Scaling Behavior in PaaS

PaaS platforms monitor signals such as:

* CPU usage
* memory usage
* request rate
* response time

When thresholds are crossed:

* new instances are created automatically
* traffic is redistributed

![Image](https://docs.aws.amazon.com/images/autoscaling/ec2/userguide/images/elb-tutorial-architecture-diagram.png)

![Image](https://cdn.prod.website-files.com/5ff66329429d880392f6cba2/66a365cb9cc8ad022229bba6_63b81bb8288dbb478ced5522_How%2520Does%2520Auto-Scaling%2520Work.jpeg)

This is why PaaS works extremely well for:

* bursty traffic
* unpredictable workloads
* consumer-facing APIs

---

## 6. Instance Restarts: Normal, Not Errors

One of the biggest misunderstandings:

> **Restarts in PaaS are expected behavior.**

Instances restart due to:

* memory limit exceeded
* failed health checks
* platform updates
* scaling events

![Image](https://k21academy.com/wp-content/uploads/2020/10/Capture-5.png)

![Image](https://dropinblog.net/cdn-cgi/image/fit%3Dscale-down%2Cwidth%3D700/34251246/files/bvuq5wuahz8ongzielvs.png)

Design rule:

* instances are **ephemeral**
* your app must survive restarts

---

## 7. Statelessness Is Not Optional

In PaaS:

* local file storage is temporary
* in-memory state is unsafe
* instance identity is meaningless

Correct design:

* persist data in databases
* store files in object storage
* use external caches
* externalize configuration

If your app requires sticky state, **PaaS will punish it**.

---

## 8. Configuration and Secrets Management

PaaS frameworks enforce:

* configuration via environment variables
* secrets stored securely
* separation of code and config

Why this matters:

* safer deployments
* environment-specific configuration
* easier rotations

Hardcoding values is a **production anti-pattern**.

---

## 9. Logging and Observability

PaaS platforms automatically:

* capture logs from all instances
* aggregate them centrally
* expose metrics and alerts

![Image](https://www.buchatech.com/wp-content/uploads/2017/10/Monitor-PaaS-5.jpg)

![Image](https://images.ctfassets.net/xnqwd8kotbaj/umt4dhjpZhsy4jZjWnc0y/87d8d3f40e971f49764f0011c22238df/Cribl-Cloud-Observability_2x.png)

Good engineers:

* log intentionally
* include request identifiers
* monitor latency and errors

Logs become your **only source of truth** when instances rotate.

---

## 10. Common Mistakes Developers Make on PaaS

1. Storing files on local disk
2. Assuming a single running instance
3. Ignoring memory and CPU limits
4. Slow application startup
5. Not handling retries gracefully

Each of these causes **production-only failures**.

---

## 11. How This Article Fits Unit 2

This article connects:

* architectural decisions (Articles 14–16)
* with real execution behavior

After this, students understand:

* why PaaS behaves the way it does
* how to design applications correctly for it
* why “works on my machine” fails in cloud

---

## 12. Mental Model to Remember

> **In PaaS, your application runs in a hostile, ever-changing environment.
> Design for replacement, not permanence.**

---

## Quick Recap

* PaaS frameworks manage build, run, scale, and restarts
* Instances are short-lived and replaceable
* Load balancers decide request routing
* Stateless design is mandatory
* Logs and metrics are essential

---
