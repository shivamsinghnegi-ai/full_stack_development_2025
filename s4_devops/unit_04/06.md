## Integrating Jenkins and Docker – End-to-End CI Pipeline

---

## 1. From Isolated Tools to a Unified Pipeline

So far, we have explored:

* Git for version control
* Jenkins for Continuous Integration
* Docker for containerization

Individually, each tool improves part of the development process.
When integrated, they form a complete CI pipeline capable of producing deployable, reproducible artifacts automatically.

The objective is simple:

When a developer pushes code, the system should automatically build, test, package, and prepare it for deployment — without manual intervention.

---

## 2. End-to-End CI Flow Overview

A typical integrated pipeline follows this sequence:

1. Developer commits code to Git.
2. Code is pushed to remote repository.
3. Webhook notifies Jenkins.
4. Jenkins triggers pipeline.
5. Application is built and tested.
6. Docker image is built.
7. Image is tagged and optionally pushed to registry.
8. Deployment stage is triggered.

Each step is automated and traceable.

---

## 3. Connecting Git to Jenkins

To integrate Git with Jenkins:

* Configure repository in Jenkins job.
* Enable webhook in Git provider.
* Configure build trigger in Jenkins (“Build when a change is pushed”).

Once configured:

```bash
git push origin main
```

Immediately triggers the Jenkins pipeline.

This eliminates manual build execution.

---

## 4. Example Jenkins Pipeline with Docker Integration

Below is a simplified `Jenkinsfile` demonstrating integration:

```groovy
pipeline {
    agent any

    stages {

        stage('Checkout') {
            steps {
                git 'https://github.com/your-repository.git'
            }
        }

        stage('Build') {
            steps {
                sh 'npm install'
            }
        }

        stage('Test') {
            steps {
                sh 'npm test'
            }
        }

        stage('Build Docker Image') {
            steps {
                sh 'docker build -t my-app-image:latest .'
            }
        }

        stage('Push Image') {
            steps {
                sh 'docker tag my-app-image:latest my-registry/my-app-image:latest'
                sh 'docker push my-registry/my-app-image:latest'
            }
        }
    }
}
```

Let us understand what this does:

* Pulls latest code
* Installs dependencies
* Runs tests
* Builds Docker image
* Pushes image to registry

If any stage fails, the pipeline stops immediately.

---

## 5. Role of Docker Registry

After building a Docker image, it must be stored in a container registry such as:

* Docker Hub
* Private registry
* Cloud container registry

The registry acts as a centralized storage for container images.

Deployment systems pull images directly from the registry.

This ensures that:

* The exact tested image is deployed
* Version tracking is maintained
* Rollbacks are possible

---

## 6. Running Jenkins Inside Docker

Modern practice often involves running Jenkins itself as a container.

Example:

```bash
docker run -d -p 8080:8080 jenkins/jenkins:lts
```

Benefits:

* Easy setup
* Environment consistency
* Simplified upgrades
* Isolation from host system

Containerizing Jenkins aligns with DevOps philosophy: everything should be reproducible.

---

## 7. Automating Deployment Preparation

Although full deployment orchestration will be covered in Unit 5, CI pipelines can prepare applications for deployment by:

* Tagging images with version numbers
* Publishing artifacts
* Triggering staging environment builds

Example version tagging:

```bash
docker build -t my-app-image:v1.2.0 .
```

Version tags improve traceability and rollback safety.

---

## 8. Failure Handling in Integrated Pipelines

An integrated pipeline ensures:

* If build fails → image is not created
* If tests fail → image is not pushed
* If push fails → deployment is blocked

Automation enforces discipline.

Instead of detecting failures in production, errors are caught early in CI.

---

## 9. Benefits of Jenkins + Docker Integration

Integrated pipelines provide:

* Consistent build artifacts
* Faster release cycles
* Reduced manual intervention
* Improved traceability
* Increased deployment confidence

Small changes flow through a predictable automation path.

Deployment becomes a controlled engineering process rather than an event-driven activity.

---

## 10. Preparing for Orchestration

At this stage, we can:

* Build application code
* Test automatically
* Package into Docker images
* Store images in a registry

The next logical challenge is:

How do we run multiple containers?
How do we scale them?
How do we manage them in production?

This leads into orchestration — the focus of Unit 5.

---
