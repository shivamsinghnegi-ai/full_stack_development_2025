# Data Representation

---

## Introduction

Computers don't understand English, Hindi, or even "numbers" like 10 or 100 the way we do. At the deepest level, computers only understand **ON** and **OFF** (electricity).
*   **ON** = 1
*   **OFF** = 0

This is why we use **Binary** (0s and 1s) to represent *everything*—numbers, text, images, and videos.

**Key Concept:** Data Representation is how we translate human information into machine code (binary).

---

## Number Systems

We use the **Decimal** system (base-10) in daily life, but computers use other systems that are easier for machines.

### 1. The Four Common Number Systems

| System | Base | Digits Used | Why used? |
| :--- | :---: | :--- | :--- |
| **Decimal** | 10 | 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 | Human standard system |
| **Binary** | 2 | 0, 1 | Machine language (simplest state) |
| **Octal** | 8 | 0, 1, 2, 3, 4, 5, 6, 7 | Shorthand for binary (groups of 3) |
| **Hexadecimal** | 16 | 0-9, A, B, C, D, E, F | Shorthand for binary (groups of 4). Used in colors (#FFFFFF), memory addresses |

**Note for Hex:**  
A=10, B=11, C=12, D=13, E=14, F=15

---

### 2. Conversions (How to Switch)

#### **A. Binary to Decimal** (The "Power of 2" Method)
**Rule:** Multiply each bit by 2^position (starting from right at 0).

**Example:** Convert `1011` (binary) to Decimal
```
1   0   1   1
│   │   │   └── 1 × 2⁰ = 1
│   │   └────── 1 × 2¹ = 2
│   └────────── 0 × 2² = 0
└────────────── 1 × 2³ = 8
                        ----
                        11 (Decimal)
```
**Answer:** `1011₂ = 11₁₀`

#### **B. Decimal to Binary** (The "Divide by 2" Method)
**Rule:** Keep dividing the decimal number by 2 and write down the **remainder**. Read remainders from **bottom to top**.

**Example:** Convert `13` (decimal) to Binary
```
13 ÷ 2 = 6   Remainder: 1  (LSB - Least Significant Bit)
 6 ÷ 2 = 3   Remainder: 0
 3 ÷ 2 = 1   Remainder: 1
 1 ÷ 2 = 0   Remainder: 1  (MSB - Most Significant Bit)
```
**Read Bottom-Up:** `1101`
**Answer:** `13₁₀ = 1101₂`

#### **C. Binary to Octal** (Group of 3)
**Rule:** Group bits in 3s from right logic.
**Table:**
000=0, 001=1, 010=2, 011=3, 100=4, 101=5, 110=6, 111=7

**Example:** Convert `110101` to Octal
1. `110`  `101`
2. ` 6 `  ` 5 `
**Answer:** `65₈`

#### **D. Binary to Hexadecimal** (Group of 4)
**Rule:** Group bits in 4s from right.
**Table:** ... 1010=A, 1111=F ...

**Example:** Convert `11011010` to Hex
1. `1101`  `1010`
2. ` D  `  ` A  `  (Since 1101=13=D, 1010=10=A)
**Answer:** `DA₁₆`

---

## Integer Representation

How do we store negative numbers? `101` is 5, but how do we write -5?
We have 3 main methods for **Signed Integers**.

### 1. Sign-Magnitude Representation
**Concept:** Use the **first bit** (MSB) just for the sign.
*   **0** = Positive (+)
*   **1** = Negative (-)
The rest of the bits represent the number (magnitude).

**Example:** +5 and -5 in 8-bit
*   +5: `0000 0101` (Sign bit 0)
*   -5: `1000 0101` (Sign bit 1)

**Problem:** Two zeros exist (+0 and -0). Calculation is complex.

### 2. 1's Complement
**Concept:** To get negative, **flip all bits** (0→1, 1→0).

**Example:** -5 in 8-bit
*   +5: `0000 0101`
*   Flip: `1111 1010` (-5)

**Problem:** Still has two zeros (+0 `00000000` and -0 `11111111`).

### 3. 2's Complement (The Standard!)
**Concept:**
To represent a negative number in binary, we use 2's Complement.
It is calculated as: **1's Complement + 1**.

**Why use it?**
1. It has only **one representation for zero** (00000000).
2. It makes arithmetic circuits simpler (Subtraction becomes Addition).

#### **How to Calculate (Step-by-Step)**

**Example 1: Find 2's Complement of -12**
1. **Step 1:** Write positive 12 in binary (8-bit)
   `0000 1100` (+12)
2. **Step 2:** Find 1's Complement (Flip all bits)
   `1111 0011`
3. **Step 3:** Add 1 to the result
   ```
     1111 0011
   +         1
   -----------
     1111 0100  (This is -12)
   ```

**Example 2: Find 2's Complement of -34**
1. **Step 1:** Write positive 34 in binary
   `32 + 2 = 34` -> `0010 0010` (+34)
2. **Step 2:** Find 1's Complement (Flip bits)
   `1101 1101`
3. **Step 3:** Add 1
   ```
     1101 1101
   +         1
   -----------
     1101 1110  (This is -34)
   ```

#### **Shortcut Trick**
Start from the **right side (LSB)**:
1. Copy all bits **up to and including the first '1'**.
2. **Flip all remaining bits** to the left.

*Example for -12 (`0000 1100`):*
- Right to left: `0` (keep), `0` (keep), `1` (keep first 1).
- Flip the rest: `0000 1` -> `1111 0`
- **Result:** `1111 0100`

#### Range of Integers (n bits)
*   **Unsigned:** 0 to 2ⁿ - 1
*   **Signed (2's Comp):** -2⁽ⁿ⁻¹⁾ to +2⁽ⁿ⁻¹⁾ - 1

**For 8-bit:**
*   Unsigned: 0 to 255
*   Signed: -128 to +127

---

## Part 3: Floating Point Representation (Decimals)

How do computers store numbers like `3.14`, `0.00005`, or `9,000,000,000`?
Using standard binary (like 1010) doesn't work well for fractions or very large numbers.

Instead, computers use a system similar to **Scientific Notation**.

### 1. The "Scientific Notation" Analogy
In math, instead of writing `602,000,000,000,000,000,000,000`, we write:
> **6.02 × 10²³**

This has 3 parts:
1.  **Sign:** (+ or -)
2.  **Mantissa (The Number):** 6.02
3.  **Exponent (The Scale):** 23

Computers do the **exact same thing**, but in **Binary**:
> **±1.mantissa × 2^exponent**

*We call it "Floating Point" because the dot floats to the right or left depending on the exponent.*

---

### 2. IEEE 754 Standard (32-bit Single Precision)
This is the standard format used by almost all computers (e.g., `float` in C/Java).
It fits into **32 bits** (boxes), divided into 3 groups:

| S | Exponent (8 bits) | Mantissa (23 bits) |
|---|-------------------|--------------------|
| 1 | 10000010 | 101010000... |

#### **A. The Sign (1 bit)**
*   **0** = Positive (+)
*   **1** = Negative (-)
*   *Simple: Is it + or -?*

#### **B. The Exponent (8 bits) - "The Scale"**
*   This tells us how far to shift the decimal point.
*   **The "Bias" Rule:** To store both positive and negative exponents (like 2⁻³ and 2³), we **add 127** to the actual exponent.
    *   *Stored Exponent = Actual Exponent + 127*

#### **C. The Mantissa (23 bits) - "The Precision"**
*   This holds the actual digits after the decimal point.
*   **The Hidden "1" Rule:** In binary scientific notation, the number is *always* `1.something`. Since the "1" is always there, we **don't store it** to save space! We only store what comes *after* the dot.

---

### 3. Step-by-Step Example: Storing 12.5
Let's convert **12.5** into IEEE 754 Binary code.

#### **Step 1: Convert to Binary**
*   **Integer part (12):** `1100`
*   **Fraction part (0.5):** `0.1` (because 1 × 2⁻¹ = 0.5)
*   **Combined:** `1100.1`

#### **Step 2: Normalize (Scientific Notation)**
Shift the decimal point until there is only **one '1'** to the left.
*   Move dot **3 places left**: `1100.1` → `1.1001`
*   Since we moved left by 3, the exponent is **3**.
*   **Result:** `1.1001 × 2³`

#### **Step 3: Calculate Stored Exponent**
We need to add the **Bias (127)**.
*   Exponent = 3
*   Stored Value = 3 + 127 = **130**
*   Convert 130 to Binary: `10000010`

#### **Step 4: Get Mantissa**
Take the normalized number `1.1001`.
*   Drop the leading `1.` (The "Hidden 1").
*   Keep: `1001`
*   Add zeros to the end to make it 23 bits long.
*   **Mantissa:** `10010000000000000000000`

#### **Step 5: Assemble!**
1.  **Sign:** Positive (`0`)
2.  **Exponent:** `10000010`
3.  **Mantissa:** `1001000................`

**Final 32-bit Code:**
`0 10000010 10010000000000000000000`

---

### 4. Double Precision (64-bit)
Just like Single Precision, but bigger and more precise. Used for high-accuracy math (`double` in coding).
*   **Sign:** 1 bit
*   **Exponent:** 11 bits (Bias is 1023)
*   **Mantissa:** 52 bits (Mega precision!)

---

## Quick Summary

1.  **Number Systems:**
    *   Binary (Base 2): Machine language
    *   Hex (Base 16): Compact binary
2.  **Integer Representation:**
    *   **Unsigned:** Positive only.
    *   **Signed:** Use 2's Complement! (Flip bits + 1).
3.  **Floating Point (IEEE 754):**
    *   Represent decimals using **Scientific Notation**.
    *   3 Parts: Sign, Exponent (Biased), Mantissa.

---

## Practice Questions

1.  **Convert:** `110110` (binary) to **Decimal**, **Octal**, and **Hex**.
2.  **Find 2's Complement** of -25 (use 8-bit representation).
3.  **Explain why** 2's Complement is preferred over Sign-Magnitude.
4.  **Represent** 6.5 in IEEE 754 Single Precision format.
5.  What is the range of a signed 8-bit integer? (+127 to -128)

---
