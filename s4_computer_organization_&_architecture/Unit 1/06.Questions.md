# Part 1: Structure of Computers

---

**Q1.** What is a Computer?
> **Answer:** A computer is an electronic device that:
> - Takes **INPUT** (like keyboard typing)
> - **PROCESSES** it (does calculations, runs programs)
> - Gives **OUTPUT** (shows results on screen)
> - Can **STORE** information (saves files)
> 
> Simple: A computer is a smart machine that follows instructions to solve problems.

---

**Q2.** What are the five types of computers?
> **Answer:**
> 1. **Microcomputers** - Personal use (laptop, desktop, smartphone)
> 2. **Minicomputers** - Small businesses, 10-100 users
> 3. **Mainframe Computers** - Very large, thousands of users (banks, airlines)
> 4. **Supercomputers** - Fastest computers (weather prediction, AI)
> 5. **Embedded Systems** - Tiny computers inside devices (microwave, car engine)

---

**Q3.** What is a Microcomputer? Give examples.
> **Answer:** A microcomputer is a small personal computer designed for individual use.
> - **Size:** Fits on a desk or in hand
> - **Users:** 1 person at a time
> - **Examples:** Laptop, Desktop, MacBook, iPad, Smartphone

---

**Q4.** What is a Minicomputer?
> **Answer:** A medium-sized computer for small businesses.
> - **Size:** Size of a small refrigerator
> - **Users:** 10-100 people can use together
> - **Example:** Company servers in small offices

---

**Q5.** What is a Mainframe Computer?
> **Answer:** Very large, powerful computers, room-sized.
> - **Users:** Thousands can use simultaneously
> - **Example:** Bank servers, airline booking systems
> - **Analogy:** Like a train - many people use it at once

---

**Q6.** What is a Supercomputer?
> **Answer:** The FASTEST computers in the world.
> - **Size:** Warehouse-sized
> - **Speed:** Trillions of calculations per second
> - **Examples:** Weather prediction, space research, AI training

---

**Q7.** What is an Embedded System?
> **Answer:** Tiny computers hidden inside other devices that do ONE specific job.
> - **Examples:** Microwave timer, car engine control, washing machine controller

---

**Q8.** What are the five Functional Units of a computer?
> **Answer:**
> 1. **Input Unit** - Takes information from user
> 2. **Output Unit** - Shows results to user
> 3. **Central Processing Unit (CPU)** - Brain of computer
> 4. **Memory Unit** - Stores information
> 5. **Registers** - Super fast temporary storage in CPU

---

**Q9.** What is the Input Unit? Give examples.
> **Answer:** The Input Unit takes information FROM the user.
> - **Analogy:** Like your EYES and EARS (receive information)
> - **Examples:** Keyboard, Mouse, Microphone, Camera, Scanner
> - **Rule:** Anything that SENDS data TO the computer = Input device

---

**Q10.** What is the Output Unit? Give examples.
> **Answer:** The Output Unit shows results TO the user.
> - **Analogy:** Like your MOUTH (gives information)
> - **Examples:** Monitor/Screen, Printer, Speakers, Headphones
> - **Rule:** Anything that computer SENDS data to YOU = Output device

---

**Q11.** What is the CPU? What are its two main parts?
> **Answer:** CPU (Central Processing Unit) is the BRAIN of the computer.
> 
> **Two Parts:**
> 1. **ALU (Arithmetic Logic Unit):** Does ALL math operations (add, subtract, multiply, divide, comparisons)
> 2. **Control Unit (CU):** The BOSS - controls everything, manages data flow, coordinates activities

---

**Q12.** What is the ALU and what operations does it perform?
> **Answer:** ALU (Arithmetic Logic Unit) does ALL math operations:
> - Addition: 5 + 3 = 8
> - Subtraction: 10 - 2 = 8
> - Multiplication: 4 × 2 = 8
> - Division: 16 ÷ 2 = 8
> - Comparisons: Is 5 > 3? (YES)
> - **Analogy:** Like a calculator inside the brain

---

**Q13.** What is the Control Unit?
> **Answer:** The Control Unit is the BOSS - controls everything.
> - Tells other units what to do
> - Manages data flow
> - Controls timing
> - Coordinates all activities
> - **Analogy:** Like a traffic police officer directing traffic

---

**Q14.** What are the two types of Memory?
> **Answer:**
> 1. **Primary Memory (RAM):**
>    - VERY FAST
>    - Small (8GB, 16GB)
>    - Temporary (deleted when power OFF)
>    - Like short-term memory
> 
> 2. **Secondary Memory (Storage):**
>    - Slower
>    - HUGE (500GB, 1TB)
>    - Permanent (stays when power OFF)
>    - Examples: Hard Disk, SSD, USB drive
>    - Like long-term memory

---

**Q15.** What are Registers?
> **Answer:** Registers are SUPER FAST temporary storage inside CPU.
> - **Size:** VERY SMALL (few bytes)
> - **Speed:** FASTEST memory in computer
> - **Purpose:** Hold data that CPU is currently using
> - **Analogy:** Your hand holding a pen while writing (immediate access)

---

**Q16.** What is the Fetch-Decode-Execute (FDE) Cycle?
> **Answer:** The computer follows this 3-step cycle for EVERY instruction:
> 
> 1. **FETCH:** Get the next instruction from memory (like taking a recipe card)
> 2. **DECODE:** Understand what the instruction means (reading the recipe)
> 3. **EXECUTE:** Actually DO the instruction (cooking according to recipe)
> 
> Then the cycle REPEATS for the next instruction forever!

---

**Q17.** What is an Interrupt?
> **Answer:** An Interrupt is an EMERGENCY signal that stops current work.
> - **Why needed:** Something urgent needs attention RIGHT NOW
> - **Like:** Fire alarm during class - you stop studying and evacuate
> - **Examples:** Pressing CTRL+C, Printer out of paper, Error message
> 
> **Working:**
> 1. Computer doing normal work
> 2. INTERRUPT happens
> 3. Computer PAUSES current work
> 4. Handles the interrupt (urgent task)
> 5. RESUMES normal work

---

**Q18.** What is a Bus in computers?
> **Answer:** A Bus is a pathway inside the computer where data travels (highway for electrical signals).

---

**Q19.** What are the three types of Buses?
> **Answer:**
> 1. **Data Bus:**
>    - Carries ACTUAL DATA (numbers, letters, pictures)
>    - Two-way (↔)
>    - Width: 32-bit or 64-bit
> 
> 2. **Address Bus:**
>    - Carries ADDRESSES (memory locations)
>    - One-way (→) - CPU to memory only
>    - Like GPS coordinates
> 
> 3. **Control Bus:**
>    - Carries CONTROL SIGNALS (commands)
>    - Both ways (↔)
>    - Examples: "READ", "WRITE" commands

---

**Q20.** Explain how buses work together with an example.
> **Answer:** Example: CPU wants to read data from memory location 100:
> 1. **ADDRESS BUS** → Sends address "100" to memory
> 2. **CONTROL BUS** → Sends "READ" signal
> 3. Memory finds location 100
> 4. **DATA BUS** → Brings the data back to CPU
> 
> **Pizza analogy:**
> - Address Bus = Your home address
> - Control Bus = "DELIVER" command
> - Data Bus = Pizza arriving at door

---

**Q21.** What is Single Bus vs Multiple Bus Structure?
> **Answer:**
> | Type | Description | Advantage | Disadvantage |
> |------|-------------|-----------|--------------|
> | **Single Bus** | ONE bus connects everything | Simple, cheap | Slow (traffic jams) |
> | **Multiple Bus** | MULTIPLE buses for different purposes | Fast (simultaneous) | Complex, expensive |

---

**Q22.** What is Software? What are the two types?
> **Answer:** Software = Programs and instructions that tell hardware what to do.
> 
> **Two Types:**
> 1. **System Software:** Manages computer itself (OS, Drivers, Antivirus)
> 2. **Application Software:** Helps YOU do tasks (Word, Chrome, Games)

---

**Q23.** What is an Operating System?
> **Answer:** The Operating System is the KING of software - controls everything.
> - Manages memory
> - Runs programs
> - Handles files
> - Controls hardware
> - **Examples:** Windows 11, macOS, Linux, Android

---

**Q24.** What is the difference between Compiler and Interpreter?
> **Answer:**
> | Feature | Compiler | Interpreter |
> |---------|----------|-------------|
> | **Translation** | Entire program at once | Line by line |
> | **Speed** | Faster execution | Slower execution |
> | **Error Detection** | After full compilation | At each line |
> | **Analogy** | Translating whole book | Live translator |

---

**Q25.** What is an Assembler?
> **Answer:** Assembler converts assembly language to machine code.
> - **Input:** Assembly code (ADD, SUB, MOV)
> - **Output:** Binary code (010101)
> - **Like:** Converting shorthand notes to full sentences

---

**Q26.** What is Clock Speed and how is it measured?
> **Answer:** Clock Speed measures how many operations per second.
> - **Unit:** Hertz (Hz)
> - 1 GHz = 1 billion cycles per second
> - **Example:** 3.5 GHz processor
> - **Higher clock speed = Faster computer** (usually)

---

**Q27.** What is CPI (Cycles Per Instruction)?
> **Answer:** CPI is how many clock cycles needed for one instruction.
> - **Lower is better!**
> - **Example:** CPI = 2 means each instruction takes 2 clock cycles

---

**Q28.** What is MIPS?
> **Answer:** MIPS = Millions of Instructions Per Second
> - **Higher is better!**
> - **Formula:** MIPS = Clock Speed (MHz) / (CPI × 1 million)
> - **Example:** 100 MIPS = 100 million instructions per second

---

**Q29.** What is the Performance Formula for Execution Time?
> **Answer:** 
> ```
> Execution Time = Number of Instructions × CPI × Clock Cycle Time
> ```
> 
> **To make computer faster:**
> 1. Reduce number of instructions (better programming)
> 2. Reduce CPI (better CPU design)
> 3. Increase clock speed (better hardware)

---

**Q30.** What is a Multiprocessor System?
> **Answer:** Multiple CPUs in ONE computer with SHARED memory.
> - **Communication:** Fast (through shared memory)
> - **Example:** Laptop with 8 cores
> - **Advantage:** Fast, cheap
> - **Analogy:** Team working on one whiteboard together

---

**Q31.** What is a Multicomputer System?
> **Answer:** Multiple SEPARATE computers connected with DISTRIBUTED memory.
> - **Communication:** Slower (through network)
> - **Example:** Google's data centers
> - **Advantage:** Can add more computers easily
> - **Analogy:** Team members working from different offices

---

**Q32.** What is Flynn's Taxonomy?
> **Answer:** Classification of computers by how they process instructions and data:
> 
> 1. **SISD:** Single Instruction, Single Data (old computers)
> 2. **SIMD:** Single Instruction, Multiple Data (graphics processors)
> 3. **MISD:** Multiple Instruction, Single Data (rare, fault-tolerant)
> 4. **MIMD:** Multiple Instruction, Multiple Data (modern multiprocessors) - Most common today!

---

**Q33.** Compare Multiprocessor vs Multicomputer.
> **Answer:**
> | Feature | Multiprocessor | Multicomputer |
> |---------|----------------|---------------|
> | **Memory** | Shared | Distributed |
> | **Communication** | Fast (shared memory) | Slow (network) |
> | **Scalability** | Limited | Easy to add more |
> | **Example** | Multi-core laptop | Data centers |

---

# Part 2: Data Representation

---

**Q34.** Why do computers use Binary (0s and 1s)?
> **Answer:** At the deepest level, computers only understand ON and OFF (electricity).
> - **ON = 1**
> - **OFF = 0**
> 
> This is why we use Binary to represent everything—numbers, text, images, videos.

---

**Q35.** What are the four common Number Systems?
> **Answer:**
> | System | Base | Digits | Why Used |
> |--------|------|--------|----------|
> | **Decimal** | 10 | 0-9 | Human standard |
> | **Binary** | 2 | 0, 1 | Machine language |
> | **Octal** | 8 | 0-7 | Shorthand (groups of 3 bits) |
> | **Hexadecimal** | 16 | 0-9, A-F | Shorthand (groups of 4 bits) |

---

**Q36.** Convert Binary 1011 to Decimal.
> **Answer:** Using "Power of 2" method:
> ```
> 1   0   1   1
> 1×2³ + 0×2² + 1×2¹ + 1×2⁰
> = 8 + 0 + 2 + 1
> = 11
> ```
> **Answer:** 1011₂ = **11₁₀**

---

**Q37.** Convert Decimal 13 to Binary.
> **Answer:** Using "Divide by 2" method:
> ```
> 13 ÷ 2 = 6   Remainder: 1 (LSB)
>  6 ÷ 2 = 3   Remainder: 0
>  3 ÷ 2 = 1   Remainder: 1
>  1 ÷ 2 = 0   Remainder: 1 (MSB)
> ```
> **Read Bottom-Up:** 1101
> **Answer:** 13₁₀ = **1101₂**

---

**Q38.** How to convert Binary to Octal?
> **Answer:** Group bits in 3s from right.
> 
> **Table:** 000=0, 001=1, 010=2, 011=3, 100=4, 101=5, 110=6, 111=7
> 
> **Example:** 110101 → 110|101 → 6|5 = **65₈**

---

**Q39.** How to convert Binary to Hexadecimal?
> **Answer:** Group bits in 4s from right.
> 
> **Example:** 11011010 → 1101|1010 → D|A = **DA₁₆**
> (Since 1101=13=D, 1010=10=A)

---

**Q40.** What are the three methods for representing Signed Integers?
> **Answer:**
> 1. **Sign-Magnitude:** First bit for sign (0=+, 1=-), rest for magnitude
> 2. **1's Complement:** Flip all bits for negative
> 3. **2's Complement:** 1's Complement + 1 (The Standard!)

---

**Q41.** What is 2's Complement? Why is it preferred?
> **Answer:** 2's Complement = 1's Complement + 1
> 
> **Why preferred:**
> 1. Only ONE representation for zero
> 2. Makes arithmetic circuits simpler
> 3. Subtraction becomes Addition

---

**Q42.** Find the 2's Complement of -12 in 8-bit.
> **Answer:**
> 1. **Step 1:** Write +12 in binary: 0000 1100
> 2. **Step 2:** 1's Complement (flip): 1111 0011
> 3. **Step 3:** Add 1: 1111 0011 + 1 = **1111 0100**

---

**Q43.** What is the shortcut for finding 2's Complement?
> **Answer:** Start from right (LSB):
> 1. Copy all bits up to and including the first '1'
> 2. Flip all remaining bits to the left
> 
> **Example for -12 (0000 1100):**
> - Right to left: copy `100`
> - Flip rest: `0000 1` → `1111 0`
> - **Result:** 1111 0100

---

**Q44.** What is the range of integers for n bits?
> **Answer:**
> - **Unsigned:** 0 to 2ⁿ - 1
> - **Signed (2's Complement):** -2⁽ⁿ⁻¹⁾ to +2⁽ⁿ⁻¹⁾ - 1
> 
> **For 8-bit:**
> - Unsigned: 0 to 255
> - Signed: -128 to +127

---

**Q45.** What is Floating Point Representation?
> **Answer:** A way to represent decimal numbers using Scientific Notation in binary:
> **±1.mantissa × 2^exponent**
> 
> Called "Floating Point" because the decimal point floats based on exponent.

---

**Q46.** What are the three parts of IEEE 754 Single Precision (32-bit)?
> **Answer:**
> | Sign | Exponent | Mantissa |
> |------|----------|----------|
> | 1 bit | 8 bits | 23 bits |
> 
> - **Sign:** 0 = +, 1 = -
> - **Exponent:** Actual + 127 (Bias)
> - **Mantissa:** Digits after decimal (Hidden "1" rule)

---

**Q47.** What is the Bias in IEEE 754?
> **Answer:** To store both positive and negative exponents, we add a bias:
> - **Single Precision:** Bias = 127
> - **Double Precision:** Bias = 1023
> 
> **Stored Exponent = Actual Exponent + Bias**

---

**Q48.** Convert 12.5 to IEEE 754 format (show steps).
> **Answer:**
> 1. **Convert to Binary:** 12 = 1100, 0.5 = 0.1 → 1100.1
> 2. **Normalize:** 1100.1 → 1.1001 × 2³
> 3. **Exponent:** 3 + 127 = 130 = 10000010
> 4. **Mantissa:** 1001 (drop leading 1.) → 10010000...
> 5. **Sign:** 0 (positive)
> 
> **Final:** 0 | 10000010 | 10010000000000000000000

---

**Q49.** What is Double Precision (64-bit)?
> **Answer:**
> - **Sign:** 1 bit
> - **Exponent:** 11 bits (Bias = 1023)
> - **Mantissa:** 52 bits (high precision)

---

# Part 3: Computer Arithmetic

---

**Q50.** What are the rules for Binary Addition?
> **Answer:**
> - 0 + 0 = 0
> - 0 + 1 = 1
> - 1 + 0 = 1
> - 1 + 1 = 10 (Sum 0, Carry 1)
> - 1 + 1 + 1 = 11 (Sum 1, Carry 1)

---

**Q51.** How is subtraction performed using 2's Complement?
> **Answer:** A - B = A + (-B)
> 
> Where (-B) is 2's complement of B.
> 
> **Example: 7 - 5 in 4-bit:**
> - 7 = 0111
> - -5 = 2's comp of 0101 = 1011
> - 0111 + 1011 = 10010
> - Discard carry → 0010 = **2**

---

**Q52.** What is Booth's Multiplication Algorithm? Why is it used?
> **Answer:** Booth's Algorithm is used for signed multiplication (2's complement).
> 
> **Key Insight:** Strings of 1s can be treated efficiently.
> Example: 00111100 = (2⁶ - 2²) instead of four additions.
> 
> Handles positive and negative numbers uniformly without correction.

---

**Q53.** What is the decision table for Booth's Algorithm?
> **Answer:**
> | Q₀ | Q₋₁ | Operation |
> |:---:|:---:|:---|
> | 0 | 0 | No operation, only ASR |
> | 0 | 1 | AC = AC + M, then ASR |
> | 1 | 0 | AC = AC - M, then ASR |
> | 1 | 1 | No operation, only ASR |
> 
> ASR = Arithmetic Shift Right

---

**Q54.** Multiply 7 × 3 using Booth's Algorithm.
> **Answer:**
> - M = 0111 (7), Q = 0011 (3), -M = 1001
> 
> | Step | AC | Q | Q₋₁ | Operation |
> |:---:|:---:|:---:|:---:|:---|
> | Initial | 0000 | 0011 | 0 | Start |
> | 1st | 1001→1100 | 1001 | 1 | Q₀Q₋₁=10: AC-M, ASR |
> | 2nd | 1110 | 0100 | 1 | Q₀Q₋₁=11: ASR only |
> | 3rd | 0101→0010 | 1010 | 0 | Q₀Q₋₁=01: AC+M, ASR |
> | 4th | 0001 | 0101 | 0 | Q₀Q₋₁=00: ASR only |
> 
> **Result:** 00010101 = **21** ✓

---

**Q55.** What is Restoring Division Algorithm?
> **Answer:** "Restoring" means if we subtract the divisor and result is negative, we add the divisor back to restore.
> 
> **Procedure:**
> 1. Initialize A=0, Q=Dividend, M=Divisor
> 2. Shift Left AQ
> 3. Subtract: A ← A - M
> 4. If A negative: Q₀=0, Restore (A=A+M)
> 5. If A positive: Q₀=1, No restore
> 6. Repeat n times
> 7. Q = Quotient, A = Remainder

---

**Q56.** What is Non-Restoring Division? How is it different?
> **Answer:** Instead of restoring immediately after negative result, it keeps the negative remainder and adds M in the next step.
> 
> **Key Difference:**
> - **Restoring:** If A < 0, restore immediately, then shift
> - **Non-Restoring:** If A < 0, don't restore! Just shift, then add M next step
> 
> **Non-Restoring is faster** (avoids extra restore step).

---

**Q57.** Divide 11 ÷ 3 using Restoring Division.
> **Answer:**
> - Dividend Q = 1011 (11), Divisor M = 00011 (3)
> 
> | n | A | Q | Operation |
> |:---:|:---:|:---:|:---|
> | 4 | 00000 | 1011 | Initialize |
> | | 00001→11110 | 0110 | Shift, A-M, A<0→Q₀=0, Restore |
> | 3 | 00010→11111 | 1100 | Shift, A-M, A<0→Q₀=0, Restore |
> | 2 | 00101→00010 | 1001 | Shift, A-M, A≥0→Q₀=1 |
> | 1 | 00101→00010 | 0011 | Shift, A-M, A≥0→Q₀=1 |
> 
> **Quotient:** 0011 = **3**, **Remainder:** 00010 = **2** ✓

---

**Q58.** Compare Restoring vs Non-Restoring Division.
> **Answer:**
> | Feature | Restoring | Non-Restoring |
> |:---|:---|:---|
> | **Restore Step** | Always if A<0 | Never during iteration |
> | **Operations/cycle** | Up to 2 | Exactly 1 |
> | **Speed** | Slower | Faster |
> | **Final Correction** | Not needed | May need if A<0 |

---

**Q59.** What is the normalized form in Floating-Point?
> **Answer:** Mantissa is always in range 0.1 ≤ |f| < 1.0
> 
> **Examples:**
> - 0.00596 → 0.596 × 10⁻²
> - 65.7452 → 0.657452 × 10²
> - -486.8 → -0.4868 × 10³

---

**Q60.** What are the steps for Floating-Point Addition?
> **Answer:**
> 1. **Set E_z** = larger exponent
> 2. **Shift Right** smaller number's mantissa by exponent difference
> 3. **Add** mantissas: f_z = f_x + f_y
> 4. **Normalize** if |f_z| > 1

---

**Q61.** Add 0.964572 E2 and 0.586351 E5.
> **Answer:**
> 1. E_z = 5 (larger)
> 2. Align: 0.964572 E2 → 0.000964 E5
> 3. Add: 0.000964 + 0.586351 = 0.587315
> 4. Already normalized
> 
> **Result:** 0.587315 E5

---

**Q62.** What are the steps for Floating-Point Multiplication?
> **Answer:**
> 1. **Multiply** mantissas: f_z = f_x × f_y
> 2. **Add** exponents: E_z = E_x + E_y
> 3. **Combine:** z = f_z × 10^E_z
> 4. **Normalize** if necessary

---

**Q63.** Multiply 0.200000 E4 and 0.400000 E-2.
> **Answer:**
> 1. Multiply: 0.2 × 0.4 = 0.08
> 2. Add exponents: 4 + (-2) = 2
> 3. Combine: 0.08 × 10²
> 4. Normalize: 0.08 → 0.8, E = 2-1 = 1
> 
> **Result:** 0.800000 E1

---

**Q64.** What are the steps for Floating-Point Division?
> **Answer:**
> 1. **Divide** mantissas: f_z = f_x / f_y
> 2. **Subtract** exponents: E_z = E_x - E_y
> 3. **Combine:** z = f_z × 10^E_z
> 4. **Normalize** if necessary

---

**Q65.** Summarize Floating-Point Arithmetic Rules.
> **Answer:**
> | Operation | Mantissa | Exponent |
> |:---:|:---:|:---:|
> | **Addition** | Align, then Add | Use larger |
> | **Subtraction** | Align, then Subtract | Use larger |
> | **Multiplication** | Multiply | Add |
> | **Division** | Divide | Subtract |
> 
> **Always Normalize the final result!**

---

# Part 4: Decimal Arithmetic (BCD)

---

**Q66.** What is BCD (Binary Coded Decimal)?
> **Answer:** Instead of converting whole number to binary, convert each decimal digit to 4-bit binary separately.
> 
> **Example:** 472 → 0100 0111 0010
> 
> **Rule:** Each digit (0-9) uses exactly 4 bits.

---

**Q67.** Write the BCD codes for digits 0-9.
> **Answer:**
> | Decimal | BCD | Decimal | BCD |
> |:---:|:---:|:---:|:---:|
> | 0 | 0000 | 5 | 0101 |
> | 1 | 0001 | 6 | 0110 |
> | 2 | 0010 | 7 | 0111 |
> | 3 | 0011 | 8 | 1000 |
> | 4 | 0100 | 9 | 1001 |
> 
> **Invalid:** 1010-1111 (10-15 don't exist in decimal!)

---

**Q68.** Convert 59 to BCD.
> **Answer:** 
> - 5 = 0101
> - 9 = 1001
> - **BCD:** 0101 1001

---

**Q69.** Convert BCD 0011 0111 to Decimal.
> **Answer:**
> - 0011 = 3
> - 0111 = 7
> - **Decimal:** 37

---

**Q70.** What is the difference between Packed and Unpacked BCD?
> **Answer:**
> | Type | Digits/Byte | Example: 59 | Use Case |
> |:---|:---:|:---|:---|
> | **Packed** | 2 | 0101 1001 (1 byte) | Storage efficient |
> | **Unpacked** | 1 | 0000 0101, 0000 1001 (2 bytes) | Easier processing |

---

**Q71.** What is the Golden Rule for BCD Addition?
> **Answer:** After adding two BCD digits:
> - If result > 9 (1010-1111) → **Add 6 (0110)**
> - If there's a carry out → **Add 6 (0110)**
> 
> **Why add 6?** Binary has 16 values (0-15), BCD uses only 10 (0-9). We skip 6 unused codes.

---

**Q72.** Add 25 + 33 in BCD.
> **Answer:**
> ```
>     0010 0101   (25)
>   + 0011 0011   (33)
>   ───────────
>     0101 1000
> ```
> - Units: 0101+0011 = 1000 (8) ✓ Valid
> - Tens: 0010+0011 = 0101 (5) ✓ Valid
> 
> **No correction needed!** Result: **58**

---

**Q73.** Add 47 + 35 in BCD (with correction).
> **Answer:**
> ```
>     0100 0111   (47)
>   + 0011 0101   (35)
>   ───────────
>     0111 1100   ← Units = 1100 (12) > 9!
>   +      0110   ← Add 6 to units
>   ───────────
>     1000 0010   = 82
> ```
> **Result:** **82** ✓

---

**Q74.** What is 10's Complement Subtraction in BCD?
> **Answer:** Like 2's complement for binary!
> 
> **10's Complement of digit = 10 - digit**
> Or: **9's Complement + 1**
> 
> **Procedure for A - B:**
> 1. Find 10's complement of B
> 2. Add A + (10's complement of B)
> 3. Carry out → Positive result (discard carry)
> 4. No carry → Negative (take 10's complement)

---

**Q75.** Subtract 72 - 48 in BCD.
> **Answer:**
> 1. **10's complement of 48:** 9's comp = 51, +1 = 52
> 2. **Add:** 72 + 52
> ```
>     0111 0010   (72)
>   + 0101 0010   (52)
>   ───────────
>     1100 0100   ← Tens needs correction
>   + 0110
>   ───────────
>     0010 0100   with carry out
> ```
> 3. Carry out = 1 (discard, positive)
> 
> **Result:** **24** ✓

---

**Q76.** What happens in BCD subtraction when there's no carry out?
> **Answer:** Result is NEGATIVE.
> 
> **Example:** 34 - 57
> 1. 10's comp of 57 = 43
> 2. 34 + 43 = 77 (no carry)
> 3. No carry → Negative
> 4. 10's comp of 77 = 23
> 
> **Result:** **-23**

---

**Q77.** What are the advantages of BCD?
> **Answer:**
> 1. **Exact Decimal:** No rounding errors for money!
> 2. **Easy Conversion:** Direct mapping decimal ↔ BCD
> 3. **Human Readable:** Each nibble = one digit
> 4. **Financial Apps:** Banks, ATMs, calculators

---

**Q78.** What are the disadvantages of BCD?
> **Answer:**
> 1. **Wastes Space:** ~20% more bits than pure binary
> 2. **Slower:** Needs correction steps after arithmetic
> 3. **Complex Hardware:** Circuits more complicated

---

**Q79.** Why is BCD important for financial applications?
> **Answer:** In binary, 0.1₁₀ cannot be exactly represented! This causes rounding errors.
> 
> **Example:** $0.10 might become $0.0999999... in binary.
> 
> BCD represents $0.10 exactly as 0001 0000, so no rounding errors in money calculations.

---

**Q80.** Summarize BCD Addition Rules.
> **Answer:**
> | Condition | Action |
> |:---|:---|
> | Sum ≤ 9 (0000-1001) | No correction |
> | Sum > 9 (1010-1111) | Add 6 (0110) |
> | Carry out from nibble | Add 6 (0110) |

---

**Q81.** Summarize BCD Subtraction Rules.
> **Answer:**
> | Step | Action |
> |:---|:---|
> | 1 | Find 10's complement of subtrahend |
> | 2 | Add instead of subtract |
> | 3 | Carry out? → Positive result |
> | 4 | No carry? → Negative, take 10's complement |

---

