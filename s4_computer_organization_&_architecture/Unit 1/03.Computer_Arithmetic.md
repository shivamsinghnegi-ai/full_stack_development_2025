# Computer Arithmetic

---

## 1. Addition & Subtraction

### 1.1 Binary Addition
Binary addition follows the same logic as decimal addition but in base 2.

**Rules:**
- $0 + 0 = 0$
- $0 + 1 = 1$
- $1 + 0 = 1$
- $1 + 1 = 10 \quad$ (Sum 0, Carry 1)
- $1 + 1 + 1 = 11 \quad$ (Sum 1, Carry 1)

### 1.2 Signed Addition & Subtraction (2's Complement)
Modern computers use **2's complement** for signed arithmetic because it simplifies hardware by allowing subtraction to be performed as addition.

**Logic:**  
$A - B = A + (-B)$  
Where $(-B)$ is the 2's complement of $B$.

**Steps to find 2's Complement:**
1.  Invert all bits of the number (1's complement).
2.  Add 1 to the result.

**Example: $7 - 5$ using 4-bit 2's complement**
-   $7 = 0111_2$
-   $5 = 0101_2$
-   $-5 = \text{2's complement of } 0101$
    -   Invert: $1010$
    -   Add 1: $1011$
-   Add: $0111$ ($7$) + $1011$ ($-5$)
-   Result: $10010$
-   Discard carry for fixed-bit width $\rightarrow 0010_2 = 2_{10}$. (Correct)


---

## 2. Multiplication Algorithms

### 2.1 Unsigned Multiplication
Simulates manual "pencil-and-paper" multiplication.
-   **Algorithm:** Partial products are generated and shifted.
-   **Hardware:** Requires an Adder, Multiplicand Register, Multiplier Register (shift right), and Accumulator.

### 2.2 Booth's Multiplication Algorithm
Used for **signed multiplication** (2's complement). It handles positive and negative numbers uniformly without separate correction steps.

**Key Insight:** Strings of 1s in the multiplier (e.g., $00111100$) can be treated as $(2^6 - 2^2)$ instead of four additions, reducing operations.

### Booth's Flowchart

![Booth's Algorithm Flowchart](./booths_flowchart.png)

**Decision Table for $Q_0 \cdot Q_{-1}$:**

| $Q_0$ | $Q_{-1}$ | Operation |
|:---:|:---:|:---|
| 0 | 0 | No operation, only ASR |
| 0 | 1 | AC = AC + M, then ASR |
| 1 | 0 | AC = AC - M, then ASR |
| 1 | 1 | No operation, only ASR |

---

### Example 1: Positive × Positive ($7 \times 3$)

**Setup:**
-   **Multiplicand (M):** $(7)_{10} \rightarrow (0111)_2$
-   **Multiplier (Q):** $(3)_{10} \rightarrow (0011)_2$
-   **(-M):** 2's complement of $(0111)_2 \rightarrow (1001)_2$
    -   $0111$
    -   1's complement $\rightarrow 1000$
    -   Add 1 $\rightarrow 1001$
-   **Register Size:** 4 bits
-   **Count:** 4

**Step-by-Step Execution:**

| Step | AC | Q | Q₋₁ | Operation |
|:---:|:---:|:---:|:---:|:---|
| **Initial** | 0000 | 0011 | 0 | Start |
| **1st** | | | | $Q_0 \cdot Q_{-1} = 10$ |
| | 1001 | 0011 | 0 | i) AC = AC - M $(0000 + 1001 = 1001)$ |
| | **1100** | **1001** | **1** | ii) A.S.R. |
| **2nd** | | | | $Q_0 \cdot Q_{-1} = 11$ |
| | **1110** | **0100** | **1** | i) A.S.R. (No add/sub) |
| **3rd** | | | | $Q_0 \cdot Q_{-1} = 01$ |
| | 0101 | 0100 | 1 | i) AC = AC + M $(1110 + 0111 = 0101)$ |
| | **0010** | **1010** | **0** | ii) A.S.R. |
| **4th** | | | | $Q_0 \cdot Q_{-1} = 00$ |
| | **0001** | **0101** | **0** | A.S.R. (No add/sub) |

**Result:**
-   **Final AQ:** $(00010101)_2 = (21)_{10}$
-   **Verification:** $(7)_{10} \times (3)_{10} = +(21)_{10}$ ✓

---

### Example 2: Positive × Negative ($7 \times -3$)

**Setup:**
-   **Multiplicand (M):** $(7)_{10} \rightarrow (0111)_2$
-   **Multiplier (Q):** $(-3)_{10}$
    -   2's complement of 3: $(0011)_2 \rightarrow (1101)_2$
-   **(-M):** 2's complement of $(0111)_2 \rightarrow (1001)_2$
-   **Register Size:** 4 bits
-   **Count:** 4

**Step-by-Step Execution:**

| Step | AC | Q | Q₋₁ | Operation |
|:---:|:---:|:---:|:---:|:---|
| **Initial** | 0000 | 1101 | 0 | Start |
| **1st** | | | | $Q_0 \cdot Q_{-1} = 10$ |
| | 1001 | 1101 | 0 | i) AC = AC - M $(0000 + 1001 = 1001)$ |
| | **1100** | **1110** | **1** | ii) A.S.R. |
| **2nd** | | | | $Q_0 \cdot Q_{-1} = 01$ |
| | 0011 | 1110 | 1 | i) AC = AC + M $(1100 + 0111 = 0011)$ |
| | **0001** | **1111** | **0** | ii) A.S.R. |
| **3rd** | | | | $Q_0 \cdot Q_{-1} = 10$ |
| | 1010 | 1111 | 0 | i) AC = AC - M $(0001 + 1001 = 1010)$ |
| | **1101** | **0111** | **1** | ii) A.S.R. |
| **4th** | | | | $Q_0 \cdot Q_{-1} = 11$ |
| | **1110** | **1011** | **1** | A.S.R. (No add/sub) |

**Result:**
-   **Final AQ:** $(11101011)_2$
-   **Sign bit = 1** → Negative number
-   **Magnitude:** 2's complement of $11101011$:
    -   Invert: $00010100$
    -   Add 1: $00010101 = (21)_{10}$
-   **Final Answer:** $-21$
-   **Verification:** $(7)_{10} \times (-3)_{10} = -(21)_{10}$ ✓

---

### Example 3: Negative × Negative ($-7 \times -3$)

**Setup:**
-   **Multiplicand (M):** $(-7)_{10} \rightarrow (1001)_2$ (2's complement)
-   **Multiplier (Q):** $(-3)_{10} \rightarrow (1101)_2$ (2's complement)
-   **(-M):** 2's complement of $(1001)_2 \rightarrow (0111)_2$
-   **Register Size:** 4 bits
-   **Count:** 4

**Step-by-Step Execution:**

| Step | AC | Q | Q₋₁ | Operation |
|:---:|:---:|:---:|:---:|:---|
| **Initial** | 0000 | 1101 | 0 | Start |
| **1st** | | | | $Q_0 \cdot Q_{-1} = 10$ |
| | 0111 | 1101 | 0 | i) AC = AC - M $(0000 - 1001 = 0000 + 0111 = 0111)$ |
| | **0011** | **1110** | **1** | ii) A.S.R. |
| **2nd** | | | | $Q_0 \cdot Q_{-1} = 01$ |
| | 1100 | 1110 | 1 | i) AC = AC + M $(0011 + 1001 = 1100)$ |
| | **1110** | **0111** | **0** | ii) A.S.R. |
| **3rd** | | | | $Q_0 \cdot Q_{-1} = 10$ |
| | 0101 | 0111 | 0 | i) AC = AC - M $(1110 + 0111 = 0101)$ |
| | **0010** | **1011** | **1** | ii) A.S.R. |
| **4th** | | | | $Q_0 \cdot Q_{-1} = 11$ |
| | **0001** | **0101** | **1** | A.S.R. (No add/sub) |

**Result:**
-   **Final AQ:** $(00010101)_2 = (21)_{10}$
-   **Sign bit = 0** → Positive number
-   **Final Answer:** $+21$
-   **Verification:** $(-7)_{10} \times (-3)_{10} = +(21)_{10}$ ✓

---

## 3. Division Algorithms

### 3.1 Overview
Division ($Dividend \div Divisor = Quotient, Remainder$) is more complex than multiplication as it involves guessing and verifying.

### 3.2 Restoring Division Algorithm (Unsigned)
"Restoring" means if we subtract the divisor and the result is negative (we "guessed" wrong), we add the divisor back to restore the partial remainder.

### Restoring Division Flowchart

![Restoring Division Flowchart](./restoring_division_flowchart.png)

**Procedure:**
1.  Initialize $A = 0$, $Q = Dividend$, $M = Divisor$. Count = $n$.
2.  **Shift Left** $A, Q$ combined.
3.  **Subtract:** $A \leftarrow A - M$.
4.  **Check Sign of A:**
    -   If $A < 0$ (MSB is 1):
        -   $Q_0 = 0$ (Set last bit of Q to 0).
        -   **Restore:** $A \leftarrow A + M$.
    -   If $A \ge 0$ (MSB is 0):
        -   $Q_0 = 1$ (Set last bit of Q to 1).
        -   Do NOT restore.
5.  Decrement count. Repeat $n$ times.
6.  **Quotient** is in $Q$, **Remainder** is in $A$.

---

### Example: $7 \div 3$ (4-bit)

**Setup:**
-   **Dividend (Q):** $(7)_{10} \rightarrow (0111)_2$
-   **Divisor (M):** $(3)_{10} \rightarrow (0011)_2$
-   **A (Accumulator):** $(0000)_2$
-   **Register Size:** 4 bits
-   **Count:** 4

**Step-by-Step Execution:**

| Cycle | Operation | A | Q | Q₀ | Description |
|:---:|:---|:---:|:---:|:---:|:---|
| **Initial** | - | 0000 | 0111 | - | Start |
| **1st** | Shift Left | 0000 | 1110 | - | Shift A,Q left |
| | A = A - M | 1101 | 1110 | - | $0000 - 0011 = 1101$ (negative) |
| | A < 0? **Yes** | | | **0** | $Q_0 = 0$ |
| | **Restore** | **0000** | **1110** | 0 | A = A + M $(1101 + 0011 = 0000)$ |
| **2nd** | Shift Left | 0001 | 1100 | - | Shift A,Q left |
| | A = A - M | 1110 | 1100 | - | $0001 - 0011 = 1110$ (negative) |
| | A < 0? **Yes** | | | **0** | $Q_0 = 0$ |
| | **Restore** | **0001** | **1100** | 0 | A = A + M $(1110 + 0011 = 0001)$ |
| **3rd** | Shift Left | 0011 | 1000 | - | Shift A,Q left |
| | A = A - M | 0000 | 1000 | - | $0011 - 0011 = 0000$ (non-negative) |
| | A < 0? **No** | | | **1** | $Q_0 = 1$ |
| | No Restore | **0000** | **1001** | 1 | Keep A as is |
| **4th** | Shift Left | 0001 | 0010 | - | Shift A,Q left |
| | A = A - M | 1110 | 0010 | - | $0001 - 0011 = 1110$ (negative) |
| | A < 0? **Yes** | | | **0** | $Q_0 = 0$ |
| | **Restore** | **0001** | **0010** | 0 | A = A + M $(1110 + 0011 = 0001)$ |

**Result:**
-   **Quotient (Q):** $(0010)_2 = (2)_{10}$
-   **Remainder (A):** $(0001)_2 = (1)_{10}$
-   **Verification:** $7 = 3 \times 2 + 1$ ✓

### 3.3 Non-Restoring Division
Instead of adding back $M$ immediately after a negative result, it keeps the negative remainder and adds $M$ in the next step (after shift). It is slightly faster in hardware.

---
