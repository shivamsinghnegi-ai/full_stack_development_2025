# Timing & Control + Memory-Reference Instructions

---

# 1. Timing and Control Unit

## 1.1 What is the Control Unit?

The **Control Unit (CU)** is the "brain" of the CPU that:
- Generates **timing signals** (T₀, T₁, T₂, ...)
- Decodes instructions
- Generates **control signals** for all operations

```
┌─────────────────────────────────────────────────────────────┐
│                      CONTROL UNIT                           │
│                                                             │
│   Inputs:                          Outputs:                 │
│   ├── IR (instruction)             ├── Timing signals       │
│   ├── Flags (E, I, etc.)           ├── Register controls    │
│   └── Clock                        ├── Memory controls      │
│                                    └── ALU controls         │
└─────────────────────────────────────────────────────────────┘
```

---

## 1.2 Control Unit Components

```
┌──────────────────────────────────────────────────────────────────┐
│                                                                  │
│  ┌─────────┐     ┌───────────────┐     ┌──────────────────────┐  │
│  │  CLOCK  │ ──→ │   SEQUENCE    │ ──→ │  TIMING DECODER      │  │
│  │         │     │   COUNTER     │     │  (4×16 decoder)      │  │
│  └─────────┘     │   (SC)        │     └──────────┬───────────┘  │
│                  └───────────────┘                │              │
│                                          T₀ T₁ T₂ T₃ ... T₁₅     │
│                                                   │              │
│  ┌─────────────────────┐                          │              │
│  │  IR(12-14) ──→      │     ┌────────────────────┴────────┐     │
│  │  INSTRUCTION        │ ──→ │      CONTROL LOGIC          │     │
│  │  DECODER (3×8)      │     │      (generates all         │     │
│  │  D₀ D₁ D₂...D₇      │     │       control signals)      │     │
│  └─────────────────────┘     └─────────────────────────────┘     │
│                                                                  │
└──────────────────────────────────────────────────────────────────┘
```

### Key Components:

| Component | Function |
|-----------|----------|
| **Clock** | Provides timing pulses |
| **Sequence Counter (SC)** | Counts 0,1,2,3... for timing |
| **Timing Decoder** | Converts SC output → T₀,T₁,T₂... |
| **Instruction Decoder** | Converts opcode → D₀,D₁...D₇ |
| **Control Logic** | Combines all inputs → control signals |

---

## 1.3 Two Types of Control Unit Design

### Type 1: Hardwired Control Unit

```
┌───────────────────────────────────────────────────────────────┐
│                    HARDWIRED CONTROL                          │
│                                                               │
│  IR ──→ ┌──────────────────────────┐                          │
│         │   COMBINATIONAL LOGIC    │ ──→ Control Signals      │
│  SC ──→ │   (Gates: AND, OR, NOT)  │                          │
│         └──────────────────────────┘                          │
│                                                               │
│  The logic is FIXED in hardware (wires and gates)             │
└───────────────────────────────────────────────────────────────┘
```

**Characteristics:**
- Uses **gates** (AND, OR, NOT) to generate control signals
- Logic is **fixed** - cannot be changed without rewiring
- **Very fast** execution
- **Complex** for large instruction sets

**Example Control Signal:**
```
To execute: D₄T₄: PC ← AR (BUN instruction at T₄)

Control signal = D₄ AND T₄
                 ↓
         ┌───────────────┐
   D₄ ───┤     AND       ├──→ PC load signal
   T₄ ───┤               │
         └───────────────┘
```

---

### Type 2: Microprogrammed Control Unit

```
┌───────────────────────────────────────────────────────────────┐
│                 MICROPROGRAMMED CONTROL                       │
│                                                               │
│  ┌──────────────────────────────────────────────────────┐     │
│  │              CONTROL MEMORY (ROM)                    │     │
│  │  ┌────────────────────────────────────────────────┐  │     │
│  │  │ Address 0: Microinstruction for Fetch T₀       │  │     │
│  │  │ Address 1: Microinstruction for Fetch T₁       │  │     │
│  │  │ Address 2: Microinstruction for Fetch T₂       │  │     │
│  │  │    ...                                         │  │     │
│  │  │ Address n: Microinstruction for ADD T₄         │  │     │
│  │  └────────────────────────────────────────────────┘  │     │
│  └──────────────────────────────────────────────────────┘     │
│                           │                                   │
│                           ▼                                   │
│                   Control Signals                             │
│                                                               │
└───────────────────────────────────────────────────────────────┘
```

**Characteristics:**
- Control signals stored in **Control Memory (ROM)**
- Each instruction has a **microprogram** (sequence of microinstructions)
- **Easy to modify** - just change ROM contents
- **Slower** than hardwired (needs memory access)
- **Flexible** - can add new instructions easily

---

## 1.4 Comparison Table (Very Important for Exam!)

| Feature | Hardwired | Microprogrammed |
|---------|-----------|-----------------|
| **Speed** |  Faster |  Slower |
| **Flexibility** |  Difficult to change |  Easy to modify |
| **Complexity** | Complex for large ISA | Simpler design |
| **Cost** | Higher (more gates) | Lower (less hardware) |
| **Debugging** | Very difficult |  Easy |
| **Used in** | RISC processors | CISC processors |
| **Control** | Combinational logic | Control memory (ROM) |

**Exam Tip:** Remember - "**H**ardwired = **H**igh-speed, **M**icroprogrammed = **M**odifiable"

---

## 1.5 Control Signal Equations (Exam Important!)

### Fetch Cycle Control Signals:
```
T₀: AR ← PC
    Control: T₀ (enable PC to bus, load AR)

T₁: IR ← M[AR], PC ← PC + 1
    Control: T₁ (read memory, load IR, increment PC)

T₂: Decode, AR ← IR(0-11), I ← IR(15)
    Control: T₂ (decode opcode, transfer address)
```

### Register Reference (D₇I'T₃):
```
When opcode = 111 AND I = 0 AND T₃:
Execute register operation based on IR(0-11)
```

### I/O Instructions (D₇IT₃):
```
When opcode = 111 AND I = 1 AND T₃:
Execute I/O operation based on IR(0-11)
```

---

# 2. Memory-Reference Instructions (Detailed)

## 2.1 All 7 MRI with Micro-operations

### 1. AND (Opcode: 000)
**Operation:** AC ← AC ∧ M[EA]

```
Direct (I=0):                    Indirect (I=1):
D₀T₄: DR ← M[AR]                 D₀T₄: DR ← M[AR]
D₀T₅: AC ← AC ∧ DR, SC ← 0       D₀T₅: AC ← AC ∧ DR, SC ← 0
```

**Example:**
```
AC = 1010 1100 (binary)
M[AR] = 1100 0011
After AND: AC = 1000 0000
```

---

### 2. ADD (Opcode: 001)
**Operation:** AC ← AC + M[EA], E ← Carry

```
D₁T₄: DR ← M[AR]
D₁T₅: AC ← AC + DR, E ← Cout, SC ← 0
```

**Example:**
```
AC = 0000 0101 (5)
M[AR] = 0000 0011 (3)
After ADD: AC = 0000 1000 (8), E = 0
```

---

### 3. LDA - Load AC (Opcode: 010)
**Operation:** AC ← M[EA]

```
D₂T₄: DR ← M[AR]
D₂T₅: AC ← DR, SC ← 0
```

**Example:**
```
M[500] = 1234
After LDA 500: AC = 1234
```

---

### 4. STA - Store AC (Opcode: 011)
**Operation:** M[EA] ← AC

```
D₃T₄: M[AR] ← AC, SC ← 0
```

**Note:** Only 1 timing cycle needed (no read required)

**Example:**
```
AC = 5678
After STA 500: M[500] = 5678
```

---

### 5. BUN - Branch Unconditional (Opcode: 100)
**Operation:** PC ← EA

```
D₄T₄: PC ← AR, SC ← 0
```

**Use:** Jump to another location (GOTO)

**Example:**
```
BUN 200
After: PC = 200 (next instruction fetched from 200)
```

---

### 6. BSA - Branch and Save Return Address (Opcode: 101)
**Operation:** M[EA] ← PC, PC ← EA + 1

```
D₅T₄: M[AR] ← PC, AR ← AR + 1
D₅T₅: PC ← AR, SC ← 0
```

**Use:** Subroutine call

```
Memory Layout:
┌──────────────────────────────────────┐
│  Before BSA 100:  PC = 25            │
│                                      │
│  Address 100: [Return Address = 25]  │ ← Saved here
│  Address 101: [First instruction]    │ ← PC jumps here
│         ...                          │
│  Last instruction: BUN I 100         │ ← Returns to 25
└──────────────────────────────────────┘
```

---

### 7. ISZ - Increment and Skip if Zero (Opcode: 110)
**Operation:** M[EA] ← M[EA] + 1, if result = 0 then PC ← PC + 1

```
D₆T₄: DR ← M[AR]
D₆T₅: DR ← DR + 1
D₆T₆: M[AR] ← DR, if (DR = 0) then PC ← PC + 1, SC ← 0
```

**Use:** Loop counter

**Example: Loop 5 times**
```
      LDA CTR      ; Load counter (initially -5)
LOOP: ...          ; Loop body
      ISZ CTR      ; Increment counter
      BUN LOOP     ; If not zero, repeat
      ...          ; Exit (executes when CTR becomes 0)
CTR:  DEC -5       ; Counter initialized to -5
```

---

## 2.2 Summary Table (Memorize This!)

| Instruction | Opcode | T₄ | T₅ | T₆ | Purpose |
|-------------|--------|----|----|----|---------| 
| **AND** | 000 | DR←M[AR] | AC←AC∧DR | - | Bitwise AND |
| **ADD** | 001 | DR←M[AR] | AC←AC+DR, E←Cout | - | Addition |
| **LDA** | 010 | DR←M[AR] | AC←DR | - | Load to AC |
| **STA** | 011 | M[AR]←AC | - | - | Store from AC |
| **BUN** | 100 | PC←AR | - | - | Unconditional jump |
| **BSA** | 101 | M[AR]←PC, AR←AR+1 | PC←AR | - | Subroutine call |
| **ISZ** | 110 | DR←M[AR] | DR←DR+1 | M[AR]←DR, skip if 0 | Loop counter |

---

## 2.3 Register Reference Instructions (Quick Reference)

These execute at **D₇I'T₃** (Opcode=111, I=0, at T₃):

| Instruction | Hex | Micro-operation |
|-------------|-----|-----------------|
| CLA | 7800 | AC ← 0 |
| CLE | 7400 | E ← 0 |
| CMA | 7200 | AC ← AC' (complement) |
| CME | 7100 | E ← E' |
| CIR | 7080 | Circular right shift |
| CIL | 7040 | Circular left shift |
| INC | 7020 | AC ← AC + 1 |
| SPA | 7010 | if(AC₁₅=0) PC←PC+1 (skip if positive) |
| SNA | 7008 | if(AC₁₅=1) PC←PC+1 (skip if negative) |
| SZA | 7004 | if(AC=0) PC←PC+1 (skip if zero) |
| SZE | 7002 | if(E=0) PC←PC+1 |
| HLT | 7001 | S ← 0 (halt) |

---

## 2.4 Circular Shift Operations (Diagram)

### CIR (Circular Right):
```
Before: E│AC₁₅ AC₁₄ AC₁₃ ... AC₁ AC₀│
        │                            │
After:  │AC₀│E   AC₁₅ AC₁₄ ... AC₂ AC₁│
        
E goes to AC₁₅, AC₀ goes to E
```

### CIL (Circular Left):
```
Before: │AC₁₅ AC₁₄ AC₁₃ ... AC₁ AC₀│E
        │                            │
After:  │AC₁₄ AC₁₃ AC₁₂ ... AC₀  E │AC₁₅

AC₁₅ goes to E, E goes to AC₀
```

---

## 2.5 Complete Flowchart for Instruction Execution

```
                     START
                       │
             ┌─────────┴─────────┐
             │  FETCH PHASE      │
             │  T₀: AR ← PC      │
             │  T₁: IR ← M[AR]   │
             │      PC ← PC + 1  │
             │  T₂: Decode       │
             └─────────┬─────────┘
                       │
                       ▼
              ┌────────────────┐
              │  Opcode = 111? │
              └────────┬───────┘
                       │
         ┌─────────────┼─────────────┐
         │ NO          │             │ YES
         ▼             │             ▼
   ┌───────────┐       │      ┌───────────┐
   │  I = 1?   │       │      │  I = 1?   │
   └─────┬─────┘       │      └─────┬─────┘
         │             │            │
    ┌────┴────┐        │       ┌────┴────┐
   YES       NO        │      YES       NO
    │         │        │       │         │
    ▼         ▼        │       ▼         ▼
┌───────┐ ┌───────┐    │  ┌───────┐ ┌───────┐
│T₃:AR← │ │Execute│    │  │  I/O  │ │ Reg   │
│M[AR]  │ │at T₄  │    │  │ Inst  │ │ Ref   │
└───┬───┘ └───────┘    │  │ at T₃ │ │ at T₃ │
    │                  │  └───────┘ └───────┘
    ▼                  │
┌───────┐              │
│Execute│              │
│at T₄  │              │
└───────┘              │
```

---

## Quick Revision Points

1. **Hardwired** = Fast but inflexible
2. **Microprogrammed** = Slow but flexible
3. **Fetch takes 3 cycles** (T₀, T₁, T₂)
4. **Indirect adds 1 cycle** (T₃)
5. **STA is fastest MRI** (only 1 execute cycle)
6. **ISZ is slowest MRI** (3 execute cycles)
7. **BSA** saves PC, then jumps (for subroutines)
8. **ISZ** used for loop counting (counts up from negative)

---
