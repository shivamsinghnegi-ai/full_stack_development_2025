# 1. Computer Instructions

## 1.1 What are Computer Instructions?

**Computer instructions** are binary codes that specify operations to be performed by the computer. The basic computer has a **16-bit instruction word**.

## 1.2 Instruction Format

```
┌─────────────────────────────────────────────────────────────────┐
│                    INSTRUCTION FORMAT (16 bits)                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌───────┬───────────────┬──────────────────────────────────┐   │
│  │ I (1) │  Opcode (3)   │         Address (12)             │   │
│  └───────┴───────────────┴──────────────────────────────────┘   │
│    15      14  13  12       11  10  9  8  7  6  5  4  3  2  1  0 │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

- **Bit 15 (I)**: Mode bit (0 = Direct, 1 = Indirect)
- **Bits 14-12 (Opcode)**: Operation code (8 possible operations for memory-reference)
- **Bits 11-0 (Address)**: Memory address or operation specification

## 1.3 Types of Instructions

All instructions in a basic computer are **16 bits** long. Based on what they do, instructions are divided into **3 types**:

```
┌─────────────────────────────────────────────────────────┐
│                 3 TYPES OF INSTRUCTIONS                 │
├─────────────────────────────────────────────────────────┤
│  1. Memory Reference   → Works with memory (RAM)        │
│  2. Register Reference → Works with CPU registers only  │
│  3. I/O Instructions   → Works with input/output devices│
└─────────────────────────────────────────────────────────┘
```

---

### Type 1: Memory Reference Instructions

**What it does:** These instructions need to **access memory** to get or store data.

**Format:**
```
   ┌─────┬─────────┬──────────────────┐
   │  I  │ Opcode  │     Address      │
   │(1)  │  (3)    │      (12)        │
   └─────┴─────────┴──────────────────┘
    bit    bits       bits
    15    14-12       11-0
```

**How to identify:**
- Opcode = **000 to 110** (any value from 0 to 6)

**I bit decides addressing mode:**
- I = 0 → **Direct** (address field has the actual memory location)
- I = 1 → **Indirect** (address field points to another location)

**All 7 Memory Reference Instructions:**

| Symbol | What it does | Simple Meaning |
|--------|-------------|----------------|
| **AND** | AC ← AC AND Memory | Perform AND operation |
| **ADD** | AC ← AC + Memory | Add memory value to AC |
| **LDA** | AC ← Memory | Load value from memory to AC |
| **STA** | Memory ← AC | Store AC value to memory |
| **BUN** | PC ← Address | Jump to another instruction |
| **BSA** | Save PC, then jump | Call a subroutine |
| **ISZ** | Memory++, skip if 0 | Increment and skip if zero |

---

### Type 2: Register Reference Instructions

**What it does:** These instructions work **only on registers** (AC, E). No memory access needed!

**Format:**
```
   ┌─────┬─────────┬──────────────────┐
   │  0  │  111    │  Reg. Operation  │
   └─────┴─────────┴──────────────────┘
    I=0   Opcode      Operation bits
```

**How to identify:**
```
┌─────────────────────────────────┐
│  I = 0  AND  Opcode = 111       │
└─────────────────────────────────┘
```

**All 12 Register Reference Instructions:**

| Symbol | What it does | Simple Meaning |
|--------|-------------|----------------|
| **CLA** | AC ← 0 | Clear the Accumulator |
| **CLE** | E ← 0 | Clear the carry flag E |
| **CMA** | AC ← NOT(AC) | Complement (flip) all bits of AC |
| **CME** | E ← NOT(E) | Complement E |
| **CIR** | Rotate right | Circular shift right through E |
| **CIL** | Rotate left | Circular shift left through E |
| **INC** | AC ← AC + 1 | Add 1 to AC |
| **SPA** | Skip if AC > 0 | Skip next instruction if positive |
| **SNA** | Skip if AC < 0 | Skip next instruction if negative |
| **SZA** | Skip if AC = 0 | Skip next instruction if zero |
| **SZE** | Skip if E = 0 | Skip next instruction if E is zero |
| **HLT** | Stop | Halt the computer |

---

### Type 3: I/O Instructions (Input/Output)

**What it does:** These instructions handle **communication with external devices** (keyboard, monitor, etc.)

**Format:**
```
   ┌─────┬─────────┬──────────────────┐
   │  1  │  111    │   I/O Operation  │
   └─────┴─────────┴──────────────────┘
    I=1   Opcode      Operation bits
```

**How to identify:**
```
┌─────────────────────────────────┐
│  I = 1  AND  Opcode = 111       │
└─────────────────────────────────┘
```

**All 6 I/O Instructions:**

| Symbol | What it does | Simple Meaning |
|--------|-------------|----------------|
| **INP** | AC ← Input device | Read character from keyboard |
| **OUT** | Output device ← AC | Display character on screen |
| **SKI** | Skip if input ready | Check if keyboard has data |
| **SKO** | Skip if output ready | Check if screen is ready |
| **ION** | Enable interrupts | Turn ON interrupt system |
| **IOF** | Disable interrupts | Turn OFF interrupt system |

---

### How to Identify Instruction Type? (Easy Method)

```
Step 1: Check Opcode (bits 14, 13, 12)
        │
        ├── If Opcode = 000 to 110 → MEMORY REFERENCE
        │
        └── If Opcode = 111 → Go to Step 2
                │
Step 2: Check I bit (bit 15)
        │
        ├── If I = 0 → REGISTER REFERENCE  
        │
        └── If I = 1 → I/O INSTRUCTION
```

### Quick Summary Table

| Type | I bit | Opcode | Count | Purpose |
|------|-------|--------|-------|---------|
| Memory Reference | 0 or 1 | 000-110 | 7 | Access RAM |
| Register Reference | 0 | 111 | 12 | Work on AC, E |
| I/O Instruction | 1 | 111 | 6 | Keyboard, Screen |
| | | | **Total: 25** | |

## 1.4 Instruction Set Summary

```
┌────────────────────────────────────────────────────────────────────────────┐
│                        INSTRUCTION SET SUMMARY                              │
├────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   MEMORY-REFERENCE (I can be 0 or 1)                                        │
│   ┌────────┬────────┬─────────────────────────────────────────────────────┐ │
│   │ Symbol │ Opcode │ Description                                         │ │
│   ├────────┼────────┼─────────────────────────────────────────────────────┤ │
│   │  AND   │  000   │ AC ← AC ∧ M[effective address]                      │ │
│   │  ADD   │  001   │ AC ← AC + M[effective address], E ← Carry           │ │
│   │  LDA   │  010   │ AC ← M[effective address]                           │ │
│   │  STA   │  011   │ M[effective address] ← AC                           │ │
│   │  BUN   │  100   │ PC ← effective address                              │ │
│   │  BSA   │  101   │ M[effective address] ← PC, PC ← effective addr + 1  │ │
│   │  ISZ   │  110   │ M[effective address] ← M[eff addr] + 1, skip if 0   │ │
│   └────────┴────────┴─────────────────────────────────────────────────────┘ │
│                                                                             │
│   REGISTER-REFERENCE (Opcode = 111, I = 0)                                  │
│   ┌────────┬────────┬─────────────────────────────────────────────────────┐ │
│   │  CLA   │  7800  │ Clear AC                                            │ │
│   │  CLE   │  7400  │ Clear E                                             │ │
│   │  CMA   │  7200  │ Complement AC                                       │ │
│   │  CME   │  7100  │ Complement E                                        │ │
│   │  CIR   │  7080  │ Circulate right AC and E                            │ │
│   │  CIL   │  7040  │ Circulate left AC and E                             │ │
│   │  INC   │  7020  │ Increment AC                                        │ │
│   │  SPA   │  7010  │ Skip if positive                                    │ │
│   │  SNA   │  7008  │ Skip if negative                                    │ │
│   │  SZA   │  7004  │ Skip if zero                                        │ │
│   │  SZE   │  7002  │ Skip if E is zero                                   │ │
│   │  HLT   │  7001  │ Halt                                                │ │
│   └────────┴────────┴─────────────────────────────────────────────────────┘ │
│                                                                             │
│   INPUT-OUTPUT (Opcode = 111, I = 1)                                        │
│   ┌────────┬────────┬─────────────────────────────────────────────────────┐ │
│   │  INP   │  F800  │ AC(0-7) ← INPR                                      │ │
│   │  OUT   │  F400  │ OUTR ← AC(0-7)                                      │ │
│   │  SKI   │  F200  │ Skip if FGI = 1                                     │ │
│   │  SKO   │  F100  │ Skip if FGO = 1                                     │ │
│   │  ION   │  F080  │ IEN ← 1 (Enable interrupt)                          │ │
│   │  IOF   │  F040  │ IEN ← 0 (Disable interrupt)                         │ │
│   └────────┴────────┴─────────────────────────────────────────────────────┘ │
│                                                                             │
└────────────────────────────────────────────────────────────────────────────┘
```
## 1.5 Examples of Instructions

### Example 1: ADD Instruction with Direct Addressing

```
Instruction: ADD 500 (I=0)
Binary: 0 001 0001 1111 0100
         │  │        │
         I  Opcode   Address (500)

Execution:
1. AR ← 500        (Address 500 loaded to AR)
2. DR ← M[500]     (Content of M[500] loaded to DR)
3. AC ← AC + DR    (Add DR to AC)
4. E ← Carry       (Store carry in E)
```

### Example 2: LDA Instruction with Indirect Addressing

```
Instruction: LDA 300 (I=1)
Assume: M[300] = 600, M[600] = 1234

Binary: 1 010 0001 0010 1100
         │  │        │
         I  Opcode   Address (300)

Execution:
1. AR ← 300        (Address 300 loaded to AR)
2. DR ← M[300]     (DR gets 600)
3. AR ← DR         (AR now has 600 - effective address)
4. DR ← M[600]     (DR gets 1234)
5. AC ← DR         (AC gets 1234)
```

### Example 3: Register-Reference Instruction

```
Instruction: CLA (Clear Accumulator)
Hex: 7800
Binary: 0 111 1000 0000 0000

Since:
- I = 0
- Opcode = 111
- Bit 11 (D7) = 1

This is a register-reference instruction that clears AC.
```

---
## 1.6 Types of Instructions (Based on Number of Addresses)

Different computers use different instruction formats based on **how many addresses** are specified in each instruction.

### 1. Three-Address Instruction

**Format:** `OPCODE` `Dest` `Source1` `Source2`

```
ADD A, B, C    →    A = B + C

┌─────────┬─────────┬─────────┬─────────┐
│ Opcode  │ Addr A  │ Addr B  │ Addr C  │
└─────────┴─────────┴─────────┴─────────┘
```

**Example:** To calculate `X = (A + B) * (C + D)`
```
ADD T1, A, B     ; T1 = A + B
ADD T2, C, D     ; T2 = C + D
MUL X, T1, T2    ; X = T1 * T2
(Only 3 instructions needed!)
```

| Advantages | Disadvantages |
|------------|---------------|
| Fewer instructions needed | Longer instruction length |
| Less temporary storage | More memory for each instruction |

---

### 2. Two-Address Instruction

**Format:** `OPCODE` `Dest/Source1` `Source2`

```
ADD A, B    →    A = A + B

┌─────────┬─────────┬─────────┐
│ Opcode  │ Addr A  │ Addr B  │
└─────────┴─────────┴─────────┘
```

**One operand is both source AND destination!**

**Example:** To calculate `X = (A + B) * (C + D)`
```
MOV T1, A        ; T1 = A
ADD T1, B        ; T1 = T1 + B = A + B
MOV X, C         ; X = C
ADD X, D         ; X = X + D = C + D
MUL X, T1        ; X = X * T1 = (C+D) * (A+B)
(5 instructions needed)
```

| Advantages | Disadvantages |
|------------|---------------|
| Shorter than 3-address | Original data may be destroyed |
| Used in many real CPUs (x86) | More instructions than 3-address |

---

### 3. One-Address Instruction (Accumulator-Based)

**Format:** `OPCODE` `Address`

```
ADD X    →    ACC = ACC + X

┌─────────┬─────────┐
│ Opcode  │ Address │
└─────────┴─────────┘
```

**Uses Accumulator (ACC) as implicit operand!**

**Example:** To calculate `X = (A + B) * (C + D)`
```
LDA A        ; ACC = A
ADD B        ; ACC = ACC + B = A + B
STA T1       ; T1 = ACC (save A+B)
LDA C        ; ACC = C
ADD D        ; ACC = ACC + D = C + D
MUL T1       ; ACC = ACC * T1 = (C+D) * (A+B)
STA X        ; X = ACC
(7 instructions needed)
```

| Advantages | Disadvantages |
|------------|---------------|
| Shortest instruction | More instructions needed |
| Simple hardware | Heavy use of accumulator |

> **Note:** Our Basic Computer uses this format!

---

### 4. Zero-Address Instruction (Stack-Based)

**Format:** `OPCODE` only (no address!)

```
ADD    →    TOS = TOS + (TOS-1)

┌─────────┐
│ Opcode  │
└─────────┘
```

**All operands come from STACK!**

**Example:** To calculate `X = (A + B) * (C + D)`
```
PUSH A       ; Stack: [A]
PUSH B       ; Stack: [A, B]
ADD          ; Stack: [A+B]  (pops 2, pushes result)
PUSH C       ; Stack: [A+B, C]
PUSH D       ; Stack: [A+B, C, D]
ADD          ; Stack: [A+B, C+D]
MUL          ; Stack: [(A+B)*(C+D)]
POP X        ; X = result
```

| Advantages | Disadvantages |
|------------|---------------|
| Very short instructions | Need PUSH/POP operations |
| Good for expression evaluation | Stack management overhead |

---

### Quick Comparison Table (Exam Important!)

| Type | Example | Operands | Instruction Length | # of Instructions |
|------|---------|----------|-------------------|-------------------|
| **3-Address** | ADD A, B, C | 3 explicit | Longest | Fewest |
| **2-Address** | ADD A, B | 2 explicit | Medium | Medium |
| **1-Address** | ADD X | 1 + ACC | Short | More |
| **0-Address** | ADD | Stack | Shortest | Most (+ PUSH/POP) |

> **Remember:** Basic Computer uses **1-Address (Accumulator-based)** format!

---

