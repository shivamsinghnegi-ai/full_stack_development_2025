# Part 1: Instruction Codes

---

**Q1.** What is an Instruction Code?
> **Answer:** An instruction code is a group of bits that instructs the computer to perform a specific operation. It is divided into parts:
> 
> - **Opcode (Operation Code):** Specifies the operation (ADD, SUB, LOAD, etc.)
> - **Address Field:** Specifies memory location of operand
> 
> **Example (16-bit):** 4 bits for opcode (16 operations) + 12 bits for address (4096 locations)

---

**Q2.** What is the structure of a 16-bit Instruction Code?
> **Answer:**
> ```
> | Opcode (4 bits) | Address (12 bits) |
> ```
> - **Opcode:** Specifies operation (2⁴ = 16 possible operations)
> - **Address:** Specifies memory location (2¹² = 4096 addresses, 0-4095)
> 
> **Formula:** Number of bits in opcode = log₂(number of operations)

---

**Q3.** What is the Stored Program Concept?
> **Answer:** The computer stores both **instructions and data** in the same memory unit. This is the foundation of **Von Neumann Architecture**.
> 
> **Key points:**
> - Instructions and data share same memory
> - Memory is a linear array of words
> - CPU fetches instructions from memory sequentially
> - Same memory can hold code or data depending on context

---

# Part 2: Computer Registers

---

**Q4.** What are Registers?
> **Answer:** Registers are small, super-fast storage locations inside the CPU used for temporary data storage during processing.
> 
> **Why needed:**
> - RAM is slow compared to CPU speed
> - Registers are inside CPU → very fast access
> - Hold data CPU is currently working on
> 
> **Analogy:** Registers are like rough paper in front of you (fast), RAM is like a textbook on a shelf (slow).

---

**Q5.** List all 8 registers of the Basic Computer with their sizes.
> **Answer:**
> 
> | Register | Full Name | Size | Purpose |
> |----------|-----------|------|---------|
> | **AC** | Accumulator | 16 bits | Stores calculation results |
> | **DR** | Data Register | 16 bits | Holds data from memory |
> | **AR** | Address Register | 12 bits | Holds memory address |
> | **IR** | Instruction Register | 16 bits | Holds current instruction |
> | **PC** | Program Counter | 12 bits | Address of next instruction |
> | **TR** | Temporary Register | 16 bits | Temporary storage |
> | **INPR** | Input Register | 8 bits | Keyboard input |
> | **OUTR** | Output Register | 8 bits | Screen output |

---

**Q6.** Why are register sizes different?
> **Answer:**
> - **AC, DR, IR, TR = 16 bits:** Because memory word size = 16 bits
> - **AR, PC = 12 bits:** Because 2¹² = 4096 memory addresses
> - **INPR, OUTR = 8 bits:** Because ASCII character = 8 bits

---

**Q7.** What is the Accumulator (AC)?
> **Answer:** The main register where ALL arithmetic and logic calculations happen.
> 
> **Key points:**
> - All ALU results go to AC
> - Only register directly connected to ALU
> - Most instructions use AC as implicit operand
> 
> **Example:** ADD 500 → AC = AC + Memory[500]

---

**Q8.** What is the Program Counter (PC)?
> **Answer:** Keeps track of which instruction to fetch next.
> 
> **How it works:**
> - Initially contains address of first instruction
> - Automatically increments: PC ← PC + 1 after each fetch
> - Jump instructions can change PC to any address
> 
> **Size:** 12 bits (can address 0-4095)

---

**Q9.** What is the Instruction Register (IR)?
> **Answer:** Holds the instruction currently being executed.
> 
> **After fetch:** IR contains | I bit | Opcode | Address |
> - Bit 15: Indirect bit (I)
> - Bits 14-12: Opcode
> - Bits 11-0: Address
> 
> **Purpose:** IR is decoded to determine what operation to perform.

---

**Q10.** What is the Data Register (DR)?
> **Answer:** Acts as a buffer/middleman between memory and CPU.
> 
> **When CPU needs data from memory:**
> 1. Put address in AR
> 2. Memory sends data → DR holds it
> 3. CPU uses data from DR
> 
> **Size:** 16 bits (same as memory word)

---

# Part 3: Addressing Modes

---

**Q11.** What are the three Addressing Modes in Basic Computer?
> **Answer:**
> 1. **Immediate Addressing:** Operand is in the instruction itself
> 2. **Direct Addressing (I=0):** Address field contains actual memory address
> 3. **Indirect Addressing (I=1):** Address field contains pointer to actual address

---

**Q12.** Explain Immediate Addressing.
> **Answer:** The operand value is part of the instruction itself (address field contains data, not address).
> 
> **Characteristics:**
> - Fastest (no memory access needed)
> - Limited by address field size (12 bits max)
> - Used for constants
> 
> **Example:** ADD #25 → AC = AC + 25 (directly, no memory access)

---

**Q13.** Explain Direct Addressing (I=0).
> **Answer:** The address field contains the actual memory address of the operand.
> 
> **How it works:**
> 1. AR ← Address from instruction
> 2. DR ← Memory[AR]
> 3. Use DR as operand
> 
> **Memory accesses:** 1
> **Example:** ADD 400 with M[400]=75 → AC = AC + 75

---

**Q14.** Explain Indirect Addressing (I=1).
> **Answer:** Address field contains address of a memory location that holds the actual address of the operand.
> 
> **How it works:**
> 1. AR ← Address from instruction
> 2. DR ← Memory[AR] (this is a pointer)
> 3. AR ← DR
> 4. DR ← Memory[AR] (actual operand)
> 
> **Memory accesses:** 2
> **Use case:** Arrays, pointers, dynamic data structures

---

**Q15.** Compare the three Addressing Modes.
> **Answer:**
> 
> | Feature | Immediate | Direct (I=0) | Indirect (I=1) |
> |---------|-----------|--------------|----------------|
> | Memory accesses | 0 | 1 | 2 |
> | Speed | Fastest | Fast | Slowest |
> | Flexibility | Least | Medium | Most |
> | Operand location | In instruction | At address | At address of address |

---

# Part 4: Types of Instructions

---

**Q16.** What are the three types of Instructions in Basic Computer?
> **Answer:**
> 1. **Memory Reference Instructions (MRI):** Access memory (opcode 000-110)
> 2. **Register Reference Instructions:** Work only on registers (opcode 111, I=0)
> 3. **I/O Instructions:** Handle input/output devices (opcode 111, I=1)
> 
> **Total:** 7 + 12 + 6 = **25 instructions**

---

**Q17.** How to identify instruction type from binary?
> **Answer:**
> 1. Check opcode (bits 14-12)
>    - If 000-110 → **Memory Reference**
>    - If 111 → Go to step 2
> 2. Check I bit (bit 15)
>    - If I=0 → **Register Reference**
>    - If I=1 → **I/O Instruction**

---

**Q18.** List all 7 Memory Reference Instructions.
> **Answer:**
> 
> | Symbol | Opcode | Operation | Purpose |
> |--------|--------|-----------|---------|
> | AND | 000 | AC ← AC ∧ M[EA] | Bitwise AND |
> | ADD | 001 | AC ← AC + M[EA] | Addition |
> | LDA | 010 | AC ← M[EA] | Load to AC |
> | STA | 011 | M[EA] ← AC | Store from AC |
> | BUN | 100 | PC ← EA | Unconditional jump |
> | BSA | 101 | M[EA] ← PC, PC ← EA+1 | Subroutine call |
> | ISZ | 110 | M[EA]++, skip if 0 | Loop counter |

---

**Q19.** What are Register Reference Instructions?
> **Answer:** Instructions that work only on AC and E registers, no memory access.
> 
> **Identification:** Opcode = 111, I = 0
> 
> **Examples:**
> - CLA (Clear AC)
> - CMA (Complement AC)
> - INC (Increment AC)
> - CIR/CIL (Circular shift right/left)
> - SPA/SNA/SZA (Skip if positive/negative/zero)
> - HLT (Halt)

---

**Q20.** What are I/O Instructions?
> **Answer:** Instructions that handle communication with input/output devices.
> 
> **Identification:** Opcode = 111, I = 1
> 
> **All 6 I/O Instructions:**
> - INP: Read from keyboard to AC
> - OUT: Write from AC to display
> - SKI: Skip if input flag set
> - SKO: Skip if output flag set
> - ION: Enable interrupts
> - IOF: Disable interrupts

---

# Part 5: Instruction Formats by Address Count

---

**Q21.** What are the four instruction formats based on number of addresses?
> **Answer:**
> 1. **Three-Address:** ADD A, B, C → A = B + C
> 2. **Two-Address:** ADD A, B → A = A + B
> 3. **One-Address:** ADD X → AC = AC + X (Accumulator-based)
> 4. **Zero-Address:** ADD → Stack-based operation
> 
> **Basic Computer uses:** One-Address (Accumulator-based)

---

**Q22.** Compare the four instruction formats.
> **Answer:**
> 
> | Type | Instruction Length | Instructions Needed | Example |
> |------|-------------------|---------------------|---------|
> | 3-Address | Longest | Fewest | ADD A, B, C |
> | 2-Address | Medium | Medium | ADD A, B |
> | 1-Address | Short | More | ADD X (uses AC) |
> | 0-Address | Shortest | Most | ADD (uses stack) |
> 
> **Trade-off:** Shorter instructions = more instructions needed

---

**Q23.** Why does Basic Computer use One-Address format?
> **Answer:** 
> - Has only ONE general-purpose register (AC)
> - One operand is always AC (implicit)
> - One operand comes from memory (explicit in instruction)
> - Simpler hardware design
> - 12-bit address allows accessing 4096 memory locations

---

# Part 6: Common Bus System

---

**Q24.** What is the Common Bus System?
> **Answer:** A set of shared wires connecting all registers and memory, allowing data transfer between any components.
> 
> **Purpose:** Instead of connecting every register to every other register (too many wires), all components share ONE common data path.
> 
> **Key rules:**
> - Only ONE register can put data on bus at a time
> - Multiple registers can read from bus simultaneously

---

**Q25.** What is the Bus Selection Table?
> **Answer:** 3 selection lines (S₂S₁S₀) choose which register outputs to bus:
> 
> | S₂S₁S₀ | Register |
> |--------|----------|
> | 001 | AR |
> | 010 | PC |
> | 011 | DR |
> | 100 | AC |
> | 101 | IR |
> | 110 | TR |
> | 111 | Memory |
> 
> **Memory trick:** 1=AR, 2=PC, 3=DR, 4=AC, 5=IR, 6=TR, 7=Mem

---

**Q26.** What are the three register control signals?
> **Answer:**
> - **LD (Load):** Transfer data INTO register (e.g., AC ← Bus)
> - **INR (Increment):** Add 1 to register (e.g., PC ← PC + 1)
> - **CLR (Clear):** Reset register to zero (e.g., AC ← 0)

---

# Part 7: Instruction Cycle

---

**Q27.** What is the Instruction Cycle?
> **Answer:** The sequence of steps CPU follows to execute each instruction:
> 
> 1. **Fetch:** Get instruction from memory
> 2. **Decode:** Understand what instruction means
> 3. **Execute:** Perform the operation
> 4. **Repeat** for next instruction
> 
> This cycle repeats continuously until HLT instruction.

---

**Q28.** What are the Fetch Cycle micro-operations?
> **Answer:** Same for ALL instructions (T₀, T₁, T₂):
> 
> - **T₀:** AR ← PC (transfer instruction address)
> - **T₁:** IR ← M[AR], PC ← PC + 1 (read instruction, increment PC)
> - **T₂:** Decode opcode, AR ← IR(0-11), I ← IR(15)
> 
> **Key point:** Fetch always takes 3 timing cycles.

---

**Q29.** What happens after decoding (T₂)?
> **Answer:** CPU determines instruction type and executes:
> 
> - **If opcode ≠ 111:** Memory Reference Instruction
>   - I=0: Execute at T₃ or T₄
>   - I=1: Get effective address at T₃, execute at T₄
> 
> - **If opcode = 111 and I=0:** Register Reference (execute at T₃)
> 
> - **If opcode = 111 and I=1:** I/O Instruction (execute at T₃)

---

**Q30.** What is the Sequence Counter (SC)?
> **Answer:** A counter that generates timing signals T₀, T₁, T₂, T₃...
> 
> **How it works:**
> - Initially SC = 0 → generates T₀
> - Each clock pulse increments SC
> - SC = 0 generates T₀, SC = 1 generates T₁, etc.
> - After instruction completes, SC ← 0 (reset for next instruction)

---

# Part 8: Timing and Control

---

**Q31.** What is the Control Unit?
> **Answer:** The "brain" of CPU that generates control signals for all operations.
> 
> **Inputs:**
> - IR (current instruction)
> - Timing signals (T₀, T₁, ...)
> - Flags (E, I, etc.)
> 
> **Outputs:**
> - Register control signals (load, increment, clear)
> - Memory control signals (read, write)
> - ALU control signals

---

**Q32.** What are the two types of Control Unit design?
> **Answer:**
> 
> **1. Hardwired Control:**
> - Uses combinational logic (AND, OR gates)
> - Fixed in hardware, cannot change
> - Very fast
> - Used in RISC processors
> 
> **2. Microprogrammed Control:**
> - Control signals stored in ROM (Control Memory)
> - Easy to modify
> - Slower (needs memory access)
> - Used in CISC processors

---

**Q33.** Compare Hardwired vs Microprogrammed Control.
> **Answer:**
> 
> | Feature | Hardwired | Microprogrammed |
> |---------|-----------|-----------------|
> | Speed | Faster | Slower |
> | Flexibility | Fixed | Easy to modify |
> | Complexity | Complex for large ISA | Simpler design |
> | Debugging | Difficult | Easy |
> | Used in | RISC | CISC |
> 
> **Remember:** Hardwired = High-speed, Microprogrammed = Modifiable

---

# Part 9: Memory Reference Instructions (Detailed)

---

**Q34.** Explain AND instruction micro-operations.
> **Answer:** AND performs bitwise AND between AC and memory.
> 
> **Opcode:** 000
> **Operation:** AC ← AC ∧ M[EA]
> 
> **Micro-operations:**
> - T₄: DR ← M[AR]
> - T₅: AC ← AC ∧ DR, SC ← 0

---

**Q35.** Explain ADD instruction micro-operations.
> **Answer:** ADD adds memory value to AC.
> 
> **Opcode:** 001
> **Operation:** AC ← AC + M[EA], E ← Carry
> 
> **Micro-operations:**
> - T₄: DR ← M[AR]
> - T₅: AC ← AC + DR, E ← Cout, SC ← 0

---

**Q36.** Explain LDA (Load AC) instruction.
> **Answer:** LDA loads value from memory into AC.
> 
> **Opcode:** 010
> **Operation:** AC ← M[EA]
> 
> **Micro-operations:**
> - T₄: DR ← M[AR]
> - T₅: AC ← DR, SC ← 0

---

**Q37.** Explain STA (Store AC) instruction.
> **Answer:** STA stores AC value into memory.
> 
> **Opcode:** 011
> **Operation:** M[EA] ← AC
> 
> **Micro-operations:**
> - T₄: M[AR] ← AC, SC ← 0
> 
> **Note:** Only 1 execute cycle (no read needed) - fastest MRI!

---

**Q38.** Explain BUN (Branch Unconditional) instruction.
> **Answer:** BUN jumps to specified address.
> 
> **Opcode:** 100
> **Operation:** PC ← EA
> 
> **Micro-operations:**
> - T₄: PC ← AR, SC ← 0
> 
> **Use:** Implementing GOTO, loops

---

**Q39.** Explain BSA (Branch and Save Address) instruction.
> **Answer:** BSA is used for subroutine calls - saves return address, then jumps.
> 
> **Opcode:** 101
> **Operation:** M[EA] ← PC, PC ← EA + 1
> 
> **Micro-operations:**
> - T₄: M[AR] ← PC, AR ← AR + 1
> - T₅: PC ← AR, SC ← 0
> 
> **How it works:**
> 1. Saves return address at specified location
> 2. Jumps to next location (subroutine start)
> 3. Subroutine ends with indirect BUN to return

---

**Q40.** Explain ISZ (Increment and Skip if Zero) instruction.
> **Answer:** ISZ increments memory and skips next instruction if result is zero.
> 
> **Opcode:** 110
> **Operation:** M[EA] ← M[EA] + 1, if result = 0 then PC ← PC + 1
> 
> **Micro-operations:**
> - T₄: DR ← M[AR]
> - T₅: DR ← DR + 1
> - T₆: M[AR] ← DR, if (DR=0) PC ← PC+1, SC ← 0
> 
> **Note:** Slowest MRI (3 execute cycles)
> **Use:** Loop counters (count from negative to zero)

---

