# Part 1: Structure of Computers

---

**Q1.** What is a Computer?
> **Answer:** A computer is an electronic device that:
> - Takes **INPUT** (like keyboard typing)
> - **PROCESSES** it (does calculations, runs programs)
> - Gives **OUTPUT** (shows results on screen)
> - Can **STORE** information (saves files)
> 
> Simple: A computer is a smart machine that follows instructions to solve problems.

---

**Q2.** What are the five types of computers?
> **Answer:**
> 1. **Microcomputers** - Personal use (laptop, desktop, smartphone)
> 2. **Minicomputers** - Small businesses, 10-100 users
> 3. **Mainframe Computers** - Very large, thousands of users (banks, airlines)
> 4. **Supercomputers** - Fastest computers (weather prediction, AI)
> 5. **Embedded Systems** - Tiny computers inside devices (microwave, car engine)

---

**Q3.** What is a Microcomputer? Give examples.
> **Answer:** A microcomputer is a small personal computer designed for individual use.
> - **Size:** Fits on a desk or in hand
> - **Users:** 1 person at a time
> - **Examples:** Laptop, Desktop, MacBook, iPad, Smartphone

---

**Q4.** What is a Minicomputer?
> **Answer:** A medium-sized computer for small businesses.
> - **Size:** Size of a small refrigerator
> - **Users:** 10-100 people can use together
> - **Example:** Company servers in small offices

---

**Q5.** What is a Mainframe Computer?
> **Answer:** Very large, powerful computers, room-sized.
> - **Users:** Thousands can use simultaneously
> - **Example:** Bank servers, airline booking systems
> - **Analogy:** Like a train - many people use it at once

---

**Q6.** What is a Supercomputer?
> **Answer:** The FASTEST computers in the world.
> - **Size:** Warehouse-sized
> - **Speed:** Trillions of calculations per second
> - **Examples:** Weather prediction, space research, AI training

---

**Q7.** What is an Embedded System?
> **Answer:** Tiny computers hidden inside other devices that do ONE specific job.
> - **Examples:** Microwave timer, car engine control, washing machine controller

---

**Q8.** What are the five Functional Units of a computer?
> **Answer:**
> 1. **Input Unit** - Takes information from user
> 2. **Output Unit** - Shows results to user
> 3. **Central Processing Unit (CPU)** - Brain of computer
> 4. **Memory Unit** - Stores information
> 5. **Registers** - Super fast temporary storage in CPU

---

**Q9.** What is the Input Unit? Give examples.
> **Answer:** The Input Unit takes information FROM the user.
> - **Analogy:** Like your EYES and EARS (receive information)
> - **Examples:** Keyboard, Mouse, Microphone, Camera, Scanner
> - **Rule:** Anything that SENDS data TO the computer = Input device

---

**Q10.** What is the Output Unit? Give examples.
> **Answer:** The Output Unit shows results TO the user.
> - **Analogy:** Like your MOUTH (gives information)
> - **Examples:** Monitor/Screen, Printer, Speakers, Headphones
> - **Rule:** Anything that computer SENDS data to YOU = Output device

---

**Q11.** What is the CPU? What are its two main parts?
> **Answer:** CPU (Central Processing Unit) is the BRAIN of the computer.
> 
> **Two Parts:**
> 1. **ALU (Arithmetic Logic Unit):** Does ALL math operations (add, subtract, multiply, divide, comparisons)
> 2. **Control Unit (CU):** The BOSS - controls everything, manages data flow, coordinates activities

---

**Q12.** What is the ALU and what operations does it perform?
> **Answer:** ALU (Arithmetic Logic Unit) does ALL math operations:
> - Addition: 5 + 3 = 8
> - Subtraction: 10 - 2 = 8
> - Multiplication: 4 × 2 = 8
> - Division: 16 ÷ 2 = 8
> - Comparisons: Is 5 > 3? (YES)
> - **Analogy:** Like a calculator inside the brain

---

**Q13.** What is the Control Unit?
> **Answer:** The Control Unit is the BOSS - controls everything.
> - Tells other units what to do
> - Manages data flow
> - Controls timing
> - Coordinates all activities
> - **Analogy:** Like a traffic police officer directing traffic

---

**Q14.** What are the two types of Memory?
> **Answer:**
> 1. **Primary Memory (RAM):**
>    - VERY FAST
>    - Small (8GB, 16GB)
>    - Temporary (deleted when power OFF)
>    - Like short-term memory
> 
> 2. **Secondary Memory (Storage):**
>    - Slower
>    - HUGE (500GB, 1TB)
>    - Permanent (stays when power OFF)
>    - Examples: Hard Disk, SSD, USB drive
>    - Like long-term memory

---

**Q15.** What are Registers?
> **Answer:** Registers are SUPER FAST temporary storage inside CPU.
> - **Size:** VERY SMALL (few bytes)
> - **Speed:** FASTEST memory in computer
> - **Purpose:** Hold data that CPU is currently using
> - **Analogy:** Your hand holding a pen while writing (immediate access)

---

**Q16.** What is the Fetch-Decode-Execute (FDE) Cycle?
> **Answer:** The computer follows this 3-step cycle for EVERY instruction:
> 
> 1. **FETCH:** Get the next instruction from memory (like taking a recipe card)
> 2. **DECODE:** Understand what the instruction means (reading the recipe)
> 3. **EXECUTE:** Actually DO the instruction (cooking according to recipe)
> 
> Then the cycle REPEATS for the next instruction forever!

---

**Q17.** What is an Interrupt?
> **Answer:** An Interrupt is an EMERGENCY signal that stops current work.
> - **Why needed:** Something urgent needs attention RIGHT NOW
> - **Like:** Fire alarm during class - you stop studying and evacuate
> - **Examples:** Pressing CTRL+C, Printer out of paper, Error message
> 
> **Working:**
> 1. Computer doing normal work
> 2. INTERRUPT happens
> 3. Computer PAUSES current work
> 4. Handles the interrupt (urgent task)
> 5. RESUMES normal work

---

**Q18.** What is Software? What are the two types?
> **Answer:** Software = Programs and instructions that tell hardware what to do.
> 
> **Two Types:**
> 1. **System Software:** Manages computer itself (OS, Drivers, Antivirus)
> 2. **Application Software:** Helps YOU do tasks (Word, Chrome, Games)

---

**Q19.** What is an Operating System?
> **Answer:** The Operating System is the KING of software - controls everything.
> - Manages memory
> - Runs programs
> - Handles files
> - Controls hardware
> - **Examples:** Windows 11, macOS, Linux, Android

---

**Q20.** What is the difference between Compiler and Interpreter?
> **Answer:**
> | Feature | Compiler | Interpreter |
> |---------|----------|-------------|
> | **Translation** | Entire program at once | Line by line |
> | **Speed** | Faster execution | Slower execution |
> | **Error Detection** | After full compilation | At each line |
> | **Analogy** | Translating whole book | Live translator |

---

**Q21.** What is an Assembler?
> **Answer:** Assembler converts assembly language to machine code.
> - **Input:** Assembly code (ADD, SUB, MOV)
> - **Output:** Binary code (010101)
> - **Like:** Converting shorthand notes to full sentences

---

**Q22.** What is Clock Speed and how is it measured?
> **Answer:** Clock Speed measures how many operations per second.
> - **Unit:** Hertz (Hz)
> - 1 GHz = 1 billion cycles per second
> - **Example:** 3.5 GHz processor
> - **Higher clock speed = Faster computer** (usually)

---

**Q23.** What is the Performance Formula for Execution Time?
> **Answer:** 
> ```
> Execution Time = Number of Instructions × CPI × Clock Cycle Time
> ```
> 
> **To make computer faster:**
> 1. Reduce number of instructions (better programming)
> 2. Reduce CPI (better CPU design)
> 3. Increase clock speed (better hardware)

---

**Q24.** What is a Multiprocessor System?
> **Answer:** Multiple CPUs in ONE computer with SHARED memory.
> - **Communication:** Fast (through shared memory)
> - **Example:** Laptop with 8 cores
> - **Advantage:** Fast, cheap
> - **Analogy:** Team working on one whiteboard together

---

**Q25.** What is a Multicomputer System?
> **Answer:** Multiple SEPARATE computers connected with DISTRIBUTED memory.
> - **Communication:** Slower (through network)
> - **Example:** Google's data centers
> - **Advantage:** Can add more computers easily
> - **Analogy:** Team members working from different offices

---

**Q26.** Compare Multiprocessor vs Multicomputer.
> **Answer:**
> | Feature | Multiprocessor | Multicomputer |
> |---------|----------------|---------------|
> | **Memory** | Shared | Distributed |
> | **Communication** | Fast (shared memory) | Slow (network) |
> | **Scalability** | Limited | Easy to add more |
> | **Example** | Multi-core laptop | Data centers |

---

# Part 2: Data Representation

---

**Q27.** Why do computers use Binary (0s and 1s)?
> **Answer:** At the deepest level, computers only understand ON and OFF (electricity).
> - **ON = 1**
> - **OFF = 0**
> 
> This is why we use Binary to represent everything—numbers, text, images, videos.

---

**Q28.** What are the four common Number Systems?
> **Answer:**
> | System | Base | Digits | Why Used |
> |--------|------|--------|----------|
> | **Decimal** | 10 | 0-9 | Human standard |
> | **Binary** | 2 | 0, 1 | Machine language |
> | **Octal** | 8 | 0-7 | Shorthand (groups of 3 bits) |
> | **Hexadecimal** | 16 | 0-9, A-F | Shorthand (groups of 4 bits) |

---

**Q29.** Convert Binary 1011 to Decimal.
> **Answer:** Using "Power of 2" method:
> ```
> 1   0   1   1
> 1×2³ + 0×2² + 1×2¹ + 1×2⁰
> = 8 + 0 + 2 + 1
> = 11
> ```
> **Answer:** 1011₂ = **11₁₀**

---

**Q30.** Convert Decimal 13 to Binary.
> **Answer:** Using "Divide by 2" method:
> ```
> 13 ÷ 2 = 6   Remainder: 1 (LSB)
>  6 ÷ 2 = 3   Remainder: 0
>  3 ÷ 2 = 1   Remainder: 1
>  1 ÷ 2 = 0   Remainder: 1 (MSB)
> ```
> **Read Bottom-Up:** 1101
> **Answer:** 13₁₀ = **1101₂**

---

**Q31.** How to convert Binary to Octal?
> **Answer:** Group bits in 3s from right.
> 
> **Table:** 000=0, 001=1, 010=2, 011=3, 100=4, 101=5, 110=6, 111=7
> 
> **Example:** 110101 → 110|101 → 6|5 = **65₈**

---

**Q32.** How to convert Binary to Hexadecimal?
> **Answer:** Group bits in 4s from right.
> 
> **Example:** 11011010 → 1101|1010 → D|A = **DA₁₆**
> (Since 1101=13=D, 1010=10=A)

---

**Q33.** What are the three methods for representing Signed Integers?
> **Answer:**
> 1. **Sign-Magnitude:** First bit for sign (0=+, 1=-), rest for magnitude
> 2. **1's Complement:** Flip all bits for negative
> 3. **2's Complement:** 1's Complement + 1 (The Standard!)

---

**Q34.** What is 2's Complement? Why is it preferred?
> **Answer:** 2's Complement = 1's Complement + 1
> 
> **Why preferred:**
> 1. Only ONE representation for zero
> 2. Makes arithmetic circuits simpler
> 3. Subtraction becomes Addition

---

**Q35.** Find the 2's Complement of -12 in 8-bit.
> **Answer:**
> 1. **Step 1:** Write +12 in binary: 0000 1100
> 2. **Step 2:** 1's Complement (flip): 1111 0011
> 3. **Step 3:** Add 1: 1111 0011 + 1 = **1111 0100**

---

**Q36.** What is the shortcut for finding 2's Complement?
> **Answer:** Start from right (LSB):
> 1. Copy all bits up to and including the first '1'
> 2. Flip all remaining bits to the left
> 
> **Example for -12 (0000 1100):**
> - Right to left: copy `100`
> - Flip rest: `0000 1` → `1111 0`
> - **Result:** 1111 0100

---

**Q37.** What is the range of integers for n bits?
> **Answer:**
> - **Unsigned:** 0 to 2ⁿ - 1
> - **Signed (2's Complement):** -2⁽ⁿ⁻¹⁾ to +2⁽ⁿ⁻¹⁾ - 1
> 
> **For 8-bit:**
> - Unsigned: 0 to 255
> - Signed: -128 to +127

---

**Q38.** What is Floating Point Representation?
> **Answer:** A way to represent decimal numbers using Scientific Notation in binary:
> **±1.mantissa × 2^exponent**
> 
> Called "Floating Point" because the decimal point floats based on exponent.

---

**Q39.** What are the three parts of IEEE 754 Single Precision (32-bit)?
> **Answer:**
> | Sign | Exponent | Mantissa |
> |------|----------|----------|
> | 1 bit | 8 bits | 23 bits |
> 
> - **Sign:** 0 = +, 1 = -
> - **Exponent:** Actual + 127 (Bias)
> - **Mantissa:** Digits after decimal (Hidden "1" rule)

---

**Q40.** Convert 12.5 to IEEE 754 format (show steps).
> **Answer:**
> 1. **Convert to Binary:** 12 = 1100, 0.5 = 0.1 → 1100.1
> 2. **Normalize:** 1100.1 → 1.1001 × 2³
> 3. **Exponent:** 3 + 127 = 130 = 10000010
> 4. **Mantissa:** 1001 (drop leading 1.) → 10010000...
> 5. **Sign:** 0 (positive)
> 
> **Final:** 0 | 10000010 | 10010000000000000000000

---

# Part 3: Computer Arithmetic

---

**Q41.** What are the rules for Binary Addition?
> **Answer:**
> - 0 + 0 = 0
> - 0 + 1 = 1
> - 1 + 0 = 1
> - 1 + 1 = 10 (Sum 0, Carry 1)
> - 1 + 1 + 1 = 11 (Sum 1, Carry 1)

---

**Q42.** How is subtraction performed using 2's Complement?
> **Answer:** A - B = A + (-B)
> 
> Where (-B) is 2's complement of B.
> 
> **Example: 7 - 5 in 4-bit:**
> - 7 = 0111
> - -5 = 2's comp of 0101 = 1011
> - 0111 + 1011 = 10010
> - Discard carry → 0010 = **2**

---

**Q43.** What is Booth's Multiplication Algorithm? Why is it used?
> **Answer:** Booth's Algorithm is used for signed multiplication (2's complement).
> 
> **Key Insight:** Strings of 1s can be treated efficiently.
> Example: 00111100 = (2⁶ - 2²) instead of four additions.
> 
> Handles positive and negative numbers uniformly without correction.

---

**Q44.** What is the decision table for Booth's Algorithm?
> **Answer:**
> | Q₀ | Q₋₁ | Operation |
> |:---:|:---:|:---|
> | 0 | 0 | No operation, only ASR |
> | 0 | 1 | AC = AC + M, then ASR |
> | 1 | 0 | AC = AC - M, then ASR |
> | 1 | 1 | No operation, only ASR |
> 
> ASR = Arithmetic Shift Right

---

**Q45.** Multiply 7 × 3 using Booth's Algorithm.
> **Answer:**
> - M = 0111 (7), Q = 0011 (3), -M = 1001
> 
> | Step | AC | Q | Q₋₁ | Operation |
> |:---:|:---:|:---:|:---:|:---|
> | Initial | 0000 | 0011 | 0 | Start |
> | 1st | 1001→1100 | 1001 | 1 | Q₀Q₋₁=10: AC-M, ASR |
> | 2nd | 1110 | 0100 | 1 | Q₀Q₋₁=11: ASR only |
> | 3rd | 0101→0010 | 1010 | 0 | Q₀Q₋₁=01: AC+M, ASR |
> | 4th | 0001 | 0101 | 0 | Q₀Q₋₁=00: ASR only |
> 
> **Result:** 00010101 = **21** ✓

---

**Q46.** What is Restoring Division Algorithm?
> **Answer:** "Restoring" means if we subtract the divisor and result is negative, we add the divisor back to restore.
> 
> **Procedure:**
> 1. Initialize A=0, Q=Dividend, M=Divisor
> 2. Shift Left AQ
> 3. Subtract: A ← A - M
> 4. If A negative: Q₀=0, Restore (A=A+M)
> 5. If A positive: Q₀=1, No restore
> 6. Repeat n times
> 7. Q = Quotient, A = Remainder

---

**Q47.** What is Non-Restoring Division? How is it different?
> **Answer:** Instead of restoring immediately after negative result, it keeps the negative remainder and adds M in the next step.
> 
> **Key Difference:**
> - **Restoring:** If A < 0, restore immediately, then shift
> - **Non-Restoring:** If A < 0, don't restore! Just shift, then add M next step
> 
> **Non-Restoring is faster** (avoids extra restore step).

---

**Q48.** Divide 11 ÷ 3 using Restoring Division.
> **Answer:**
> - Dividend Q = 1011 (11), Divisor M = 00011 (3)
> 
> | n | A | Q | Operation |
> |:---:|:---:|:---:|:---|
> | 4 | 00000 | 1011 | Initialize |
> | | 00001→11110 | 0110 | Shift, A-M, A<0→Q₀=0, Restore |
> | 3 | 00010→11111 | 1100 | Shift, A-M, A<0→Q₀=0, Restore |
> | 2 | 00101→00010 | 1001 | Shift, A-M, A≥0→Q₀=1 |
> | 1 | 00101→00010 | 0011 | Shift, A-M, A≥0→Q₀=1 |
> 
> **Quotient:** 0011 = **3**, **Remainder:** 00010 = **2** ✓

---

**Q49.** Compare Restoring vs Non-Restoring Division.
> **Answer:**
> | Feature | Restoring | Non-Restoring |
> |:---|:---|:---|
> | **Restore Step** | Always if A<0 | Never during iteration |
> | **Operations/cycle** | Up to 2 | Exactly 1 |
> | **Speed** | Slower | Faster |
> | **Final Correction** | Not needed | May need if A<0 |

---

**Q50.** What is the normalized form in Floating-Point?
> **Answer:** Mantissa is always in range 0.1 ≤ |f| < 1.0
> 
> **Examples:**
> - 0.00596 → 0.596 × 10⁻²
> - 65.7452 → 0.657452 × 10²
> - -486.8 → -0.4868 × 10³

---

**Q51.** What are the steps for Floating-Point Addition?
> **Answer:**
> 1. **Set E_z** = larger exponent
> 2. **Shift Right** smaller number's mantissa by exponent difference
> 3. **Add** mantissas: f_z = f_x + f_y
> 4. **Normalize** if |f_z| > 1

---

**Q52.** Add 0.964572 E2 and 0.586351 E5.
> **Answer:**
> 1. E_z = 5 (larger)
> 2. Align: 0.964572 E2 → 0.000964 E5
> 3. Add: 0.000964 + 0.586351 = 0.587315
> 4. Already normalized
> 
> **Result:** 0.587315 E5

---

**Q53.** What are the steps for Floating-Point Multiplication?
> **Answer:**
> 1. **Multiply** mantissas: f_z = f_x × f_y
> 2. **Add** exponents: E_z = E_x + E_y
> 3. **Combine:** z = f_z × 10^E_z
> 4. **Normalize** if necessary

---

**Q54.** Multiply 0.200000 E4 and 0.400000 E-2.
> **Answer:**
> 1. Multiply: 0.2 × 0.4 = 0.08
> 2. Add exponents: 4 + (-2) = 2
> 3. Combine: 0.08 × 10²
> 4. Normalize: 0.08 → 0.8, E = 2-1 = 1
> 
> **Result:** 0.800000 E1

---

**Q55.** What are the steps for Floating-Point Division?
> **Answer:**
> 1. **Divide** mantissas: f_z = f_x / f_y
> 2. **Subtract** exponents: E_z = E_x - E_y
> 3. **Combine:** z = f_z × 10^E_z
> 4. **Normalize** if necessary

---

**Q56.** Summarize Floating-Point Arithmetic Rules.
> **Answer:**
> | Operation | Mantissa | Exponent |
> |:---:|:---:|:---:|
> | **Addition** | Align, then Add | Use larger |
> | **Subtraction** | Align, then Subtract | Use larger |
> | **Multiplication** | Multiply | Add |
> | **Division** | Divide | Subtract |
> 
> **Always Normalize the final result!**

---

# Part 4: Decimal Arithmetic (BCD)

---

**Q57.** What is BCD (Binary Coded Decimal)?
> **Answer:** Instead of converting whole number to binary, convert each decimal digit to 4-bit binary separately.
> 
> **Example:** 472 → 0100 0111 0010
> 
> **Rule:** Each digit (0-9) uses exactly 4 bits.

---

**Q58.** Write the BCD codes for digits 0-9.
> **Answer:**
> | Decimal | BCD | Decimal | BCD |
> |:---:|:---:|:---:|:---:|
> | 0 | 0000 | 5 | 0101 |
> | 1 | 0001 | 6 | 0110 |
> | 2 | 0010 | 7 | 0111 |
> | 3 | 0011 | 8 | 1000 |
> | 4 | 0100 | 9 | 1001 |
> 
> **Invalid:** 1010-1111 (10-15 don't exist in decimal!)

---

**Q59.** Convert 59 to BCD.
> **Answer:** 
> - 5 = 0101
> - 9 = 1001
> - **BCD:** 0101 1001

---

**Q60.** Convert BCD 0011 0111 to Decimal.
> **Answer:**
> - 0011 = 3
> - 0111 = 7
> - **Decimal:** 37

---

**Q61.** What is the Golden Rule for BCD Addition?
> **Answer:** After adding two BCD digits:
> - If result > 9 (1010-1111) → **Add 6 (0110)**
> - If there's a carry out → **Add 6 (0110)**
> 
> **Why add 6?** Binary has 16 values (0-15), BCD uses only 10 (0-9). We skip 6 unused codes.

---

**Q62.** Add 25 + 33 in BCD.
> **Answer:**
> ```
>     0010 0101   (25)
>   + 0011 0011   (33)
>   ───────────
>     0101 1000
> ```
> - Units: 0101+0011 = 1000 (8) ✓ Valid
> - Tens: 0010+0011 = 0101 (5) ✓ Valid
> 
> **No correction needed!** Result: **58**

---

**Q63.** Add 47 + 35 in BCD (with correction).
> **Answer:**
> ```
>     0100 0111   (47)
>   + 0011 0101   (35)
>   ───────────
>     0111 1100   ← Units = 1100 (12) > 9!
>   +      0110   ← Add 6 to units
>   ───────────
>     1000 0010   = 82
> ```
> **Result:** **82** ✓

---

**Q64.** What is 10's Complement Subtraction in BCD?
> **Answer:** Like 2's complement for binary!
> 
> **10's Complement of digit = 10 - digit**
> Or: **9's Complement + 1**
> 
> **Procedure for A - B:**
> 1. Find 10's complement of B
> 2. Add A + (10's complement of B)
> 3. Carry out → Positive result (discard carry)
> 4. No carry → Negative (take 10's complement)

---

**Q65.** Subtract 72 - 48 in BCD.
> **Answer:**
> 1. **10's complement of 48:** 9's comp = 51, +1 = 52
> 2. **Add:** 72 + 52
> ```
>     0111 0010   (72)
>   + 0101 0010   (52)
>   ───────────
>     1100 0100   ← Tens needs correction
>   + 0110
>   ───────────
>     0010 0100   with carry out
> ```
> 3. Carry out = 1 (discard, positive)
> 
> **Result:** **24** ✓

---

**Q66.** What happens in BCD subtraction when there's no carry out?
> **Answer:** Result is NEGATIVE.
> 
> **Example:** 34 - 57
> 1. 10's comp of 57 = 43
> 2. 34 + 43 = 77 (no carry)
> 3. No carry → Negative
> 4. 10's comp of 77 = 23
> 
> **Result:** **-23**

---

**Q67.** What are the advantages of BCD?
> **Answer:**
> 1. **Exact Decimal:** No rounding errors for money!
> 2. **Easy Conversion:** Direct mapping decimal ↔ BCD
> 3. **Human Readable:** Each nibble = one digit
> 4. **Financial Apps:** Banks, ATMs, calculators

---

**Q68.** What are the disadvantages of BCD?
> **Answer:**
> 1. **Wastes Space:** ~20% more bits than pure binary
> 2. **Slower:** Needs correction steps after arithmetic
> 3. **Complex Hardware:** Circuits more complicated

---

**Q69.** Summarize BCD Addition Rules.
> **Answer:**
> | Condition | Action |
> |:---|:---|
> | Sum ≤ 9 (0000-1001) | No correction |
> | Sum > 9 (1010-1111) | Add 6 (0110) |
> | Carry out from nibble | Add 6 (0110) |

---

**Q70.** Summarize BCD Subtraction Rules.
> **Answer:**
> | Step | Action |
> |:---|:---|
> | 1 | Find 10's complement of subtrahend |
> | 2 | Add instead of subtract |
> | 3 | Carry out? → Positive result |
> | 4 | No carry? → Negative, take 10's complement |

---

# Part 5: Instruction Codes & Computer Registers

---

**Q71.** What is an Instruction Code?
> **Answer:** An instruction code is a group of bits that instructs the computer to perform a specific operation. It is divided into parts, each having its own particular interpretation.
> 
> The most basic part is the **Operation Code (Opcode)** which specifies the operation to be performed.

---

**Q72.** What is the structure of a 16-bit Instruction Code?
> **Answer:**
> ```
> ┌──────────┬──────────────────────────────────────────┐
> │  OPCODE  │              ADDRESS                     │
> │ (4 bits) │             (12 bits)                    │
> └──────────┴──────────────────────────────────────────┘
> ```
> - **Opcode (4 bits):** Specifies operation (16 possible operations)
> - **Address (12 bits):** Specifies memory location (0-4095)

---

**Q73.** What is the Operation Code (Opcode)?
> **Answer:** A group of bits that define operations like ADD, SUB, MUL, LOAD, STORE, etc.
> - Number of bits in opcode = log₂(number of operations)
> - **Example:** 4-bit opcode can represent 2⁴ = 16 different operations

---

**Q74.** What are Registers? Why do we need them?
> **Answer:** Registers are small, super-fast storage boxes inside the CPU - the CPU's personal notepad.
> 
> **Why needed:**
> - Memory (RAM) is slow compared to CPU
> - Registers are inside CPU → very fast access
> - CPU uses registers to store temporary results
> 
> **Analogy:** Rough work paper (registers) vs textbook on shelf (RAM)

---

**Q75.** List all 8 registers of the Basic Computer with their sizes.
> **Answer:**
> | Register | Full Name | Size | Purpose |
> |----------|-----------|------|---------|
> | **AC** | Accumulator | 16 bits | Results of calculations |
> | **DR** | Data Register | 16 bits | Data from memory |
> | **AR** | Address Register | 12 bits | Memory address |
> | **IR** | Instruction Register | 16 bits | Current instruction |
> | **PC** | Program Counter | 12 bits | Next instruction's address |
> | **TR** | Temporary Register | 16 bits | Temp storage |
> | **INPR** | Input Register | 8 bits | Keyboard input |
> | **OUTR** | Output Register | 8 bits | Screen output |

---

**Q76.** What is the Accumulator (AC)?
> **Answer:** The main register where ALL calculations happen.
> - All arithmetic/logic results go to AC
> - Only register directly connected to ALU
> - Most instructions use AC
> 
> **Example:** ADD 500 → AC = AC + Memory[500]

---

**Q77.** What is the Data Register (DR)?
> **Answer:** Holds data that was just read from memory.
> - Acts as a "middleman" between memory and CPU
> 
> **Working:**
> 1. Put address in AR
> 2. Memory sends data → DR holds it
> 3. CPU uses data from DR

---

**Q78.** What is the Address Register (AR)?
> **Answer:** Holds the memory address CPU wants to access.
> - **Size:** 12 bits (because 2¹² = 4096 memory locations)
> 
> **Example:** To read Memory[500]:
> - AR ← 500
> - DR ← M[AR]

---

**Q79.** What is the Instruction Register (IR)?
> **Answer:** Holds the instruction that CPU is currently executing.
> - After fetching, IR contains: | I | Opcode | Address |
> - IR is decoded to understand what operation to perform

---

**Q80.** What is the Program Counter (PC)?
> **Answer:** Keeps track of WHICH instruction to fetch next.
> - Automatically increments: PC ← PC + 1 after each fetch
> - Jump instructions can change PC to go to a different address
> - **Size:** 12 bits (addresses 0-4095)

---

**Q81.** What are INPR and OUTR registers?
> **Answer:**
> - **INPR (Input Register):** 8 bits, receives character from keyboard
>   - When you press 'A': INPR ← 65 (ASCII)
> - **OUTR (Output Register):** 8 bits, sends character to display
>   - To print 'A': OUTR ← AC(0-7)

---

**Q82.** What are the three Addressing Modes in Basic Computer?
> **Answer:**
> 1. **Immediate Addressing:** Operand is part of instruction
> 2. **Direct Addressing (I=0):** Address field has actual memory address
> 3. **Indirect Addressing (I=1):** Address field points to location containing actual address

---

**Q83.** What is Immediate Addressing?
> **Answer:** The operand itself is part of the instruction (address field contains actual data).
> 
> - **Fastest:** No memory access needed
> - **Limited:** Operand must fit in 12 bits
> 
> **Example:** ADD #25 → AC ← AC + 25 (directly)

---

**Q84.** What is Direct Addressing (I=0)?
> **Answer:** The address field contains the actual memory address of the operand.
> - I bit = 0
> - One memory access to fetch operand
> - Effective Address = Address specified in instruction
> 
> **Example:** ADD 400 (I=0)
> - AR ← 400
> - DR ← M[400]
> - AC ← AC + DR

---

**Q85.** What is Indirect Addressing (I=1)?
> **Answer:** The address field contains address of a memory location that holds the actual address.
> - I bit = 1
> - Two memory accesses required
> - Slower but more flexible
> 
> **Example:** ADD 500 (I=1), M[500]=1000, M[1000]=85
> 1. AR ← 500
> 2. DR ← M[500] = 1000 (pointer)
> 3. AR ← 1000
> 4. DR ← M[1000] = 85 (operand)
> 5. AC ← AC + 85

---

**Q86.** Compare the three Addressing Modes.
> **Answer:**
> | Feature | Immediate | Direct (I=0) | Indirect (I=1) |
> |---------|-----------|--------------|----------------|
> | **Memory accesses** | 0 | 1 | 2 |
> | **Speed** | Fastest | Fast | Slower |
> | **Flexibility** | Least | Medium | Most |
> | **Use case** | Constants | Direct data | Pointers, arrays |

---

# Part 6: Computer Instructions

---

**Q87.** What are the three types of Instructions in Basic Computer?
> **Answer:**
> 1. **Memory Reference Instructions:** Work with memory (RAM)
> 2. **Register Reference Instructions:** Work with CPU registers only
> 3. **I/O Instructions:** Work with input/output devices
> 
> **Total:** 25 instructions (7 + 12 + 6)

---

**Q88.** What is the format of a Memory Reference Instruction?
> **Answer:**
> ```
> ┌─────┬─────────┬──────────────────┐
> │  I  │ Opcode  │     Address      │
> │(1)  │  (3)    │      (12)        │
> └─────┴─────────┴──────────────────┘
> ```
> - **Opcode:** 000 to 110 (7 instructions)
> - **I bit:** 0 = Direct, 1 = Indirect

---

**Q89.** How to identify the type of instruction? (Flowchart)
> **Answer:**
> ```
> Check Opcode (bits 14-12)
>         │
>         ├── Opcode = 000 to 110 → MEMORY REFERENCE
>         │
>         └── Opcode = 111 → Check I bit
>                 │
>                 ├── I = 0 → REGISTER REFERENCE
>                 │
>                 └── I = 1 → I/O INSTRUCTION
> ```

---

**Q90.** What are the four types of instructions based on Number of Addresses?
> **Answer:**
> 1. **Three-Address:** ADD A, B, C → A = B + C
> 2. **Two-Address:** ADD A, B → A = A + B
> 3. **One-Address:** ADD X → AC = AC + X (Accumulator-based)
> 4. **Zero-Address:** ADD → TOS = TOS + (TOS-1) (Stack-based)

---

**Q91.** Trace ADD 500 with Direct Addressing (I=0).
> **Answer:** Assume M[500] = 75
> 
> 1. AR ← 500 (Load address)
> 2. DR ← M[500] = 75 (Read memory)
> 3. AC ← AC + DR (Add to AC)
> 4. E ← Carry (Store carry)
> 
> **Effective Address = 500, Operand = 75**

---

**Q92.** Trace LDA 300 with Indirect Addressing (I=1).
> **Answer:** Assume M[300] = 600, M[600] = 1234
> 
> 1. AR ← 300 (First address)
> 2. DR ← M[300] = 600 (Get pointer)
> 3. AR ← DR = 600 (Effective address)
> 4. DR ← M[600] = 1234 (Get operand)
> 5. AC ← DR = 1234 (Load to AC)
> 
> **Effective Address = 600, Operand = 1234**

---

**Q93.** What instruction format does the Basic Computer use?
> **Answer:** The Basic Computer uses **One-Address (Accumulator-based)** format.
> - One explicit address in instruction
> - Accumulator (AC) is the implicit operand
> - All arithmetic operations involve AC

---

**Q94.** What is the significance of Bit 15 (I bit)?
> **Answer:** The I bit determines the addressing mode:
> - **I = 0:** Direct Addressing (address field = actual address)
> - **I = 1:** Indirect Addressing (address field = pointer)
> 
> For Register/I/O: I bit distinguishes between them when opcode = 111

---

**Q95.** Why is the address field 12 bits?
> **Answer:** The Basic Computer has 4096 words of memory.
> - 2¹² = 4096
> - Therefore, 12 bits can address all memory locations (0 to 4095)

---

