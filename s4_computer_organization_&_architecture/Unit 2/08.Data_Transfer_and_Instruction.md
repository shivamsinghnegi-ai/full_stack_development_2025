# Data Transfer Instructions

## 1. Types of Data Transfer

```
┌─────────────────────────────────────────────────────────────┐
│           DATA TRANSFER INSTRUCTIONS                        │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  Memory ←→ Register                                         │
│  Register ←→ Register                                       │
│  I/O Device ←→ Register                                     │
│  Stack ←→ Register                                          │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## 2. Common Data Transfer Instructions

| Instruction | RTL | Description |
|-------------|-----|-------------|
| **LOAD** | R ← M[addr] | Memory to Register |
| **STORE** | M[addr] ← R | Register to Memory |
| **MOVE** | R2 ← R1 | Register to Register |
| **EXCHANGE** | R1 ↔ R2 | Swap two registers |
| **PUSH** | SP←SP-1, M[SP]←R | Register to Stack |
| **POP** | R←M[SP], SP←SP+1 | Stack to Register |
| **INPUT** | R ← I/O Port | Input Device to Register |
| **OUTPUT** | I/O Port ← R | Register to Output Device |

---

# Data Manipulation Instructions

## 1. Arithmetic Instructions

| Instruction | Operation | Description |
|-------------|-----------|-------------|
| **ADD** | R ← R + X | Addition |
| **SUB** | R ← R - X | Subtraction |
| **MUL** | R ← R × X | Multiplication |
| **DIV** | R ← R ÷ X | Division |
| **INC** | R ← R + 1 | Increment by 1 |
| **DEC** | R ← R - 1 | Decrement by 1 |
| **NEG** | R ← -R | 2's Complement (Negate) |

### Flags Affected:

| Flag | Full Name | Set When |
|------|-----------|----------|
| **C** | Carry | Carry/Borrow from MSB |
| **Z** | Zero | Result = 0 |
| **S** | Sign | Result is negative (MSB = 1) |
| **V** | Overflow | Signed overflow occurred |

---

## 2. Logical Instructions

| Instruction | Operation | Description |
|-------------|-----------|-------------|
| **AND** | R ← R ∧ X | Bitwise AND |
| **OR** | R ← R ∨ X | Bitwise OR |
| **XOR** | R ← R ⊕ X | Bitwise XOR |
| **NOT** | R ← R' | Complement all bits |
| **CLEAR** | R ← 0 | Set to all zeros |
| **SET** | R ← all 1s | Set to all ones |

### Applications:

```
AND: Masking (Clear specific bits)
     1010 1100 AND 0000 1111 = 0000 1100 (keep lower 4 bits)

OR:  Setting bits
     1010 0000 OR 0000 1111 = 1010 1111 (set lower 4 bits)

XOR: Toggling bits
     1010 1010 XOR 1111 0000 = 0101 1010 (toggle upper 4 bits)

NOT: Complement
     NOT 1010 1100 = 0101 0011
```

---

## 3. Shift Instructions

### Types of Shifts:

```
┌─────────────────────────────────────────────────────────────┐
│                     SHIFT OPERATIONS                        │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  1. LOGICAL SHIFT                                           │
│     - Zeros fill vacant positions                           │
│     - Used for unsigned numbers                             │
│                                                             │
│  2. ARITHMETIC SHIFT                                        │
│     - Sign bit preserved (for right shift)                  │
│     - Used for signed numbers                               │
│                                                             │
│  3. ROTATE (CIRCULAR SHIFT)                                 │
│     - Bits wrap around                                      │
│     - No bits are lost                                      │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### Shift Instructions Table:

| Instruction | Operation | Description |
|-------------|-----------|-------------|
| **SHL/SLA** | Shift Left | Multiply by 2 |
| **SHR** | Logical Shift Right | Divide by 2 (unsigned) |
| **SAR/SRA** | Arithmetic Shift Right | Divide by 2 (signed) |
| **ROL** | Rotate Left | Circular left |
| **ROR** | Rotate Right | Circular right |

---

### Visual Examples:

**Logical Shift Left (SHL):**
```
Before: 0│1010 1100│
After:  │0101 1000│0
        ↑         ↑
     Discarded   Filled with 0

Effect: Multiply by 2
```

**Logical Shift Right (SHR):**
```
Before: │1010 1100│0
After:  0│0101 0110│
        ↑         ↑
   Filled with 0  Discarded

Effect: Divide by 2 (unsigned)
```

**Arithmetic Shift Right (SAR):**
```
Before: │1│010 1100│   (negative number, sign bit = 1)
After:  │1│101 0110│
         ↑
    Sign bit PRESERVED (extended)

Effect: Divide by 2 (signed, keeps sign)
```

**Rotate Left (ROL):**
```
Before: │1│010 1100│
After:  │0│101 1001│
         ↑         ↑
    Goes to LSB   MSB wraps around

No bits lost!
```

**Rotate Right (ROR):**
```
Before: │1010 110│1│
After:  │1│101 0110│
         ↑    
    LSB wraps to MSB

No bits lost!
```

---

## 4. Why Shifts are Useful

| Operation | Equivalent To |
|-----------|---------------|
| Shift Left by 1 | Multiply by 2 |
| Shift Left by n | Multiply by 2ⁿ |
| Shift Right by 1 | Divide by 2 |
| Shift Right by n | Divide by 2ⁿ |

**Example:**
```
5 × 4 = 5 × 2² = 5 << 2

5 in binary:  0000 0101
Shift left 2: 0001 0100 = 20 ✓
```

---

# Program Control Instructions

## 1. Types of Control Instructions

| Type | Examples | Purpose |
|------|----------|---------|
| **Unconditional** | JMP, BRA | Always jump |
| **Conditional** | BZ, BNZ, BC, BV | Jump if condition true |
| **Subroutine** | CALL, RET | Function calls |
| **Loop** | LOOP | Decrement and branch |
| **Interrupt** | INT, IRET | Software interrupts |
| **Halt** | HLT | Stop execution |

---

## 2. Conditional Branch Instructions

| Instruction | Condition | Jump if... |
|-------------|-----------|------------|
| **BZ** | Z = 1 | Zero (result = 0) |
| **BNZ** | Z = 0 | Not Zero |
| **BC** | C = 1 | Carry |
| **BNC** | C = 0 | No Carry |
| **BN/BM** | S = 1 | Negative (Minus) |
| **BP** | S = 0 | Positive (Plus) |
| **BV** | V = 1 | Overflow |

---

# Summary Tables for Exam

## 1. Addressing Modes Quick Reference

| Mode | Symbol | EA = | Access |
|------|--------|------|--------|
| Immediate | #X | - | 0 |
| Direct | X | X | 1 |
| Indirect | @X | M[X] | 2 |
| Register | R | R | 0 |
| Reg. Indirect | (R) | M[R] | 1 |
| Indexed | X(R) | X + R | 1 |
| Relative | +/-offset | PC + offset | 1 |
| Base | X(BR) | X + BR | 1 |

## 2. Instruction Categories

| Category | Examples | Count |
|----------|----------|-------|
| Data Transfer | LOAD, STORE, MOVE, PUSH, POP | 8 |
| Arithmetic | ADD, SUB, MUL, DIV, INC, DEC | 7 |
| Logical | AND, OR, XOR, NOT, CLEAR | 6 |
| Shift | SHL, SHR, SAR, ROL, ROR | 5 |
| Control | JMP, Bxx, CALL, RET, HLT | Many |

---

## Quick Revision Points

1. **Indexed** addressing is best for **arrays**
2. **Relative** addressing is best for **branches**
3. **Base Register** is for **relocatable code**
4. **SHL** = Multiply by 2
5. **SHR** = Divide by 2 (unsigned)
6. **SAR** = Divide by 2 (signed, preserves sign)
7. **Rotate** = No bits lost (wrap around)
8. **Z flag** set when result = 0
9. **C flag** set on carry from MSB
10. **V flag** set on signed overflow

---
