# 1. Instruction Codes

## 1.1 What is an Instruction Code?

An **instruction code** is a group of bits that instructs the computer to perform a specific operation. It is divided into parts, each having its own particular interpretation.

> [!NOTE]
> The most basic part of an instruction code is the **operation code (opcode)** which specifies the operation to be performed.

## 1.2 Structure of Instruction Code

```
┌─────────────────────────────────────────────────────┐
│              INSTRUCTION CODE (16 bits)             │
├──────────┬──────────────────────────────────────────┤
│  OPCODE  │              ADDRESS                     │
│ (4 bits) │             (12 bits)                    │
└──────────┴──────────────────────────────────────────┘
     │                    │
     │                    └──→ Specifies memory location (0-4095)
     └──────────────────────→ Specifies operation (16 possible operations)
```

## 1.3 Components of Instruction Code

### Operation Code (Opcode)
- A group of bits that define operations like **ADD, SUB, MUL, LOAD, STORE**, etc.
- Number of bits in opcode = log₂(number of operations)
- Example: 4-bit opcode can represent 2⁴ = 16 different operations

### Address Field
- Specifies the **memory address** of the operand
- In a basic computer with 4096 words of memory, we need 12 bits (2¹² = 4096)

## 1.4 Stored Program Concept

The computer stores both **instructions** and **data** in the same memory unit. This is the foundation of the **Von Neumann Architecture**.

```
┌─────────────────────────────────────────┐
│              MEMORY (4096 × 16)         │
├─────────────────────────────────────────┤
│  Address 0    │  Instruction 1          │
│  Address 1    │  Instruction 2          │
│  Address 2    │  Data 1                 │
│  Address 3    │  Data 2                 │
│     ...       │     ...                 │
│  Address 4095 │  Instruction/Data       │
└─────────────────────────────────────────┘
```
---
# 2. Computer Registers

## 2.1 What are Registers?

**Registers** are small, super-fast storage boxes inside the CPU. Think of them as the CPU's personal notepad where it keeps data it's currently working on.

**Why do we need registers?**
- Memory (RAM) is slow compared to CPU
- Registers are inside the CPU → very fast access
- CPU uses registers to store temporary results

> **Simple Analogy:** Imagine you're solving a math problem. Your rough work paper (registers) is right in front of you, but your textbook (RAM) is on a shelf. Which is faster to access?

---

## 2.2 All 8 Registers

The basic computer has **8 registers**. Here's an easy-to-remember summary:

| Register | Full Name | Size | What it stores | Easy Way to Remember |
|----------|-----------|------|----------------|---------------------|
| **AC** | Accumulator | 16 bits | Results of calculations | "AC = Answer Collector" |
| **DR** | Data Register | 16 bits | Data from memory | "DR = Data Reader" |
| **AR** | Address Register | 12 bits | Memory address | "AR = Address Rememberer" |
| **IR** | Instruction Register | 16 bits | Current instruction | "IR = Instruction Reader" |
| **PC** | Program Counter | 12 bits | Next instruction's address | "PC = Program Counter (line number)" |
| **TR** | Temporary Register | 16 bits | Temp storage | "TR = Temporary Room" |
| **INPR** | Input Register | 8 bits | Keyboard input | "INPR = Input from keyboard" |
| **OUTR** | Output Register | 8 bits | Screen output | "OUTR = Output to screen" |

### Why these specific sizes?

```
┌────────────────────────────────────────────────────────────┐
│  AC, DR, IR, TR = 16 bits  (because memory word = 16 bits) │
│  AR, PC = 12 bits          (because 2¹² = 4096 addresses)  │
│  INPR, OUTR = 8 bits       (because ASCII character = 8 bits)│
└────────────────────────────────────────────────────────────┘
```

---

## 2.3 Understanding Each Register (Exam Important!)

### AC - Accumulator (16 bits) Most Important!

**What it does:** The main register where ALL calculations happen.

```
Example: ADD 500 (Add value at memory location 500 to AC)

Before: AC = 10, Memory[500] = 5
After:  AC = 15
```

**Key Points for Exam:**
- All arithmetic/logic results go to AC
- Only register directly connected to ALU
- Most instructions use AC

---

### DR - Data Register (16 bits)

**What it does:** Holds data that was just read from memory.

```
When CPU needs data from memory:
Step 1: Put address in AR
Step 2: Memory sends data → DR holds it
Step 3: CPU uses data from DR
```

**Key Point:** DR acts as a "middleman" between memory and CPU.

---

### AR - Address Register (12 bits)

**What it does:** Holds the memory address CPU wants to access.

```
To read Memory[500]:
AR ← 500  (Put 500 in AR)
DR ← M[AR] (Memory sends data at address 500 to DR)
```

**Why 12 bits?** Because 2¹² = 4096, and we have 4096 memory locations.

---

### IR - Instruction Register (16 bits)

**What it does:** Holds the instruction that CPU is currently executing.

```
After fetching instruction from memory:
IR contains: | I | Opcode | Address |
             | 1 |   3    |   12    | bits
```

**Key Point:** IR is decoded to understand what operation to perform.

---

### PC - Program Counter (12 bits)

**What it does:** Keeps track of WHICH instruction to fetch next.

```
Program in Memory:        PC Value:
Address 100: ADD 500      PC = 100 → fetches ADD 500
Address 101: LDA 600      PC = 101 → fetches LDA 600
Address 102: STA 700      PC = 102 → fetches STA 700
```

**Key Points:**
- Automatically increments: PC ← PC + 1 after each fetch
- Jump instructions can change PC to go to a different address

---

### TR - Temporary Register (16 bits)

**What it does:** Extra storage for intermediate calculations.

**Simple:** When CPU needs to remember something temporarily while doing other work.

---

### INPR - Input Register (8 bits)

**What it does:** Receives character from keyboard.

```
When you press 'A' on keyboard:
INPR ← 65 (ASCII code of 'A')
AC(0-7) ← INPR (Transfer to AC for processing)
```

---

### OUTR - Output Register (8 bits)

**What it does:** Sends character to display/printer.

```
To print 'A' on screen:
OUTR ← AC(0-7) (AC contains 65)
Display shows 'A'
```

---
# 3. Addressing Modes in Basic Computer

The basic computer supports **three addressing modes**:
1. Immediate Addressing
2. Direct Addressing (I = 0)
3. Indirect Addressing (I = 1)

---

### 1. Immediate Addressing

In immediate addressing, the **operand itself is part of the instruction** (the address field contains the actual data, not a memory address).

```
┌─────────────┬─────────────────────┐
│   Opcode    │      Operand        │
└─────────────┴─────────────────────┘
                    ↓
           (Address acts as Operand)
```

**Key Characteristics:**
- Operand is available immediately (no memory access needed)
- Fastest addressing mode
- Limited by the size of address field (operand must fit in 12 bits)
- Used for constants and immediate values

**Example:**
```
Instruction: ADD #25
The value 25 is directly added to AC
AC ← AC + 25
No memory access required!
```

---

### 2. Direct Addressing (I = 0)

In direct addressing, the address field contains the **actual memory address** of the operand.

```
INSTRUCTION FORMAT:
┌───┬────────┬─────────────────┐
│ 0 │ Opcode │    Address      │
└───┴────────┴─────────────────┘
  I=0              │
                   ▼
         ┌─────────────────────┐
         │  Effective Address  │
         │   = Address Field   │
         └─────────────────────┘

MEMORY ACCESS:
┌──────────────────────────────────────────────────────┐
│ Instruction: 22  │ 0 │ ADD │ 400 │                   │
└──────────────────────────────────────────────────────┘
                              │
                              ▼
                    ┌─────────────────┐
         Address 400│    OPERAND      │──→ Effective Address
                    └─────────────────┘
```

**Key Characteristics:**
- I bit = 0
- One memory access to fetch operand
- Effective Address = Address specified in instruction
- Simple and fast

**Example:**
```
Instruction: ADD 400 (I=0)
Assume: M[400] = 75

Execution:
1. AR ← 400          (Load address 400 to AR)
2. DR ← M[400]       (DR gets 75 from memory)
3. AC ← AC + DR      (AC = AC + 75)

Effective Address = 400
Operand = 75
```

---

### 3. Indirect Addressing (I = 1)

In indirect addressing, the address field contains the address of a **memory location that holds the actual address** of the operand.

```
INSTRUCTION FORMAT:
┌───┬────────┬─────────────────┐
│ 1 │ Opcode │    Address      │
└───┴────────┴─────────────────┘
  I=1              │
                   ▼
         ┌─────────────────────┐
         │ Points to location  │
         │ containing actual   │
         │ effective address   │
         └─────────────────────┘

MEMORY ACCESS (Two-Level):
┌──────────────────────────────────────────────────────┐
│ Instruction: 35  │ 1 │ ADD │ 500 │                   │
└──────────────────────────────────────────────────────┘
                              │
                              ▼
                    ┌─────────────────┐
         Address 500│      1000       │ (Pointer)
                    └─────────────────┘
                              │
                              ▼
                    ┌─────────────────┐
        Address 1000│    OPERAND      │──→ Effective Address
                    └─────────────────┘
```

**Key Characteristics:**
- I bit = 1
- Two memory accesses required
- Effective Address = Contents of the address in instruction
- Slower but more flexible (can access any memory location)

**Example:**
```
Instruction: ADD 500 (I=1)
Assume: M[500] = 1000, M[1000] = 85

Execution:
1. AR ← 500          (Load address 500 to AR)
2. DR ← M[500]       (DR gets 1000 - the pointer)
3. AR ← DR           (AR now has 1000)
4. DR ← M[1000]      (DR gets 85 - the actual operand)
5. AC ← AC + DR      (AC = AC + 85)

Effective Address = 1000
Operand = 85
```

---

### Comparison Table

| Feature | Immediate | Direct (I=0) | Indirect (I=1) |
|---------|-----------|--------------|----------------|
| I bit | N/A | 0 | 1 |
| Memory accesses | 0 | 1 | 2 |
| Operand location | In instruction | At address field | At address stored in address field |
| Speed | Fastest | Fast | Slower |
| Flexibility | Least (limited size) | Medium | Most |
| Use case | Constants | Direct data access | Pointers, arrays |

### Visual Summary

```
IMMEDIATE:     Instruction → Operand (directly)

DIRECT:        Instruction → Address → [Memory] = Operand

INDIRECT:      Instruction → Address → [Memory] = Pointer → [Memory] = Operand
```

---

```
> **Why is this important?** This is the basis of **Von Neumann Architecture** - the design used in most computers today!
