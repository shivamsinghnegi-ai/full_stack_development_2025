# Stack Organization

---

# 1. Introduction to Stack

## 1.1 What is a Stack?

A **Stack** is a storage structure that follows **LIFO** (Last-In-First-Out) principle.

```
┌─────────────────────────────────────────────────────────────┐
│                         STACK                               │
│                                                             │
│   Think of it like a stack of plates:                       │
│   - You add plates on TOP (PUSH)                            │
│   - You remove plates from TOP (POP)                        │
│   - You can't access plates in the middle!                  │
│                                                             │
│          ┌───────┐                                          │
│   TOP →  │ Plate │  ← Last added, First removed             │
│          ├───────┤                                          │
│          │ Plate │                                          │
│          ├───────┤                                          │
│          │ Plate │  ← First added, Last removed             │
│          └───────┘                                          │
│         BOTTOM                                              │
└─────────────────────────────────────────────────────────────┘
```

---

## 1.2 Stack Operations

| Operation | Description | Effect on SP |
|-----------|-------------|--------------|
| **PUSH** | Add item to top | SP changes |
| **POP** | Remove item from top | SP changes |

---

## 1.3 Stack Pointer (SP)

The **Stack Pointer (SP)** is a register that always points to the **top of the stack**.

```
┌─────────────────────────────────────────────────────────────┐
│                                                             │
│   Memory:          After PUSH A:       After PUSH B:        │
│                                                             │
│   ┌───────┐        ┌───────┐           ┌───────┐            │
│   │       │        │       │           │   B   │ ← SP       │
│   ├───────┤        ├───────┤           ├───────┤            │
│   │       │        │   A   │ ← SP      │   A   │            │
│   ├───────┤        ├───────┤           ├───────┤            │
│   │       │ ← SP   │       │           │       │            │
│   └───────┘        └───────┘           └───────┘            │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

# 2. Types of Stack Organization

## 2.1 Register Stack

Stack implemented using a **set of registers** inside the CPU.

```
┌─────────────────────────────────────────────────────────────┐
│                    REGISTER STACK                           │
│                                                             │
│   ┌──────────────────────────────────┐                      │
│   │  Register 63   │               │                        │
│   ├──────────────────────────────────┤                      │
│   │  Register 62   │               │                        │
│   ├──────────────────────────────────┤                      │
│   │      ...       │               │                        │
│   ├──────────────────────────────────┤                      │
│   │  Register 2    │    Data C     │ ← SP = 2 (TOP)         │
│   ├──────────────────────────────────┤                      │
│   │  Register 1    │    Data B     │                        │
│   ├──────────────────────────────────┤                      │
│   │  Register 0    │    Data A     │ (BOTTOM)               │
│   └──────────────────────────────────┘                      │
│                                                             │
│   Stack grows UPWARD (SP increases on PUSH)                 │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### Register Stack Characteristics:

| Feature | Description |
|---------|-------------|
| **Size** | Limited (typically 64-128 registers) |
| **Speed** | Very Fast (no memory access) |
| **Location** | Inside CPU |
| **Use** | Expression evaluation, nested calls |

---

### Register Stack Operations (Stack grows UP):

```
┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│   PUSH Operation:                                               │
│   ───────────────                                               │
│   SP ← SP + 1          ; Increment stack pointer                │
│   M[SP] ← DR           ; Write data to new top                  │
│                                                                 │
│   If SP = 0 after increment (wrapped around), FULL ← 1          │
│   EMTY ← 0             ; Stack is not empty anymore             │
│                                                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   POP Operation:                                                │
│   ──────────────                                                │
│   DR ← M[SP]           ; Read data from top                     │
│   SP ← SP - 1          ; Decrement stack pointer                │
│                                                                 │
│   If SP = 0, EMTY ← 1  ; Stack is now empty                     │
│   FULL ← 0             ; Stack is not full anymore              │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

### FULL and EMPTY Flags:

| Flag | Meaning | When Set |
|------|---------|----------|
| **FULL** | Stack is full | SP reaches maximum |
| **EMTY** | Stack is empty | SP = 0 (nothing to pop) |

```
Overflow:  Trying to PUSH when FULL = 1  → ERROR!
Underflow: Trying to POP when EMTY = 1   → ERROR!
```

---

## 2.2 Memory Stack

Stack implemented in **main memory (RAM)**.

```
┌─────────────────────────────────────────────────────────────┐
│                    MEMORY STACK                             │
│                                                             │
│   Memory Layout (stack grows DOWNWARD):                     │
│                                                             │
│   Address 0    ┌──────────────────────────────────┐         │
│                │         PROGRAM                  │         │
│                │         (Code)                   │         │
│                ├──────────────────────────────────┤         │
│                │         DATA                               │
│                │         (Variables)              │         │
│   Address 1000 ├──────────────────────────────────┤         │
│                │                                  │         │
│                │         FREE                     │         │
│                │         SPACE                    │         │
│                │            ↑                     │         │
│                │         Stack grows UP           │         │
│                │         (toward lower addr)      │         │
│                ├──────────────────────────────────┤         │
│   SP →         │         TOP of Stack             │         │
│                ├──────────────────────────────────┤         │
│                │         Stack Data               │         │
│                ├──────────────────────────────────┤         │
│   Address 4000 │         BOTTOM of Stack          │         │
│                └──────────────────────────────────┘         │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### Memory Stack Characteristics:

| Feature | Description |
|---------|-------------|
| **Size** | Large (limited by available memory) |
| **Speed** | Slower (requires memory access) |
| **Location** | In RAM |
| **Use** | Subroutine calls, local variables |

---

### Memory Stack Operations (Stack grows DOWN):

```
┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│   PUSH Operation:                                               │
│   ───────────────                                               │
│   SP ← SP - 1          ; Decrement SP (move up in memory)       │
│   M[SP] ← DR           ; Write data to new top                  │
│                                                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   POP Operation:                                                │
│   ──────────────                                                │
│   DR ← M[SP]           ; Read data from top                     │
│   SP ← SP + 1          ; Increment SP (move down in memory)     │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**Note:** Memory stack grows DOWNWARD (opposite of register stack!)

---

## 2.3 Comparison: Register Stack vs Memory Stack

| Feature | Register Stack | Memory Stack |
|---------|----------------|--------------|
| **Location** | Inside CPU | In RAM |
| **Size** | Small (64-128) | Large |
| **Speed** | Very Fast | Slower |
| **PUSH Direction** | SP increases (↑) | SP decreases (↓) |
| **POP Direction** | SP decreases (↓) | SP increases (↑) |
| **Use** | Quick operations | Subroutines |

---

# 3. Stack Applications

## 3.1 Subroutine Calls (Very Important!)

When calling a subroutine, we need to save the **return address**.

```
┌─────────────────────────────────────────────────────────────┐
│                                                             │
│   Main Program:            Memory Stack:                    │
│                                                             │
│   Address 100: CALL SUB    │         │                      │
│   Address 101: (return)    │         │                      │
│                            │   101   │ ← SP (return address)│
│                            │         │                      │
│   Subroutine:                                               │
│   Address 500: SUB: ...                                     │
│   Address 510: RETURN                                       │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### CALL Instruction:
```
SP ← SP - 1      ; Make room on stack
M[SP] ← PC       ; Save return address (101)
PC ← SUB         ; Jump to subroutine (500)
```

### RETURN Instruction:
```
PC ← M[SP]       ; Get return address (101)
SP ← SP + 1      ; Pop the stack
; Now execution continues at 101
```

---

## 3.2 Nested Subroutine Calls

Stack handles **multiple levels** of subroutine calls perfectly!

```
Main calls A, A calls B, B calls C:

Stack State:
┌─────────────────────────────────────────────────────────────┐
│                                                             │
│   After CALL A:     After CALL B:     After CALL C:         │
│                                                             │
│   │         │       │         │       │ Return C │ ← SP     │
│   │         │       │ Return B│ ← SP  │ Return B │          │
│   │ Return A│ ← SP  │ Return A│       │ Return A │          │
│   └─────────┘       └─────────┘       └──────────┘          │
│                                                             │
│   After RET from C: After RET from B: After RET from A:     │
│                                                             │
│   │         │       │         │       │         │           │
│   │ Return B│ ← SP  │         │       │         │           │
│   │ Return A│       │ Return A│ ← SP  │         │ ← SP      │
│   └─────────┘       └─────────┘       └─────────┘           │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 3.3 Expression Evaluation (Reverse Polish Notation)

Stack is perfect for evaluating expressions in **Postfix (RPN)** notation.

### Example: Evaluate `3 4 + 5 *` (which is (3+4)*5 = 35)

```
┌─────────────────────────────────────────────────────────────┐
│                                                             │
│   Step 1: PUSH 3      │  3  │                               │
│                       └─────┘                               │
│                                                             │
│   Step 2: PUSH 4      │  4  │                               │
│                       │  3  │                               │
│                       └─────┘                               │
│                                                             │
│   Step 3: ADD         Pop 4, Pop 3                          │
│                       Push (3+4=7)                          │
│                       │  7  │                               │
│                       └─────┘                               │
│                                                             │
│   Step 4: PUSH 5      │  5  │                               │
│                       │  7  │                               │
│                       └─────┘                               │
│                                                             │
│   Step 5: MUL         Pop 5, Pop 7                          │
│                       Push (7*5=35)                         │
│                       │ 35  │  ← RESULT!                    │
│                       └─────┘                               │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 3.4 Infix to Postfix Conversion

| Infix (Normal) | Postfix (RPN) |
|----------------|---------------|
| A + B | A B + |
| A + B * C | A B C * + |
| (A + B) * C | A B + C * |
| A * B + C * D | A B * C D * + |

---

# 4. Stack Instructions

## 4.1 Common Stack Instructions

| Instruction | Operation | Description |
|-------------|-----------|-------------|
| **PUSH X** | SP←SP-1, M[SP]←X | Push X onto stack |
| **POP X** | X←M[SP], SP←SP+1 | Pop top to X |
| **CALL addr** | SP←SP-1, M[SP]←PC, PC←addr | Call subroutine |
| **RET** | PC←M[SP], SP←SP+1 | Return from subroutine |

---

## 4.2 Stack-Based (Zero-Address) Instructions

In stack machines, operations work on **top of stack**:

```
ADD:  Pop two items, add them, push result
SUB:  Pop two items, subtract them, push result
MUL:  Pop two items, multiply them, push result
DIV:  Pop two items, divide them, push result
```

### Example: X = (A + B) * C using stack

```assembly
PUSH A       ; Stack: [A]
PUSH B       ; Stack: [A, B]
ADD          ; Stack: [A+B]
PUSH C       ; Stack: [A+B, C]
MUL          ; Stack: [(A+B)*C]
POP X        ; X = (A+B)*C, Stack: empty
```

---

# 5. Important Points for Exam

## 5.1 Must Remember:

| Concept | Key Point |
|---------|-----------|
| **LIFO** | Last-In-First-Out |
| **SP** | Stack Pointer (points to TOP) |
| **PUSH** | Add to top, SP changes |
| **POP** | Remove from top, SP changes |
| **Register Stack** | Grows UP (SP increases) |
| **Memory Stack** | Grows DOWN (SP decreases) |
| **Overflow** | Push when stack is full |
| **Underflow** | Pop when stack is empty |

## 5.2 Quick Formulas:

```
Register Stack (grows UP):
  PUSH: SP ← SP + 1, then M[SP] ← Data
  POP:  Data ← M[SP], then SP ← SP - 1

Memory Stack (grows DOWN):
  PUSH: SP ← SP - 1, then M[SP] ← Data
  POP:  Data ← M[SP], then SP ← SP + 1
```

## 5.3 Common Exam Questions:

**Q: What is the difference between register and memory stack?**
A: Register stack is in CPU (fast, small), Memory stack is in RAM (slow, large).

**Q: Why does memory stack grow downward?**
A: To separate it from program/data area which grows upward.

**Q: How does stack help in recursion?**
A: Each recursive call pushes return address and local variables; they're automatically restored on return.

---

## Quick Revision MCQs

1. **Stack follows which principle?** → LIFO
2. **SP points to?** → Top of stack
3. **PUSH does what to SP in memory stack?** → Decrements (SP-1)
4. **POP does what to SP in memory stack?** → Increments (SP+1)
5. **Overflow occurs when?** → Push on full stack
6. **Underflow occurs when?** → Pop from empty stack
7. **What is RPN?** → Reverse Polish Notation (Postfix)

---
