
# Additional Addressing Modes

You've already learned Immediate, Direct, and Indirect. Here are the remaining modes:

## 1. Register Addressing

**Operand is in a register** (not in memory).

```
┌─────────────────────────────────────────────────────────────┐
│  Instruction: ADD R1                                        │
│                                                             │
│  ┌────────┬─────────┐                                       │
│  │ Opcode │   R1    │                                       │
│  └────────┴────┬────┘                                       │
│                │                                            │
│                ▼                                            │
│         ┌───────────┐                                       │
│         │  Register │                                       │
│         │    R1     │ = OPERAND                             │
│         └───────────┘                                       │
│                                                             │
│  EA = Register itself                                       │
│  Operand = Contents of Register                             │
└─────────────────────────────────────────────────────────────┘
```

| Feature | Value |
|---------|-------|
| Memory Access | 0 (None!) |
| Speed | Fastest |
| Address Field | Small (few bits for register number) |

**Example:**
```
ADD R1        ; AC ← AC + R1
MOV R2, R3    ; R2 ← R3
```

---

## 2. Register Indirect Addressing

**Register contains the ADDRESS** of the operand (pointer in register).

```
┌─────────────────────────────────────────────────────────────┐
│  Instruction: ADD (R1)    or    ADD @R1                     │
│                                                             │
│  ┌────────┬─────────┐                                       │
│  │ Opcode │   R1    │                                       │
│  └────────┴────┬────┘                                       │
│                │                                            │
│                ▼                                            │
│         ┌───────────┐                                       │
│         │    R1     │ = 500 (ADDRESS)                       │
│         └─────┬─────┘                                       │
│               │                                             │
│               ▼                                             │
│         ┌───────────┐                                       │
│         │  M[500]   │ = OPERAND                             │
│         └───────────┘                                       │
│                                                             │
│  EA = Contents of Register                                  │
│  Operand = M[Register contents]                             │
└─────────────────────────────────────────────────────────────┘
```

| Feature | Value |
|---------|-------|
| Memory Access | 1 |
| Speed | Fast |
| Use Case | Pointers, Arrays |

**Example:**
```
R1 = 500, M[500] = 75
ADD (R1)      ; AC ← AC + M[500] = AC + 75
```

---

## 3. Indexed Addressing

**EA = Base Address + Index Register**

```
┌─────────────────────────────────────────────────────────────┐
│  Instruction: ADD 1000(X)                                   │
│               (X = Index Register)                          │
│                                                             │
│  ┌────────┬──────────┬─────────┐                            │
│  │ Opcode │  1000    │    X    │                            │
│  └────────┴────┬─────┴────┬────┘                            │
│                │          │                                 │
│                ▼          ▼                                 │
│             1000    +     5    = 1005 (EA)                  │
│                           │                                 │
│                           ▼                                 │
│                    ┌───────────┐                            │
│                    │  M[1005]  │ = OPERAND                  │
│                    └───────────┘                            │
│                                                             │
│  EA = Address Field + Index Register                        │
└─────────────────────────────────────────────────────────────┘
```

| Feature | Value |
|---------|-------|
| Memory Access | 1 |
| Speed | Fast |
| **Best Use** | **Array Access!** |

**Example: Accessing Array[i]**
```
Array starts at address 1000
X (index register) = 5

LOAD 1000(X)    ; Load Array[5]
                ; EA = 1000 + 5 = 1005
                ; AC ← M[1005]
```

---

## 4. Relative Addressing (PC-Relative)

**EA = PC + Offset**

```
┌─────────────────────────────────────────────────────────────┐
│  Instruction: BRA +10    (Branch with offset +10)           │
│                                                             │
│  Current PC = 100                                           │
│                                                             │
│  ┌────────┬──────────┐                                      │
│  │ Opcode │   +10    │ (Offset/Displacement)                │
│  └────────┴────┬─────┘                                      │
│                │                                            │
│                ▼                                            │
│         EA = PC + Offset                                    │
│            = 100 + 10 = 110                                 │
│                                                             │
│  Next instruction fetched from address 110                  │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

| Feature | Value |
|---------|-------|
| Memory Access | 1 |
| **Best Use** | **Branches, Loops** |
| Advantage | Position-independent code |

**Example:**
```
PC = 200
BRA -5        ; EA = 200 + (-5) = 195
              ; Jump 5 locations backward
```

---

## 5. Base Register Addressing

**EA = Base Register + Offset**

```
┌─────────────────────────────────────────────────────────────┐
│  Instruction: ADD 50(BR)                                    │
│               (BR = Base Register)                          │
│                                                             │
│  ┌────────┬──────────┬─────────┐                            │
│  │ Opcode │    50    │   BR    │                            │
│  └────────┴────┬─────┴────┬────┘                            │
│                │          │                                 │
│                ▼          ▼                                 │
│               50    +   2000   = 2050 (EA)                  │
│                                                             │
│  EA = Offset + Base Register                                │
└─────────────────────────────────────────────────────────────┘
```

| Feature | Value |
|---------|-------|
| Memory Access | 1 |
| **Best Use** | **Relocatable Programs, Segments** |

**Example:**
```
BR = 2000 (base of data segment)
LOAD 50(BR)   ; EA = 2000 + 50 = 2050
              ; Load from data segment offset 50
```

---

## 6. Master Comparison Table (Very Important!)

| Mode | EA Formula | Memory Access | Speed | Use Case |
|------|-----------|---------------|-------|----------|
| **Immediate** | Operand in instruction | 0 | Fastest | Constants |
| **Direct** | EA = Address | 1 | Fast | Simple variables |
| **Indirect** | EA = M[Address] | 2 | Slow | Pointers |
| **Register** | EA = Register | 0 | Fastest | Temp values |
| **Reg. Indirect** | EA = M[Register] | 1 | Fast | Pointers in regs |
| **Indexed** | EA = Addr + Index | 1 | Fast | **Arrays** |
| **Relative** | EA = PC + Offset | 1 | Fast | **Branches** |
| **Base Register** | EA = BR + Offset | 1 | Fast | **Relocation** |

---

## 7. Numerical Example (Exam Type!)

**Given:**
```
PC = 200, R1 = 400, BR = 1000
M[400] = 500, M[500] = 600, M[1050] = 700
```

**Find EA and Operand for each:**

| Mode | Instruction | EA | Operand |
|------|-------------|----|---------| 
| Immediate | ADD #50 | - | 50 |
| Direct | ADD 400 | 400 | M[400] = 500 |
| Indirect | ADD @400 | M[400] = 500 | M[500] = 600 |
| Register | ADD R1 | R1 | 400 |
| Reg. Indirect | ADD (R1) | R1 = 400 | M[400] = 500 |
| Indexed | ADD 100(R1) | 100+400 = 500 | M[500] = 600 |
| Relative | BRA +50 | 200+50 = 250 | (branch target) |
| Base Reg. | ADD 50(BR) | 1000+50 = 1050 | M[1050] = 700 |

---
