# Input-Output and Interrupt

---

# 1. Input-Output Configuration

## 1.1 I/O System Overview

The basic computer communicates with external devices (keyboard, display) using **I/O registers and flags**.

```
┌─────────────────────────────────────────────────────────────────┐
│                    I/O CONFIGURATION                            │
│                                                                 │
│    ┌──────────────┐           ┌──────────────────┐              │
│    │   KEYBOARD   │           │     DISPLAY      │              │
│    └──────┬───────┘           └────────┬─────────┘              │
│           │                            │                        │
│           ▼                            ▲                        │
│    ┌──────────────┐           ┌────────────────┐                │
│    │  INPR (8)    │           │   OUTR (8)     │                │
│    │ Input Reg    │           │  Output Reg    │                │
│    └──────┬───────┘           └────────┬───────┘                │
│           │                            │                        │
│    ┌──────────────┐           ┌────────────────┐                │
│    │  FGI (1 bit) │           │  FGO (1 bit)   │                │
│    │ Input Flag   │           │  Output Flag   │                │
│    └──────┬───────┘           └────────┬───────┘                │
│           │                            │                        │
│           └────────────┬───────────────┘                        │
│                        ▼                                        │
│                 ┌─────────────┐                                 │
│                 │   AC (16)   │                                 │
│                 │ Accumulator │                                 │
│                 └─────────────┘                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 1.2 I/O Registers and Flags

| Component | Size | Purpose |
|-----------|------|---------|
| **INPR** | 8 bits | Holds character from keyboard |
| **OUTR** | 8 bits | Holds character to display |
| **FGI** | 1 bit | Input Flag (1 = data ready) |
| **FGO** | 1 bit | Output Flag (1 = device ready) |
| **IEN** | 1 bit | Interrupt Enable (1 = enabled) |

---

## 1.3 How Flags Work

### Input Flag (FGI):
```
Keyboard pressed 'A':
  1. INPR ← 'A' (ASCII code)
  2. FGI ← 1 (signal: data is ready!)
  
CPU reads input:
  1. AC(0-7) ← INPR
  2. FGI ← 0 (clear flag after reading)
```

### Output Flag (FGO):
```
Display is idle:
  1. FGO ← 1 (signal: ready to receive!)
  
CPU sends output:
  1. OUTR ← AC(0-7)
  2. FGO ← 0 (display is now busy)
  
Display finished:
  1. FGO ← 1 (ready for next character)
```

---

## 1.4 I/O Instructions (6 Instructions)

| Instruction | Hex | Operation | Meaning |
|-------------|-----|-----------|---------|
| **INP** | F800 | AC(0-7) ← INPR, FGI ← 0 | Read from keyboard |
| **OUT** | F400 | OUTR ← AC(0-7), FGO ← 0 | Write to display |
| **SKI** | F200 | if(FGI=1) PC ← PC+1 | Skip if input ready |
| **SKO** | F100 | if(FGO=1) PC ← PC+1 | Skip if output ready |
| **ION** | F080 | IEN ← 1 | Enable interrupts |
| **IOF** | F040 | IEN ← 0 | Disable interrupts |

---

# 2. Input-Output Methods

## 2.1 Method 1: Programmed I/O (Polling)

CPU **continuously checks** the flag until device is ready.

### Input Program (Polling):
```assembly
WAIT_IN: SKI           ; Is input ready? (FGI = 1?)
         BUN WAIT_IN   ; No → keep waiting
         INP           ; Yes → read character to AC
```

### Output Program (Polling):
```assembly
WAIT_OUT: SKO          ; Is output ready? (FGO = 1?)
          BUN WAIT_OUT ; No → keep waiting
          OUT          ; Yes → send character to display
```

### Polling Flowchart:
```
        ┌─────────────────┐
        │     START       │
        └────────┬────────┘
                 │
        ┌────────▼────────┐
        │   Check Flag    │◄──────┐
        │   (SKI/SKO)     │       │
        └────────┬────────┘       │
                 │                │
        ┌────────▼────────┐       │
        │   Flag = 1?     │       │
        └────────┬────────┘       │
                 │                │
         ┌───────┴───────┐        │
         │ NO            │ YES    │
         │               ▼        │
         │      ┌───────────────┐ │
         │      │ Transfer Data │ │
         │      │  (INP/OUT)    │ │
         │      └───────┬───────┘ │
         │              │         │
         └──────────────┘         │
                 │                │
        ┌────────▼────────┐       │
        │     DONE        │       │
        └─────────────────┘
```

### Disadvantages of Polling:
- CPU **wastes time** waiting
- Cannot do other work while checking
- **Inefficient** for slow devices

---

## 2.2 Method 2: Interrupt-Driven I/O

Device **interrupts** CPU when it's ready. CPU can do other work meanwhile!

### Key Concept:
```
Instead of CPU asking: "Are you ready? Are you ready?..."
Device says: "Hey CPU! I'm ready now!"
```

### Interrupt Enable Flag (IEN):
- **IEN = 1**: Interrupts are enabled
- **IEN = 0**: Interrupts are disabled (ignored)

---

# 3. Interrupt Mechanism

## 3.1 When Does Interrupt Occur?

Interrupt happens when **ALL** conditions are true:
```
┌────────────────────────────────────────────────────────┐
│  INTERRUPT CONDITION:                                  │
│                                                        │
│     IEN = 1  (Interrupts enabled)                      │
│              AND                                       │
│     (FGI = 1  OR  FGO = 1)  (Device ready)             │
│                                                        │
│  Simplified: R = IEN × (FGI + FGO)                     │
│  If R = 1, interrupt occurs!                           │
└────────────────────────────────────────────────────────┘
```

---

## 3.2 Interrupt Cycle (What Happens During Interrupt)

When interrupt occurs (R = 1), this **Interrupt Cycle** executes:

```
┌────────────────────────────────────────────────────────────────┐
│                    INTERRUPT CYCLE                             │
│                                                                │
│  At the END of current instruction cycle:                      │
│                                                                │
│  Step 1: M[0] ← PC       (Save return address at location 0)   │
│  Step 2: PC ← 1          (Jump to address 1 = ISR start)       │
│  Step 3: IEN ← 0         (Disable further interrupts)          │
│  Step 4: R ← 0           (Clear interrupt flip-flop)           │
│                                                                │
│  Micro-operations:                                             │
│  RT₀: AR ← 0, TR ← PC                                          │
│  RT₁: M[AR] ← TR, PC ← 0                                       │
│  RT₂: PC ← PC + 1, IEN ← 0, R ← 0, SC ← 0                      │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

---

## 3.3 Memory Layout for Interrupts

```
┌─────────────────────────────────────────────────────────────┐
│  MEMORY MAP                                                 │
├─────────────────────────────────────────────────────────────┤
│  Address 0:  [Return Address]  ← PC saved here              │
│  Address 1:  [ISR starts here] ← PC jumps here              │
│  Address 2:  [ISR instruction 2]                            │
│     ...                                                     │
│  Address n:  [BUN I 0]         ← Return from ISR            │
│     ...                                                     │
│  Address 100: [Main Program]                                │
│  Address 101: [Main Program]                                │
│     ...                                                     │
└─────────────────────────────────────────────────────────────┘
```

---

## 3.4 Interrupt Service Routine (ISR) Structure

```assembly
; ISR starts at address 1
ORG 1
        BUN SRV         ; Jump to actual service routine

SRV,    STA SAC         ; Save AC (we'll use it)
        INP             ; Read input / or OUT for output
        OUT             ; Echo to display (optional)
        LDA SAC         ; Restore AC
        ION             ; Re-enable interrupts
        BUN I 0         ; Return (indirect jump through M[0])

SAC,    HEX 0           ; Storage for AC
```

### Key Points:
1. **Save AC** before using it
2. **Handle I/O** (INP or OUT)
3. **Restore AC** after
4. **ION** - Re-enable interrupts
5. **BUN I 0** - Return using saved address

---

## 3.5 Complete Interrupt Flow

```
        ┌─────────────────────────────────────────┐
        │         MAIN PROGRAM RUNNING            │
        │         at address 100                  │
        └────────────────┬────────────────────────┘
                         │
                         ▼
        ┌─────────────────────────────────────────┐
        │  Device ready! (FGI=1 or FGO=1)         │
        │  IEN = 1 (interrupts enabled)           │
        │  R ← 1 (interrupt flip-flop set)        │
        └────────────────┬────────────────────────┘
                         │
                         ▼
        ┌─────────────────────────────────────────┐
        │         INTERRUPT CYCLE                 │
        │  1. M[0] ← PC (save 100)                │
        │  2. PC ← 1                              │
        │  3. IEN ← 0                             │
        └────────────────┬────────────────────────┘
                         │
                         ▼
        ┌─────────────────────────────────────────┐
        │         ISR EXECUTES                    │
        │  (handles I/O at address 1+)            │
        └────────────────┬────────────────────────┘
                         │
                         ▼
        ┌─────────────────────────────────────────┐
        │         BUN I 0                         │
        │  PC ← M[0] = 100                        │
        │  (returns to main program)              │
        └────────────────┬────────────────────────┘
                         │
                         ▼
        ┌─────────────────────────────────────────┐
        │       MAIN PROGRAM RESUMES              │
        │       from address 100                  │
        └─────────────────────────────────────────┘
```

---

## 3.6 Comparison: Polling vs Interrupt

| Feature | Polling | Interrupt |
|---------|---------|-----------|
| CPU Utilization | Low (wasted in loop) | High (does other work) |
| Response Time | Slow | Fast |
| Complexity | Simple | More complex |
| Hardware | Less | More (interrupt logic) |
| Software | Simple loop | Needs ISR |
| Multiple Devices | Difficult | Easy with priorities |

---

# 4. Important Points for Exam

## 4.1 Must Remember:

1. **INPR** = 8 bits (ASCII character)
2. **FGI = 1** means keyboard has data
3. **FGO = 1** means display is ready
4. **Interrupt condition**: R = IEN × (FGI + FGO)
5. **Return address saved at M[0]**
6. **ISR starts at address 1**
7. **BUN I 0** returns from ISR

## 4.2 Common Exam Questions:

**Q: Why is IEN cleared during interrupt?**
A: To prevent nested interrupts while ISR is running.

**Q: Why use BUN I 0 to return?**
A: Because return address is stored at M[0]. Indirect addressing fetches address from M[0].

**Q: What happens if IEN = 0?**
A: All interrupts are ignored, even if flags are set.

---

## 4.3 Interrupt Cycle Timing (RTL)

```
R = 1 (Interrupt occurring):

RT₀: AR ← 0, TR ← PC
     (Prepare to save PC at address 0)

RT₁: M[AR] ← TR, PC ← 0  
     (Save PC to M[0], clear PC)

RT₂: PC ← PC + 1, IEN ← 0, R ← 0, SC ← 0
     (PC = 1, disable interrupts, clear R, reset counter)
```

---

## Quick Revision MCQs

1. **Where is return address stored?** → Location 0
2. **Where does ISR start?** → Location 1
3. **Which flag enables interrupts?** → IEN
4. **INP clears which flag?** → FGI
5. **OUT clears which flag?** → FGO
6. **How to return from ISR?** → BUN I 0
7. **Interrupt condition formula?** → R = IEN.(FGI + FGO)

---
