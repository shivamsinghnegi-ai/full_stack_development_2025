# Common Bus System & Instruction Cycle

---

# 1. Common Bus System

## 1.1 What is a Bus?

A **bus** is a set of **common wires** that connect multiple devices (registers, memory, ALU) inside a computer.

> **Simple Analogy:** Think of a bus like a highway. Instead of building separate roads between every house, we use one shared highway!

---

## 1.2 Why Use a Bus?

**Without Bus:**
```
Every register connected to every other register = Too many wires!
For n registers: n × (n-1) connections needed
```

**With Bus:**
```
All registers share ONE common path = Much simpler!
Only n connections to the bus needed
```

---

## 1.3 Basic Computer Bus Structure

```
┌────────────────────────────────────────────────────────────┐
│                    COMMON BUS (16 bits)                    │
├──────┬──────┬──────┬──────┬──────┬──────┬──────┬───────────┤
│  AR  │  PC  │  DR  │  AC  │  IR  │  TR  │ MEM  │  Input    │
│(12)  │(12)  │(16)  │(16)  │(16)  │(16)  │(16)  │   (16)    │
└──────┴──────┴──────┴──────┴──────┴──────┴──────┴───────────┘
   ↑                                                    ↑
   └───────────── Selection Lines (S2, S1, S0) ─────────┘
                     (3 bits = 8 combinations)
```

---

## 1.4 Bus Selection Table (Exam Important!)

| S2 | S1 | S0 | Selected Register |
|----|----|----|-------------------|
| 0  | 0  | 0  | None (no output)  |
| 0  | 0  | 1  | **AR** (Address Register) |
| 0  | 1  | 0  | **PC** (Program Counter) |
| 0  | 1  | 1  | **DR** (Data Register) |
| 1  | 0  | 0  | **AC** (Accumulator) |
| 1  | 0  | 1  | **IR** (Instruction Register) |
| 1  | 1  | 0  | **TR** (Temporary Register) |
| 1  | 1  | 1  | **Memory** |

---

## 1.5 Key Bus Rules

1. **Only ONE register** can put data on bus at a time
2. **Multiple registers** can READ from bus simultaneously
3. **Multiplexer (MUX)** selects which register sends data
4. **Load signals** determine which registers receive data

```
Example: Transfer DR to AC
Step 1: Select DR on bus (S2=0, S1=1, S0=1)
Step 2: Enable AC load signal
Result: AC ← DR
```

---

# 2. Instruction Cycle

## 2.1 What is Instruction Cycle?

The **instruction cycle** is the complete process of fetching, decoding, and executing ONE instruction.

```
┌───────────────────────────────────────────────────────────┐
│              INSTRUCTION CYCLE                            │
│                                                           │
│  ┌─────────┐    ┌─────────┐    ┌───────────┐              │
│  │  FETCH  │ → │ DECODE  │ → │  EXECUTE  │ → (repeat)     │
│  └─────────┘    └─────────┘    └───────────┘              │
│       ↑                              │                    │
│       └──────────────────────────────┘                    │
│                                                           │
└───────────────────────────────────────────────────────────┘
```

---

## 2.2 Timing Signals (T₀, T₁, T₂, ...)

Each step in instruction cycle is controlled by **timing signals** generated by a **sequence counter (SC)**.

```
Clock pulses → Sequence Counter → T₀, T₁, T₂, T₃, ...
```

- **T₀, T₁, T₂**: Fetch phase
- **T₃**: Indirect addressing (if I=1)
- **T₄, T₅, ...**: Execute phase

---

## 2.3 Fetch Phase (T₀, T₁, T₂) - MEMORIZE THIS!

```
┌────────────────────────────────────────────────────────────────┐
│                    FETCH PHASE                                 │
├─────────┬──────────────────────────────────────────────────────┤
│   T₀    │  AR ← PC                                             │
│         │  (Put next instruction address in AR)                │
├─────────┼──────────────────────────────────────────────────────┤
│   T₁    │  IR ← M[AR],  PC ← PC + 1                            │
│         │  (Fetch instruction to IR, increment PC)             │
├─────────┼──────────────────────────────────────────────────────┤
│   T₂    │  D₀...D₇ ← Decode IR(12-14),  AR ← IR(0-11),  I ← IR(15)│
│         │  (Decode opcode, get address, get I bit)             │
└─────────┴──────────────────────────────────────────────────────┘
```

**In RTL (Register Transfer Language):**
```
T₀: AR ← PC
T₁: IR ← M[AR], PC ← PC + 1  
T₂: D₀...D₇ ← Decode IR(12-14), AR ← IR(0-11), I ← IR(15)
```

---

## 2.4 Indirect Phase (T₃, only if I=1)

If indirect addressing mode (I=1), we need **one extra step** to get effective address:

```
┌─────────┬──────────────────────────────────────────────────────┐
│   T₃    │  AR ← M[AR]                                          │
│         │  (Replace address with contents of memory[address])  │
└─────────┴──────────────────────────────────────────────────────┘
```

**In RTL:**
```
D₇'IT₃: AR ← M[AR]
(Only if opcode ≠ 111 AND I=1 AND T₃)
```

---

## 2.5 Execute Phase (T₃ or T₄ onwards)

Different operations for each instruction type:

### For Memory Reference Instructions:
```
Direct (I=0):  Execute starts at T₃
Indirect (I=1): Execute starts at T₄
```

### For Register Reference Instructions:
```
Execute at T₃ (no memory access needed)
D₇I'T₃: Execute register operation
```

### For I/O Instructions:
```
Execute at T₃
D₇IT₃: Execute I/O operation
```

---

## 2.6 Complete Instruction Cycle Flowchart

```
                    START
                      │
                      ▼
            ┌─────────────────┐
     T₀:    │    AR ← PC      │
            └────────┬────────┘
                     │
                     ▼
            ┌─────────────────────────┐
     T₁:    │ IR ← M[AR], PC ← PC+1   │
            └────────┬────────────────┘
                     │
                     ▼
            ┌─────────────────────────────────┐
     T₂:    │ Decode opcode, AR ← IR(0-11)    │
            │ I ← IR(15)                      │
            └────────┬────────────────────────┘
                     │
                     ▼
               ┌───────────┐
               │Opcode=111?│
               └─────┬─────┘
                     │
          ┌──────────┴──────────┐
          │ YES                 │ NO (Memory Ref)
          ▼                     ▼
    ┌───────────┐         ┌───────────┐
    │   I = 1?  │         │   I = 1?  │
    └─────┬─────┘         └─────┬─────┘
          │                     │
    ┌─────┴─────┐         ┌─────┴─────┐
    │YES   │NO  │         │YES   │NO  │
    ▼      ▼    ▼         ▼      ▼
   I/O   Reg   T₃:    T₄:Execute
   Inst  Ref   AR←M[AR] (Direct)
               then execute
```

---

## 2.7 Example: LDA 500 (Load Accumulator)

### Case 1: Direct Addressing (I=0)
```
T₀: AR ← PC           (AR gets address of instruction)
T₁: IR ← M[AR], PC++  (Fetch instruction: LDA 500)
T₂: AR ← 500, I ← 0   (Decode: address=500, direct mode)
T₃: DR ← M[500]       (Fetch operand from memory)
T₄: AC ← DR, SC ← 0   (Load to AC, reset counter)
```

### Case 2: Indirect Addressing (I=1)
```
Assume M[500] = 800, M[800] = 1234

T₀: AR ← PC           (AR gets address of instruction)
T₁: IR ← M[AR], PC++  (Fetch instruction: LDA 500)
T₂: AR ← 500, I ← 1   (Decode: address=500, indirect mode)
T₃: AR ← M[500] = 800 (Get effective address)
T₄: DR ← M[800]=1234  (Fetch operand)
T₅: AC ← DR, SC ← 0   (Load 1234 to AC)
```

---

## 2.8 Key Points for Exam

| Phase | Timing | What Happens |
|-------|--------|--------------|
| **Fetch** | T₀,T₁,T₂ | Get instruction from memory |
| **Indirect** | T₃ (if I=1) | Get effective address |
| **Execute** | T₃/T₄+ | Perform the operation |

**Remember:**
- Fetch phase is **SAME for ALL instructions**
- Only Memory-Reference instructions with I=1 need indirect phase
- Register/I/O instructions execute at T₃
- SC ← 0 resets counter for next instruction

---

## Quick Revision MCQ Points

1. **How many timing signals in fetch?** → 3 (T₀, T₁, T₂)
2. **What does T₀ do?** → AR ← PC
3. **What does T₁ do?** → Fetch instruction, increment PC
4. **When is indirect phase needed?** → When I=1 in memory-reference instruction
5. **What resets the sequence counter?** → SC ← 0 at end of execute phase

---
