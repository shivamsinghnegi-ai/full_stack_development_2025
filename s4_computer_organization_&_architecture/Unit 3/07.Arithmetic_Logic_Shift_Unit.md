# Arithmetic Logic Shift Unit (ALU)

### What is an ALU?
The **Arithmetic Logic Shift Unit** is the core functional unit of the CPU that combines all three types of micro-operations — **arithmetic, logic, and shift** — into a single hardware unit.

>  **ALU doesn't store data — it only **processes** it. Data comes from registers, gets processed, and the result goes back to a register.**

---

### Building Blocks of an ALU

An ALU is built by combining:

| Component | Handles |
|-----------|---------|
| Arithmetic Circuit | Add, Subtract, Increment, Decrement |
| Logic Circuit | AND, OR, XOR, NOT |
| Shift Circuit | Logical, Arithmetic, Circular shifts |
| MUX (Selector) | Chooses which operation result goes to output |

---

### ALU Block Diagram

```
         A (n-bit)       B (n-bit)
              |               |
     _________|_______________|_________
    |                                   |
    |   ┌─────────────────────┐         |
    |   │   Arithmetic Unit   │         |
    |   │  (Adder-Subtractor) │         |
    |   └──────────┬──────────┘         |
    |              |                    |
    |   ┌──────────┴──────────┐         |
    |   │     Logic Unit      │         |
    |   │  (AND/OR/XOR/NOT)   │         |
    |   └──────────┬──────────┘         |
    |              |                    |
    |   ┌──────────┴──────────┐         |
    |   │     Shift Unit      │         |
    |   │ (shl/shr/cil/cir)   │         |
    |   └──────────┬──────────┘         |
    |______________|____________________|
                   |
              ┌────┴────┐
              │   MUX   │ ← Selection Inputs (S1, S0)
              └────┬────┘
                   |
               Output F (n-bit)
```

---

### Operation Selection Table

The ALU uses selection lines **S3, S2, S1, S0** and **Cin** to select the operation:

| S3 | S2 | S1 | S0 | Cin | Operation | Description |
|----|----|----|----|-----|-----------|-------------|
| 0  | 0  | 0  | 0  | 0   | F = A     | Transfer A |
| 0  | 0  | 0  | 0  | 1   | F = A + 1 | Increment A |
| 0  | 0  | 0  | 1  | 0   | F = A + B | Addition |
| 0  | 0  | 0  | 1  | 1   | F = A+B+1 | Add with carry |
| 0  | 0  | 1  | 0  | 0   | F = A+B̄   | Sub with borrow |
| 0  | 0  | 1  | 0  | 1   | F = A-B   | Subtraction |
| 0  | 0  | 1  | 1  | 0   | F = A-1   | Decrement A |
| 0  | 1  | 0  | 0  | X   | F = A ∧ B | AND |
| 0  | 1  | 0  | 1  | X   | F = A ∨ B | OR |
| 0  | 1  | 1  | 0  | X   | F = A ⊕ B | XOR |
| 0  | 1  | 1  | 1  | X   | F = Ā     | Complement A |
| 1  | 0  | 0  | 0  | X   | F = shr A | Logical shift right |
| 1  | 0  | 0  | 1  | X   | F = shl A | Logical shift left |
| 1  | 0  | 1  | 0  | X   | F = cir A | Circular shift right |
| 1  | 0  | 1  | 1  | X   | F = cil A | Circular shift left |

>  **The MSB of selection lines tells you the **type** — `0x` = Arithmetic, `01` = Logic, `10` = Shift. This pattern helps you memorize the table quickly.**

---

### Status Flags in ALU

After every ALU operation, the following **flag bits** are updated:

| Flag | Name | Set when... |
|------|------|-------------|
| **C** | Carry | Carry out from MSB (overflow in unsigned) |
| **Z** | Zero | Result = 0 |
| **S** | Sign | MSB of result = 1 (negative in signed) |
| **V** | Overflow | Signed arithmetic overflow occurs |

---

### How ALU Connects to the CPU

```
     Register File
      ↙         ↘
   Operand A   Operand B
        ↓           ↓
        └────[ALU]──┘
               ↓
           Result F
               ↓
        Back to Register / Memory
               ↓
           Flag Register (C, Z, S, V)
```

>  **ALU takes inputs from **registers**, not directly from memory. Data must be loaded into registers before the ALU can operate on it.**

---
