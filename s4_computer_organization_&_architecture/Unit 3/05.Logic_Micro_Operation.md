# Logic Micro-Operations
---

## 1. What are Logic Micro-Operations?

Logic micro-operations perform **bit-wise Boolean operations** on the data stored in registers.

**Key Point:** They treat **each bit independently** — they do NOT care about the numeric value of the register. Every bit is processed separately using Boolean logic.

>  **Difference from Arithmetic:**
> - Arithmetic operations → treat register as a **number** (carry propagates)
> - Logic operations → treat register as **individual bits** (no carry, each bit independent)

---

## 2. List of Logic Micro-Operations

| Operation | Symbolic Notation | Description |
|-----------|-------------------|-------------|
| AND | `R3 ← R1 ∧ R2` | Bit-wise AND of R1 and R2 |
| OR | `R3 ← R1 ∨ R2` | Bit-wise OR of R1 and R2 |
| XOR | `R3 ← R1 ⊕ R2` | Bit-wise XOR of R1 and R2 |
| NOT (Complement) | `R2 ← R̄1` | Bit-wise complement of R1 |
| Clear | `R ← 0000` | All bits forced to 0 |
| Set | `R ← 1111` | All bits forced to 1 |

---

## 3. Basic Logic Operations — Explained

### 3.1 AND Operation ( ∧ )

**Rule:** Both bits must be 1 — only then result is 1. Otherwise 0.

**Truth Table (1-bit):**

| A | B | A ∧ B |
|---|---|-------|
| 0 | 0 |   0   |
| 0 | 1 |   0   |
| 1 | 0 |   0   |
| 1 | 1 |   1   |

**RTL Notation:** `R3 ← R1 ∧ R2`

**Worked Example (8-bit):**
```
R1 = 1 0 1 1 0 1 0 0
R2 = 1 1 0 1 1 0 0 1
     ─────────────────
R3 = 1 0 0 1 0 0 0 0   ← result (AND bit by bit)
```
Verify bit by bit:
```
Bit 7: 1∧1 = 1 ✓        Bit 3: 1∧1 = 1 ✓
Bit 6: 0∧1 = 0 ✓        Bit 2: 0∧0 = 0 ✓
Bit 5: 1∧0 = 0 ✓        Bit 1: 0∧0 = 0 ✓
Bit 4: 1∧1 = 1 ✓        Bit 0: 0∧1 = 0 ✓
```

**Key Property:** AND with 0 → always 0. AND with 1 → unchanged.
```
X ∧ 0 = 0   (force to 0)
X ∧ 1 = X   (no change)
```

**Use:** To **clear specific bits** (force them to 0) — called Masking.

---

### 3.2 OR Operation ( ∨ )

**Rule:** If ANY one bit is 1 — result is 1. Both must be 0 for result to be 0.

**Truth Table (1-bit):**

| A | B | A ∨ B |
|---|---|-------|
| 0 | 0 |   0   |
| 0 | 1 |   1   |
| 1 | 0 |   1   |
| 1 | 1 |   1   |

**RTL Notation:** `R3 ← R1 ∨ R2`

**Worked Example (8-bit):**
```
R1 = 1 0 1 1 0 1 0 0
R2 = 1 1 0 1 1 0 0 1
     ─────────────────
R3 = 1 1 1 1 1 1 0 1   ← result (OR bit by bit)
```

**Key Property:** OR with 1 → always 1. OR with 0 → unchanged.
```
X ∨ 1 = 1   (force to 1)
X ∨ 0 = X   (no change)
```

**Use:** To **set specific bits** (force them to 1).

---

### 3.3 XOR Operation ( ⊕ ) — Exclusive OR

**Rule:** If both bits are DIFFERENT → result is 1. If both are SAME → result is 0.

**Truth Table (1-bit):**

| A | B | A ⊕ B |
|---|---|-------|
| 0 | 0 |   0   |
| 0 | 1 |   1   |
| 1 | 0 |   1   |
| 1 | 1 |   0   |

**RTL Notation:** `R3 ← R1 ⊕ R2`

**Worked Example (8-bit):**
```
R1 = 1 0 1 1 0 1 0 0
R2 = 1 1 0 1 1 0 0 1
     ─────────────────
R3 = 0 1 1 0 1 1 0 1   ← result (XOR bit by bit)
```

**Key Properties:**
```
X ⊕ 0 = X    (no change)
X ⊕ 1 = X̄   (complement — flip the bit)
X ⊕ X = 0    (XOR with itself = always 0)
```

**Use:** To **flip (complement) specific bits**, and to **clear a register** (XOR with itself).

---

### 3.4 NOT / Complement Operation ( ¯ )

**Rule:** Every bit is flipped — 0 becomes 1, 1 becomes 0.

**Truth Table (1-bit):**

| A | Ā |
|---|---|
| 0 | 1 |
| 1 | 0 |

**RTL Notation:** `R2 ← R̄1`

**Worked Example (8-bit):**
```
R1     = 1 0 1 1 0 1 0 0
NOT R1 = 0 1 0 0 1 0 1 1   ← every bit flipped
```

**Key Property:**
```
NOT(NOT A) = A   (double complement = original)
```

---

### 3.5 Clear Operation

**Rule:** All bits of register become 0, regardless of what they were.

**RTL Notation:** `R ← 0000`

```
R = 1 0 1 1 0 1 1 0
After Clear:
R = 0 0 0 0 0 0 0 0
```

---

### 3.6 Set Operation

**Rule:** All bits of register become 1, regardless of what they were.

**RTL Notation:** `R ← 1111`

```
R = 1 0 1 1 0 1 1 0
After Set:
R = 1 1 1 1 1 1 1 1
```

---

## 5. What is a MASK?

A **mask** is a specially crafted binary pattern used to **select which bits** to operate on.

- Mask bit = **1** → that bit position is **targeted** (operation happens)
- Mask bit = **0** → that bit position is **ignored** (no change / protected)

The operation performed depends on which logic gate we use with the mask:

| Goal | Operation | Mask bit where you want action |
|------|-----------|-------------------------------|
| Clear specific bits | AND | Put **0** at those positions |
| Set specific bits | OR | Put **1** at those positions |
| Flip specific bits | XOR | Put **1** at those positions |

---

## 6. Applications of Logic Micro-Operations

### 6.1 Selective Complement (using XOR)

**Goal:** Flip (complement) only specific bits of a register. Leave others unchanged.

**Formula:** `R ← R ⊕ Mask`

**Rule:**
- Where Mask = 1 → bit in R is **flipped**
- Where Mask = 0 → bit in R is **unchanged**

**Example:** Complement only the lower 4 bits of R
```
R    = 1 0 1 0  0 1 1 0
Mask = 0 0 0 0  1 1 1 1
       ─────────────────
R⊕M  = 1 0 1 0  1 0 0 1   ← upper 4 bits same, lower 4 bits flipped
```
Verify:
```
Upper 4 bits: 1⊕0=1, 0⊕0=0, 1⊕0=1, 0⊕0=0  → unchanged ✓
Lower 4 bits: 0⊕1=1, 1⊕1=0, 1⊕1=0, 0⊕1=1  → flipped ✓
```

---

### 6.2 Selective Set (using OR)

**Goal:** Force specific bits of a register to 1. Leave others unchanged.

**Formula:** `R ← R ∨ Mask`

**Rule:**
- Where Mask = 1 → bit in R becomes **1** (forced)
- Where Mask = 0 → bit in R is **unchanged**

**Example:** Set (force to 1) only the lower 4 bits of R
```
R    = 1 0 1 1  0 0 0 0
Mask = 0 0 0 0  1 1 1 1
       ─────────────────
R∨M  = 1 0 1 1  1 1 1 1   ← upper 4 bits same, lower 4 bits all become 1
```
Verify:
```
Upper 4 bits: 1∨0=1, 0∨0=0, 1∨0=1, 1∨0=1  → unchanged ✓
Lower 4 bits: 0∨1=1, 0∨1=1, 0∨1=1, 0∨1=1  → all set to 1 ✓
```

---

### 6.3 Selective Clear (using AND)

**Goal:** Force specific bits of a register to 0. Leave others unchanged.

**Formula:** `R ← R ∧ Mask`

**Rule:**
- Where Mask = 0 → bit in R becomes **0** (forced)
- Where Mask = 1 → bit in R is **unchanged**

**Example:** Clear (force to 0) only the lower 4 bits of R
```
R    = 1 0 1 1  1 1 1 1
Mask = 1 1 1 1  0 0 0 0
       ─────────────────
R∧M  = 1 0 1 1  0 0 0 0   ← upper 4 bits same, lower 4 bits all become 0
```
Verify:
```
Upper 4 bits: 1∧1=1, 0∧1=0, 1∧1=1, 1∧1=1  → unchanged ✓
Lower 4 bits: 1∧0=0, 1∧0=0, 1∧0=0, 1∧0=0  → all cleared to 0 ✓
```

> **Common Confusion — AND vs XOR mask:**
> - **AND mask:** Put **0** where you want to clear → that position becomes 0
> - **XOR mask:** Put **1** where you want to flip → that position gets complemented
> - They look similar but work differently — read the mask rule carefully!

---

### 6.4 Mask Operation (using AND)

**Goal:** Keep only specific bits of a register, clear everything else.

**Formula:** `R ← R ∧ Mask`

This is the same as Selective Clear — used to **isolate or extract** specific bits.

**Example:** Extract only the lower 4 bits (ignore upper 4 bits)
```
R    = 1 1 0 1  1 0 1 1
Mask = 0 0 0 0  1 1 1 1
       ─────────────────
R∧M  = 0 0 0 0  1 0 1 1   ← upper 4 bits cleared, lower 4 bits preserved
```

**Real use case:** Suppose a register holds `11001011`. You only want the lower nibble (lower 4 bits = `1011`). AND with `00001111` extracts it.

---

### 6.5 Insert Operation (using AND then OR)

**Goal:** Insert (replace) a specific bit pattern into certain positions of a register without disturbing the other bits.

**Two steps:**

**Step 1 — Clear the target bits using AND (Mask)**
```
R ← R ∧ Mask1      (clear positions where new data will go)
```

**Step 2 — Insert new pattern using OR**
```
R ← R ∨ NewPattern  (insert new data into cleared positions)
```

**Example:** Replace lower 4 bits of R with `1010`
```
R         = 1 1 0 1  0 1 1 0   (original)
Mask1     = 1 1 1 1  0 0 0 0   (to clear lower 4)
NewPattern= 0 0 0 0  1 0 1 0   (new bits to insert)

Step 1 — Clear:
  R ∧ Mask1 = 1 1 0 1  0 0 0 0

Step 2 — Insert:
  1 1 0 1  0 0 0 0
∨ 0 0 0 0  1 0 1 0
  ─────────────────
  1 1 0 1  1 0 1 0   ← upper 4 bits unchanged, lower 4 replaced with 1010
```

---

### 6.6 Clear Register (using XOR with itself)

**Goal:** Set all bits of a register to 0 — the fastest way.

**Formula:** `R ← R ⊕ R`

**Why does this work?**
```
XOR rule: Same bits → 0

R = 1 0 1 1 0 1 1 0
R = 1 0 1 1 0 1 1 0
    ─────────────────
    0 0 0 0 0 0 0 0   ← every bit XOR'd with itself = 0
```

**Why use this instead of just writing 0?**

>  In assembly language, `XOR R, R` is **faster and takes fewer bytes** than `MOV R, 0`. So CPUs and compilers prefer this trick to efficiently clear a register.

---

## 7. Logic Circuit — 4-Function Circuit

A single circuit that performs all 4 basic logic operations using **selection inputs S1 and S0**.

### Function Table

| S1 | S0 | Operation | Output F |
|----|----|-----------|----------|
| 0  | 0  | AND | F = A ∧ B |
| 0  | 1  | OR  | F = A ∨ B |
| 1  | 0  | XOR | F = A ⊕ B |
| 1  | 1  | NOT | F = Ā |

>  **Important:** In NOT operation — only **A** is used. **B is ignored.**
> This is a common exam trap!

### Circuit Diagram

```
                        S1   S0
                         |    |
                         ↓    ↓
              ┌──────────────────────────────┐
              │      4-FUNCTION MUX          │
              │                              │
   A, B ──→  [AND]  ──────────────────────→  │
   A, B ──→  [OR]   ──────────────────────→  │──→ Output F
   A, B ──→  [XOR]  ──────────────────────→  │
   A    ──→  [NOT]  ──────────────────────→  │
              │                              │
              └──────────────────────────────┘
```

**How it works:**
- All 4 operations are computed simultaneously by their respective gates
- The MUX (Multiplexer) selects which result to pass to the output based on S1 and S0
- S1=0, S0=0 → MUX selects AND result
- S1=0, S0=1 → MUX selects OR result
- S1=1, S0=0 → MUX selects XOR result
- S1=1, S0=1 → MUX selects NOT result

---

## 8. Worked Examples — All Operations

### Example 1: AND
```
R1 = 1 1 0 0 1 0 1 0
R2 = 1 0 1 0 1 1 0 0
     ─────────────────
R3 = 1 0 0 0 1 0 0 0
```

### Example 2: OR
```
R1 = 1 1 0 0 1 0 1 0
R2 = 1 0 1 0 1 1 0 0
     ─────────────────
R3 = 1 1 1 0 1 1 1 0
```

### Example 3: XOR
```
R1 = 1 1 0 0 1 0 1 0
R2 = 1 0 1 0 1 1 0 0
     ─────────────────
R3 = 0 1 1 0 0 1 1 0
```

### Example 4: NOT
```
R1     = 1 1 0 0 1 0 1 0
NOT R1 = 0 0 1 1 0 1 0 1
```

### Example 5: Selective Complement
```
Complement bits 4–7 (upper nibble) of R = 1010 0110

R    = 1 0 1 0  0 1 1 0
Mask = 1 1 1 1  0 0 0 0
       ─────────────────
R⊕M  = 0 1 0 1  0 1 1 0   ← upper 4 bits flipped, lower unchanged
```

### Example 6: Selective Set
```
Set bits 0–3 (lower nibble) of R = 1010 0000

R    = 1 0 1 0  0 0 0 0
Mask = 0 0 0 0  1 1 1 1
       ─────────────────
R∨M  = 1 0 1 0  1 1 1 1   ← lower 4 bits all set to 1
```

### Example 7: Selective Clear
```
Clear bits 4–7 (upper nibble) of R = 1111 1010

R    = 1 1 1 1  1 0 1 0
Mask = 0 0 0 0  1 1 1 1
       ─────────────────
R∧M  = 0 0 0 0  1 0 1 0   ← upper 4 bits cleared to 0
```

### Example 8: Clear Register using XOR
```
R     = 1 0 1 1 0 1 1 0
R ⊕ R = 0 0 0 0 0 0 0 0   ← all bits become 0
```

---

## 9. Expected Exam Questions

1. **What are logic micro-operations? List all with RTL notation.**
2. **Explain AND, OR, XOR, and NOT operations with truth tables and 8-bit examples.**
3. **What is a mask? How is it used in logic micro-operations?**
4. **Explain selective complement, selective set, and selective clear with examples.**
5. **What is the difference between selective set and selective clear?**
6. **How is XOR used to clear a register? Why is it preferred over direct assignment?**
7. **Explain the Insert operation with a step-by-step example.**
8. **Draw and explain the 4-function logic circuit with its function table.**
9. **Why does NOT in the 4-function circuit use only A and not B?**
10. **Give the key property: what does AND with 0, OR with 1, and XOR with 1 do?**

---
