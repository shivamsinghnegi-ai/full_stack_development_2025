# Arithmetic Micro-Operations
---

## 1. What is a Micro-Operation?

A **micro-operation** is the **smallest, elementary operation** performed on data stored in registers. It is executed in **one clock cycle** and is controlled by the control unit.

There are 4 types of micro-operations:
1. **Register Transfer** — move data between registers
2. **Arithmetic** — mathematical operations on binary data
3. **Logic** — bitwise Boolean operations
4. **Shift** — shifting bits left or right

>  Arithmetic micro-operations perform **basic mathematical operations** on numeric data stored in registers.

---

## 2. List of Arithmetic Micro-Operations

| Operation | Symbolic Notation | Description |
|-----------|------------------|-------------|
| Addition | `R3 ← R1 + R2` | Add contents of R1 and R2 |
| Subtraction | `R3 ← R1 - R2` | Subtract R2 from R1 |
| Increment | `R1 ← R1 + 1` | Add 1 to R1 |
| Decrement | `R1 ← R1 - 1` | Subtract 1 from R1 |
| Add with Carry | `R3 ← R1 + R2 + Cin` | Add R1, R2, and carry bit |
| Subtract with Borrow | `R3 ← R1 - R2 - Bin` | Subtract R2 and borrow from R1 |
| Negate | `R2 ← R̄2 + 1` | 2's complement (make negative) |
| Negate and Add | `R3 ← R1 + R̄2 + 1` | R1 + 2's complement of R2 = R1 − R2 |

---

## 3. Hardware Building Blocks

### 3.1 Half Adder (HA)

A Half Adder adds **two 1-bit numbers** (A and B) and produces a **Sum** and a **Carry**.

**Inputs:** A, B
**Outputs:** Sum (S), Carry (C)

#### Truth Table

| A | B | Sum (S) | Carry (C) |
|---|---|---------|-----------|
| 0 | 0 |    0    |     0     |
| 0 | 1 |    1    |     0     |
| 1 | 0 |    1    |     0     |
| 1 | 1 |    0    |     1     |

#### Boolean Expressions
```
Sum   = A ⊕ B        (XOR)
Carry = A ∧ B        (AND)
```

#### Circuit Diagram

```
         ┌─────────────────────────────┐
         │         HALF ADDER          │
         │                             │
    A ───┼────[XOR Gate]───────────────┼──→ Sum (S)
         │          ↑                  │
    B ───┼──────────┴──[AND Gate]──────┼──→ Carry (C)
         │                             │
         └─────────────────────────────┘
```

**Detailed gate-level diagram:**
```
    A ──┬────────────────[XOR]──── S (Sum)
        │                  ↑
    B ──┴──────────────────┤
        │                  │
        └──────[AND]────────────── C (Carry)
```

#### Worked Example: 1 + 1

```
A = 1, B = 1

Sum   = 1 ⊕ 1 = 0
Carry = 1 ∧ 1 = 1

Result: Sum=0, Carry=1  →  Binary "10" = Decimal 2 ✓
```

#### Limitation of Half Adder
Half adder **cannot accept a carry from a previous stage**. So it can only be used for the **LSB (Least Significant Bit)** position. For all other bit positions, we need a Full Adder.

---

### 3.2 Full Adder (FA)

A Full Adder adds **three 1-bit numbers** — A, B, and **Cin (Carry In)** — and produces a **Sum** and **Cout (Carry Out)**.

**Inputs:** A, B, Cin
**Outputs:** Sum (S), Cout

#### Truth Table

| A | B | Cin | Sum (S) | Cout |
|---|---|-----|---------|------|
| 0 | 0 |  0  |    0    |  0   |
| 0 | 0 |  1  |    1    |  0   |
| 0 | 1 |  0  |    1    |  0   |
| 0 | 1 |  1  |    0    |  1   |
| 1 | 0 |  0  |    1    |  0   |
| 1 | 0 |  1  |    0    |  1   |
| 1 | 1 |  0  |    0    |  1   |
| 1 | 1 |  1  |    1    |  1   |

> **Pattern to remember:**
> - **Sum = 1** when **odd number of inputs are 1** (1 or 3 inputs are 1)
> - **Cout = 1** when **2 or more inputs are 1**

#### Boolean Expressions
```
Sum  = A ⊕ B ⊕ Cin
Cout = (A ∧ B) ∨ (B ∧ Cin) ∨ (A ∧ Cin)
```

#### Circuit Diagram (using 2 Half Adders + 1 OR Gate)

```
                ┌────────────────────────────────────────────┐
                │              FULL ADDER                    │
                │                                            │
                │    ┌──────────┐    ┌──────────┐            │
    A   ────────┼───→│          │    │          │            │
                │    │  Half    │S1─→│  Half    │S ──────────┼──→ Sum
    B   ────────┼───→│ Adder 1  │    │ Adder 2  │            │
                │    │          │C1─┐│          │            │
                │    └──────────┘   ││          │C2─┐        │
    Cin ────────┼───────────────────┘│          │   │        │
                │                    └──────────┘   │        │
                │                                   ↓        │
                │                               [OR Gate]────┼──→ Cout
                │                                            │
                └────────────────────────────────────────────┘
```

**Gate-level detailed diagram:**
```
    A ────┬──────────────[XOR1]─────────┬──[XOR2]──── Sum (S)
          │                  ↑          │      ↑
    B ────┴──────────────────┤          │      │
          │                  │          │    Cin
          │              [AND1]─────┐   │
          │                         │   │
          │                    [AND2]───┘
          │                         │
    Cin ──┴─────────────────────────┤
                                    ↓
                                 [OR] ──────────── Cout
```

#### Worked Example 1: A=1, B=1, Cin=1

```
Step 1: Sum = A ⊕ B ⊕ Cin
            = 1 ⊕ 1 ⊕ 1
            = 0 ⊕ 1            [since 1⊕1=0, then 0⊕1=1]
            = 1

Step 2: Cout = (A∧B) ∨ (B∧Cin) ∨ (A∧Cin)
             = (1∧1) ∨ (1∧1) ∨ (1∧1)
             = 1 ∨ 1 ∨ 1
             = 1

Result: Sum=1, Cout=1  →  Binary "11" = Decimal 3
Verify: 1 + 1 + 1 = 3 ✓
```

#### Worked Example 2: A=1, B=0, Cin=1

```
Step 1: Sum = 1 ⊕ 0 ⊕ 1
            = 1 ⊕ 1
            = 0

Step 2: Cout = (1∧0) ∨ (0∧1) ∨ (1∧1)
             = 0 ∨ 0 ∨ 1
             = 1

Result: Sum=0, Cout=1  →  Binary "10" = Decimal 2
Verify: 1 + 0 + 1 = 2 ✓
```

#### Worked Example 3: A=0, B=1, Cin=0

```
Step 1: Sum = 0 ⊕ 1 ⊕ 0 = 1

Step 2: Cout = (0∧1) ∨ (1∧0) ∨ (0∧0)
             = 0 ∨ 0 ∨ 0
             = 0

Result: Sum=1, Cout=0  →  Binary "01" = Decimal 1
Verify: 0 + 1 + 0 = 1 ✓
```

---

### 3.3 Ripple Carry Adder (4-bit)

A **4-bit Ripple Carry Adder** chains **4 Full Adders** together to add two **4-bit numbers**.

- The **Cin of FA#0** is tied to **0** (no initial carry)
- The **Cout of each FA** is connected to the **Cin of the next FA**
- This carry "rippling" from one FA to the next gives it the name **Ripple Carry Adder**

#### Circuit Diagram

```
   A3  B3       A2  B2       A1  B1       A0  B0
    |   |         |   |        |   |        |   |
    ↓   ↓         ↓   ↓        ↓   ↓        ↓   ↓
  ┌───────┐    ┌───────┐    ┌───────┐    ┌───────┐
  │       │    │       │    │       │    │       │
  │  FA   │    │  FA   │    │  FA   │    │  FA   │←── Cin = 0
  │  #3   │    │  #2   │    │  #1   │    │  #0   │
  └───┬───┘    └───┬───┘    └───┬───┘    └───┬───┘
      |    C3→     |    C2→     |    C1→     |
      S3           S2           S1           S0

  Cout ←─── C3 (final carry out / overflow indicator)

  Result = Cout | S3 S2 S1 S0
```

**Carry propagation (Ripple effect):**
```
Cin=0 ──→ FA#0 ──C1──→ FA#1 ──C2──→ FA#2 ──C3──→ FA#3 ──Cout
```

#### Worked Example: 6 + 5 (in 4-bit binary)

```
Decimal:    6      +     5
Binary:   0110     +   0101
           A3A2A1A0    B3B2B1B0
           0  1  1  0    0  1  0  1
```

**Solving FA by FA (right to left):**

```
┌─────────────────────────────────────────────────────┐
│ FA#0:  A0=0, B0=1, Cin=0                            │
│        Sum0  = 0 ⊕ 1 ⊕ 0 = 1                        │
│        Cout0 = (0∧1)∨(1∧0)∨(0∧0) = 0                │
│        → S0 = 1,  C1 = 0                            │
└─────────────────────────────────────────────────────┘
                         ↓ C1=0
┌─────────────────────────────────────────────────────┐
│ FA#1:  A1=1, B1=0, Cin=0 (C1 from FA#0)             │
│        Sum1  = 1 ⊕ 0 ⊕ 0 = 1                        │
│        Cout1 = (1∧0)∨(0∧0)∨(1∧0) = 0                │
│        → S1 = 1,  C2 = 0                            │
└─────────────────────────────────────────────────────┘
                         ↓ C2=0
┌─────────────────────────────────────────────────────┐
│ FA#2:  A2=1, B2=1, Cin=0 (C2 from FA#1)             │
│        Sum2  = 1 ⊕ 1 ⊕ 0 = 0                        │
│        Cout2 = (1∧1)∨(1∧0)∨(1∧0) = 1  ← carry!      │
│        → S2 = 0,  C3 = 1                            │
└─────────────────────────────────────────────────────┘
                         ↓ C3=1
┌─────────────────────────────────────────────────────┐
│ FA#3:  A3=0, B3=0, Cin=1 (C3 from FA#2)             │
│        Sum3  = 0 ⊕ 0 ⊕ 1 = 1                        │
│        Cout3 = (0∧0)∨(0∧1)∨(0∧1) = 0                │
│        → S3 = 1,  Cout = 0                          │
└─────────────────────────────────────────────────────┘
```

**Final Result:**
```
Cout=0 | S3=1 | S2=0 | S1=1 | S0=1

Result = 0 1 0 1 1 = 01011 (binary) = 11 (decimal)

Verify: 6 + 5 = 11 ✓
```

**Ripple effect visualized:**
```
Stage:  FA#0     FA#1     FA#2     FA#3
Carry:  0 ──→   0 ──→   0 ──→   1 ──→   0
                              (carry generated here — rippled to FA#3)
```

---

### 3.4 Binary Adder-Subtractor

A single circuit that performs **both addition and subtraction** using a **mode input M** and **XOR gates**.

```
M = 0  →  Addition:    F = A + B
M = 1  →  Subtraction: F = A - B  (implemented as A + B̄ + 1)
```

#### Why XOR? — The Key Trick

XOR gate acts as a **programmable inverter** controlled by M:

```
B ⊕ 0 = B     (B unchanged  → used for addition)
B ⊕ 1 = B̄     (B inverted   → used for subtraction)
```

When M=1:
- All B bits get inverted (1's complement)
- M=1 is also fed into **Cin of FA#0** → adds 1
- Inverted B + 1 = **2's complement of B**
- So: A + 2's complement of B = **A − B** ✓

#### Circuit Diagram (4-bit Adder-Subtractor)

```
                           M (Mode: 0=Add, 1=Subtract)
                           │
           ┌───────────────┼──────────────────────────────┐
           │               │                              │
    B3 ──[XOR]──┐   B2 ──[XOR]──┐   B1 ──[XOR]──┐  B0 ──[XOR]──┐
           ↑    │          ↑    │          ↑    │         ↑    │
           M    │          M    │          M    │         M    │
                ↓               ↓               ↓              ↓
  A3 ──→ ┌────────┐  A2 ──→ ┌────────┐  A1──→ ┌────────┐  A0──→ ┌────────┐
         │  FA#3  │←─Cout3─ │  FA#2  │←─Cout2 │  FA#1  │←─Cout1 │  FA#0  │←── M
         └───┬────┘         └───┬────┘        └───┬────┘        └───┬────┘
             S3                 S2                  S1                S0

Cout (Overflow) ←── from FA#3
```

#### Worked Example 1 (Addition): M=0, A=0110 (6), B=0011 (3)

```
M = 0 → B bits unchanged → B = 0011
Cin of FA#0 = M = 0

   A = 0 1 1 0
   B = 0 0 1 1
   Cin = 0
   ──────────
   S = 1 0 0 1  (= 9 in decimal)
   Cout = 0

Result = 1001 = 9  →  6 + 3 = 9 ✓
```

#### Worked Example 2 (Subtraction): M=1, A=0110 (6), B=0011 (3)

```
M = 1 → B bits inverted → B̄ = 1100
Cin of FA#0 = M = 1  (this +1 completes 2's complement)

   A  = 0 1 1 0   (6)
   B̄  = 1 1 0 0   (1's complement of 3)
   Cin = 1
   ──────────────
Carry:  0 1 1 1 1
   S  = 0 0 1 1   (= 3)
  Cout = 1  (ignored for same-size operands)

Result = 0011 = 3  →  6 - 3 = 3 ✓
```

---

## 4. Arithmetic Circuit — Full Operation Table

A generalized arithmetic circuit uses **S1, S0 (selection inputs)** and **Cin** to select from 8 different arithmetic operations.

The B input to the FA is determined by S1, S0 through a MUX:

| S1 | S0 | Input to FA (Y) |
|----|----|-----------------|
| 0  | 0  | Y = 0 (all zeros) |
| 0  | 1  | Y = B |
| 1  | 0  | Y = B̄ (complement) |
| 1  | 1  | Y = 1 (all ones) |

### Complete Function Table

| S1 | S0 | Cin | Operation | Description |
|----|----|-----|-----------|-------------|
| 0  | 0  |  0  | F = A     | Transfer A (no change) |
| 0  | 0  |  1  | F = A + 1 | Increment A |
| 0  | 1  |  0  | F = A + B | Addition |
| 0  | 1  |  1  | F = A + B + 1 | Addition with carry |
| 1  | 0  |  0  | F = A + B̄  | Subtract with borrow (A - B - 1) |
| 1  | 0  |  1  | F = A + B̄ + 1 | Subtraction (A - B) |
| 1  | 1  |  0  | F = A - 1 | Decrement A |
| 1  | 1  |  1  | F = A     | Transfer A |

> **Memory tip:** S1=0 → B or 0 used as-is (addition family). S1=1 → B̄ or 1 used (subtraction/decrement family).

---

## 5. Key Concepts

### 5.1 Carry vs Overflow

| Term | When it occurs | Relevant for |
|------|---------------|-------------|
| **Carry (C)** | MSB generates a carry out | Unsigned arithmetic |
| **Overflow (V)** | Result too large for register size | Signed arithmetic |

**Overflow detection:** Overflow occurs when carry INTO MSB ≠ carry OUT of MSB.

### 5.2 2's Complement — Quick Reference

Used to represent negative numbers and perform subtraction in hardware.

```
Step 1: Write the binary number
Step 2: Invert all bits (1's complement)
Step 3: Add 1

Example: 2's complement of 5 (= -5 in 4-bit)
  5     =  0101
  Invert:  1010   (1's complement)
  Add 1:  1011   (2's complement) ← this represents -5
```

**Subtraction using 2's complement:**
```
A - B  =  A + (2's complement of B)
       =  A + B̄ + 1
```

### 5.3 Half Adder vs Full Adder

| Feature | Half Adder | Full Adder |
|---------|-----------|-----------|
| Inputs | 2 (A, B) | 3 (A, B, Cin) |
| Outputs | Sum, Carry | Sum, Cout |
| Handles carry in? |  No |  Yes |
| Position in adder | LSB only | All bit positions |
| Gates needed | 1 XOR + 1 AND | 2 XOR + 2 AND + 1 OR |

---

## 6. Expected Exam Questions

1. **What are arithmetic micro-operations? List all with RTL notation.**
2. **Explain Half Adder with truth table, Boolean expressions, and circuit diagram.**
3. **Explain Full Adder with truth table, Boolean expressions, and circuit diagram.**
4. **What is the difference between Half Adder and Full Adder?**
5. **Draw and explain a 4-bit Ripple Carry Adder. Solve: 6 + 5.**
6. **Draw and explain a Binary Adder-Subtractor. How does XOR act as a programmable inverter?**
7. **Explain the complete arithmetic circuit function table with S1, S0, and Cin.**
8. **What is 2's complement? How is it used for subtraction in hardware?**
9. **What is the difference between carry and overflow?**
10. **Solve using Ripple Carry Adder: 9 + 6 in 4-bit binary.**

---
