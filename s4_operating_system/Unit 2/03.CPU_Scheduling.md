# Part 3: CPU Scheduling

---

## What is CPU Scheduling?

**CPU Scheduling** is the process by which the operating system decides which process in the ready queue should be executed next by the CPU.

### Goal
The main objective is to make the system efficient, fast, and fair by maximizing CPU utilization and minimizing wait time.

### CPU & I/O Burst Cycle
Processes alternate between two states:
1.  **CPU Burst**: The process is executing instructions on the CPU.
2.  **I/O Burst**: The process is waiting for I/O (disk, network, user input).

> **Tip**: CPU-bound processes have long CPU bursts. I/O-bound processes have short CPU bursts and frequent I/O waits.

---

## Types of Scheduling

### 1. Preemptive Scheduling
- The OS **can interrupt** a currently running process and move it to the Ready queue.
- **Triggers**: Timer interrupt (time slice expired), higher priority process arrives.
- **Algorithms**:
  - **SRTF** (Shortest Remaining Time First)
  - **LRTF** (Longest Remaining Time First)
  - **Round Robin**
  - **Priority based**
- **Pros**: Better responsiveness, prevents one process from hogging CPU.
- **Cons**: Overhead of context switching, data consistency issues.

### 2. Non-Preemptive Scheduling
- Once a process gets the CPU, it keeps it until it **voluntarily** releases it (terminates or waits for I/O).
- The OS **cannot** interrupt the process.
- **Algorithms**:
  - **FCFS** (First Come First Serve)
  - **SJF** (Shortest Job First)
  - **LJF** (Longest Job First)
  - **HRRN** (Highest Response Ratio Next)
  - **Multilevel Queue**
- **Pros**: Low overhead (fewer context switches), simple.
- **Cons**: Poor response time, "Convoy Effect".

---

## Scheduling Criteria (Performance Metrics)

To compare scheduling algorithms, we use these metrics:

1.  **CPU Utilization** (Maximize)
    - Percentage of time the CPU is busy working. Ideally 100%.

2.  **Throughput** (Maximize)
    - Number of processes completed per unit time.

3.  **Turnaround Time (TAT)** (Minimize)
    - Total time taken from submission to completion.
    - `TAT = Completion Time - Arrival Time`
    - `TAT = Burst Time + Waiting Time`

4.  **Waiting Time (WT)** (Minimize)
    - Total time a process spends waiting in the Ready queue.
    - `WT = Turnaround Time - Burst Time`

5.  **Response Time** (Minimize)
    - Time from submission until the *first* response is produced (important for interactive systems).

---

## Scheduling Algorithms

### 1. First-Come, First-Served (FCFS)

**Definition**: A non-preemptive scheduling algorithm where the process requesting the CPU first is allocated the CPU first. It is implemented using a FIFO queue.
**Explanation**: This is the simplest scheduling algorithm. The process that requests the CPU first gets the CPU first. It operates exactly like a real-life queue, such as a school lunch line where the student who gets in line first is served first, regardless of how long they take to decide.

**Criteria**: Arrival Time
**Mode**: Non-Preemptive

**Example**:

| Process No | Arrival Time (AT) | Burst Time (BT) | Completion Time (CT) | Turnaround Time (TAT) | Waiting Time (WT) | Response Time (RT) |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| P1 | 0 | 2 | 2 | 2 | 0 | 0 |
| P2 | 1 | 2 | 4 | 3 | 1 | 1 |
| P3 | 5 | 3 | 8 | 3 | 0 | 0 |
| P4 | 6 | 4 | 12 | 6 | 2 | 2 |

**Gantt Chart**:
```
|  P1  |  P2  | Idle |  P3  |  P4  |
0      2      4      5      8      12
```

**Calculations & Notes**:
-   **Completion Time (CT)**: Time at which the process completed.
-   **Turnaround Time (TAT)** = CT - AT
-   **Waiting Time (WT)** = TAT - BT
-   **Response Time (RT)** = Time when CPU was first got - Arrival Time.
    *(Note: In Non-Preemptive algorithms, RT = WT)*
-   **Average TAT** = (2 + 3 + 3 + 6) / 4 = 3.5 units

-   **Type**: Non-Preemptive
-   **Pros**: Very easy to understand (like a real line).
-   **Cons**: **Convoy Effect**. If a large process (CPU-bound) arrives first, all smaller processes (I/O-bound) behind it must wait, significantly reducing system efficiency.

---

### 2. Shortest Job First (SJF)

**Definition**: A scheduling algorithm that associates with each process the length of its next CPU burst. The CPU is assigned to the process with the smallest next CPU burst.
**Explanation**: The process with the shortest next CPU burst is selected first. This is similar to a grocery store express lane where customers with fewer items (shorter service time) are allowed to check out before those with full carts, minimizing the overall waiting time for the majority.

**Criteria**: Burst Time
**Mode**: Non-Preemptive

**Example**:

| Process No | Arrival Time (AT) | Burst Time (BT) | Completion Time (CT) | Turnaround Time (TAT) | Waiting Time (WT) | Response Time (RT) |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| P1 | 1 | 3 | 6 | 5 | 2 | 2 |
| P2 | 2 | 4 | 10 | 8 | 4 | 4 |
| P3 | 1 | 2 | 3 | 2 | 0 | 0 |
| P4 | 4 | 4 | 14 | 10 | 6 | 6 |

**Gantt Chart**:
```
| Idle |  P3  |  P1  |  P2  |  P4  |
0      1      3      6      10     14
```

*Note: At Time 1, both P1 and P3 arrive. P3 has smaller Burst Time (2 < 3), so P3 executes first. At Time 6, P2 and P4 have same Burst Time (4), so FCFS is used (P2 arrived first).*

-   **Type**: Non-Preemptive
-   **Pros**: Gives the **minimum average waiting time** (Optimal).
-   **Cons**:
    -   **Prediction**: It is difficult to know the exact length of the next CPU burst in advance.
    -   **Starvation**: If short processes keep arriving, long processes may never get executed.

---

### 3. Shortest Remaining Time First (SRTF)

**Definition**: The preemptive version of Shortest Job First (SJF). If a new process arrives with a CPU burst less than the remaining time of the current executing process, the kernel preempts the current process.
**Explanation**: This is the preemptive version of SJF. If a new process arrives with a shorter burst time than the remaining time of the current process, the CPU switches to the new process. Ideally, this is like a teacher grading a long essay but pausing to answer a quick 10-second question from a student, then returning to the essay.

**Criteria**: Burst Time
**Mode**: Preemptive

**Example**:

| Process No | Arrival Time (AT) | Burst Time (BT) | Completion Time (CT) | Turnaround Time (TAT) | Waiting Time (WT) | Response Time (RT) |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| P1 | 0 | 5 | 9 | 9 | 4 | 0 |
| P2 | 1 | 3 | 4 | 3 | 0 | 0 |
| P3 | 2 | 4 | 13 | 11 | 7 | 7 |
| P4 | 4 | 1 | 5 | 1 | 0 | 0 |

**Gantt Chart**:
```
| P1 |  P2  | P4 |  P1  |  P3  |
0    1      4    5      9      13
```

**Calculations & Notes**:
-   **Time 1**: P2 arrives (BT=3) which is shorter than P1's remaining time (4). P1 is preempted.
-   **Time 4**: P2 finishes. P4 arrives (BT=1). P4 is shortest.
-   **Response Time (RT)** = Time when process first gets the CPU - Arrival Time.
    -   Example P3: First got CPU at 9. Arrived at 2. RT = 9 - 2 = 7.

-   **Type**: Preemptive
-   **Pros**: Extremely efficient for short tasks.
-   **Cons**: The long task keeps getting interrupted.

---

### 4. Priority Scheduling

**Definition**: A scheduling algorithm where a priority number (integer) is associated with each process. The CPU is allocated to the process with the highest priority.
**Explanation**: The CPU is assigned to the process with the highest priority. This is comparable to a hospital emergency room where patients with critical conditions (high priority) are treated before those with minor injuries (low priority), regardless of arrival time.

**Criteria**: Priority (Higher the no. Higher the priority)
**Mode**: Preemptive

**Example**:

| Priority | Process No | Arrival Time (AT) | Burst Time (BT) | Completion Time (CT) | Turnaround Time (TAT) | Waiting Time (WT) |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| 10 | P1 | 0 | 5 | 12 | 12 | 7 |
| 20 | P2 | 1 | 4 | 8 | 7 | 3 |
| 30 | P3 | 2 | 2 | 4 | 2 | 0 |
| 40 | P4 | 4 | 1 | 5 | 1 | 0 |

**Gantt Chart**:
```
| P1 | P2 |  P3  | P4 |  P2  |  P1  |
0    1    2      4    5      8      12
```

**Execution Logic**:
1.  **Time 0**: P1 arrives (Pri:10). P1 runs.
2.  **Time 1**: P2 arrives (Pri:20 > 10). P1 preempted. P2 runs.
3.  **Time 2**: P3 arrives (Pri:30 > 20). P2 preempted. P3 runs.
4.  **Time 4**: P3 finishes (Burst 2). P4 arrives (Pri:40). P4 runs.
5.  **Time 5**: P4 finishes. P2 (Highest Pri:20) resumes.
6.  **Time 8**: P2 finishes. P1 (Highest Pri:10) resumes.
7.  **Time 12**: P1 finishes.

-   **Type**: Preemptive or Non-Preemptive.
-   **Issue**: **Starvation**. Low priority processes may never execute if high priority processes keep arriving.
-   **Solution**: **Aging**. Gradually increasing the priority of processes that wait for a long time to ensure they eventually execute.

---

### 5. Round Robin (RR)

**Definition**: A preemptive scheduling algorithm designed for time-sharing systems. Each process is given a small unit of CPU time (time quantum), and the ready queue is treated as a circular queue.
**Explanation**: Each process gets a fixed time slice (quantum) in a cyclic order. It is designed for time-sharing systems. An analogy is friends executing turns in a video game; each person plays for a fixed duration (e.g., 2 minutes) before passing the controller to the next person, ensuring everyone gets equal, periodic access.

**Criteria**: Time Quantum
**Mode**: Preemptive

**Example (Time Quantum = 2)**:

| Process No | Arrival Time (AT) | Burst Time (BT) | Completion Time (CT) | Turnaround Time (TAT) | Waiting Time (WT) | Response Time (RT) |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| P1 | 0 | 5 | 12 | 12 | 7 | 0 |
| P2 | 1 | 4 | 11 | 10 | 6 | 1 |
| P3 | 2 | 2 | 6 | 4 | 2 | 2 |
| P4 | 4 | 1 | 9 | 5 | 4 | 5 |

**Ready Queue Progression**:
`P1 -> P2 -> P3 -> P1 -> P4 -> P2 -> P1`

**Gantt Chart**:
```
| P1 | P2 | P3 | P1 | P4 | P2 | P1 |
0    2    4    6    8    9    11   12
```

**Calculations & Notes**:
-   **Context Switch**: Occurs when we save the process and call a new process.
-   **Sequence**:
    1.  **0-2**: P1 runs (Rem: 3). P2 arrives at 1. P3 arrives at 2. Queue: `P2, P3, P1`
    2.  **2-4**: P2 runs (Rem: 2). Queue: `P3, P1, P4(arr @4), P2`
    3.  **4-6**: P3 runs (Rem: 0). **Finishes**. Queue: `P1, P4, P2`
    4.  **6-8**: P1 runs (Rem: 1). Queue: `P4, P2, P1`
    5.  **8-9**: P4 runs (Rem: 0). **Finishes**. Queue: `P2, P1`
    6.  **9-11**: P2 runs (Rem: 0). **Finishes**. Queue: `P1`
    7.  **11-12**: P1 runs (Rem: 0). **Finishes**.

-   **Type**: Preemptive
-   **Performance**:
    -   If the time quantum is too large, it behaves like FCFS.
    -   If the time quantum is too small, there is excessive overhead from context switching.
-   **Pros**: Fair scheduling; no process waits indefinitely.
-   **Cons**: Higher turnaround time than SJF and context switching overhead.

---

### 6. Multilevel Queue Scheduling

**Definition**: A scheduling algorithm that partitions the ready queue into several separate queues (e.g., foreground and background). Processes are permanently assigned to one queue, and each queue has its own scheduling algorithm.
**Explanation**: Processes are categorized into different groups (queues) based on their type (e.g., interactive vs batch). This is similar to an airport check-in with separate lines for First Class and Economy passengers; the First Class line (high priority tasks) is served differently and often prioritized over the Economy line.

**Structure & Example**:

```
      Highest Priority
             │
  +-------------------------+
  |     System Process      | -----------------> Round Robin (RR)
  +-------------------------+
             │
  +-------------------------+
  |   Interactive Process   | -----------------> Shortest Job First (SJF)
  +-------------------------+
             │
  +-------------------------+
  |      Batch Process      | -----------------> FCFS
  +-------------------------+
             │
      Lowest Priority
```

-   **System Processes** (Highest Priority) run first using **RR**.
-   **Interactive Processes** (Medium Priority) run next using **SJF**.
-   **Batch Processes** (Lowest Priority) run last using **FCFS**.

-   **Type**: Preemptive (usually specific to queue).
-   **Cons**: Lower priority queues (e.g., Economy) might suffer starvation if higher priority queues are always full.

---

### 7. Multilevel Feedback Queue

**Definition**: A scheduling algorithm that allows processes to move between queues. It separates processes according to the characteristics of their CPU bursts to separate I/O-bound and CPU-bound processes.
**Explanation**: Unlike Multilevel Queue, processes here can move between queues based on their behavior. It acts like a graduation system: processes start in a queue; if they consume too much CPU, they are moved to a different queue.

**Structure & Example**:

```
   Lowest Priority (Batch Process)
        │
        ▼
  +-------------------------+       if Completed then Out
  | RQ1   P1  (TQ=2)        | -------------------------->
  +-------------------------+
        │
        │
        ▼
  +-------------------------+       if Completed then Out
  | RQ2       (TQ=4)        | -------------------------->
  +-------------------------+
        │
        │
        ▼
  +-------------------------+       if Completed then Out
  | RQ3       (TQ=8)        | -------------------------->
  +-------------------------+
        │
        │
        ▼
  +-------------------------+       Remaining all Executed
  | RQ4       (FCFS)        | --------------------------> in FCFS manner
  +-------------------------+
  Highest Priority (System Process)
```

**Calculation Example**:
Process **P1** requires **19 units** of Burst Time.
1.  **RQ1**: P1 runs for **2 units**. Remaining = 17. Not finished → Moved to RQ2.
2.  **RQ2**: P1 runs for **4 units**. Remaining = 13. Not finished → Moved to RQ3.
3.  **RQ3**: P1 runs for **8 units**. Remaining = 5. Not finished → Moved to RQ4.
4.  **RQ4**: P1 runs for **5 units** in FCFS. Remaining = 0. **Finished**.

-   **Type**: Preemptive.
-   **Pros**: Most flexible scheduling algorithm.
-   **Cons**: Most complex to implement and configure.

---

### 8. Longest Job First (LJF)

**Definition**: A non-preemptive scheduling algorithm that selects the process with the longest execution time (largest CPU burst) from the ready queue to execute next.
**Explanation**: This is the opposite of SJF; the process with the longest burst time is executed first. It can be likened to a buffet where the person with the largest plate is allowed to eat first, while those with small snacks wait.

-   **Type**: Non-Preemptive
-   **Pros**: Reduces context switching for large processes.
-   **Cons**: Smaller processes may face starvation.

---

### 9. Longest Remaining Time First (LRTF)

**Definition**: The preemptive version of Longest Job First (LJF). If a new process arrives or if the current process's remaining time changes such that another process has a longer remaining time, the CPU is switched to the process with the longest remaining time.
**Explanation**: The preemptive version of LJF. The CPU constantly checks if there is a process with a longer remaining time than the current one and switches to it if found. Ideally, this maximizes processor usage but is rarely used in practice due to high overhead.

-   **Type**: Preemptive
-   **Cons**: High overhead and not practical for general systems.

---

### 10. Highest Response Ratio Next (HRRN)

**Definition**: A non-preemptive scheduling algorithm designed to correct the starvation problem of SJF. It calculates a priority (Response Ratio) based on both waiting time and service time.
**Explanation**: This algorithm addresses the starvation issue in SJF/LJF by considering both the burst time and the waiting time. The priority is decided by the response ratio:
`Response Ratio = (Waiting Time + Burst Time) / Burst Time`
A real-world analogy is a teacher who picks a student not just based on how short their question is, but also by how long they have been raising their hand (waiting).

-   **Type**: Non-Preemptive
-   **Pros**: Prevents starvation (Aging is effectively built-in).
-   **Cons**: Calculation overhead is higher.

---

## Important Points for Exams

1.  **SJF** is optimal for minimum average waiting time but is hard to implement (prediction required).
2.  **Convoy Effect** happens in **FCFS**.
3.  **Aging** is the solution to **Starvation** in Priority scheduling.
4.  **Round Robin** is best for time-sharing/interactive systems.
5.  **Formulas**:
    - `TAT = Completion - Arrival`
    - `WT = TAT - Burst`
6.  **Gantt Charts**: Practice drawing these for FCFS, SJF, RR to calculate waiting times.

---

## Quick Revision Questions

### Short Answer
1.  Define Throughput and Turnaround Time.
2.  What is the Convoy Effect? Which algorithm suffers from it?
3.  Difference between Preemptive and Non-Preemptive scheduling.
4.  What is Aging? What problem does it solve?

### Numerical / Conceptual
1.  Why is Round Robin better for a time-sharing system than FCFS?
2.  If the Time Quantum is extremely small, what is the impact on the system?
3.  Given 3 processes P1(10ms), P2(1ms), P3(2ms). Calculate Average Waiting Time for FCFS (order P1, P2, P3) vs SJF.

---

