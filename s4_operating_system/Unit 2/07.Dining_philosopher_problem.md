# Dining Philosophers Problem

The **Dining Philosophers Problem** is a classic synchronization problem in operating systems that illustrates the challenges of allocating limited resources among concurrent processes.

## Problem Statement

Consider **N** philosophers sitting around a circular table.
- There is a bowl of rice in the center.
- There are **N** forks (or chopsticks) placed between each pair of adjacent philosophers.
- A philosopher spends their time **Thinking** and **Eating**.
- To eat, a philosopher needs **two forks**: one from their immediate left and one from their immediate right.
- A philosopher can only pick up one fork at a time.
- If a philosopher cannot get both forks, they cannot eat and must wait.

### Constraints
- **Mutual Exclusion**: No two philosophers can hold the same fork at the same time.
- **Deadlock**: The system should not reach a state where no philosopher can proceed.
- **Starvation**: Every philosopher should eventually get a chance to eat.

## The Code Structure

Based on the provided solution usage of semaphores (or locks represented as `take_fork`), here is the typical structure for a philosopher `i`:

```c
void philosopher(void)
{
    while(true)
    {
        Thinking();
        
        take_fork(i);           // Take Left Fork
        take_fork((i+1) % N);   // Take Right Fork
        
        EAT();
        
        put_fork(i);            // Put Left Fork
        put_fork((i+1) % N);    // Put Right Fork
    }
}
```

Where `N` is the number of philosophers (e.g., 5).

## Visual Representation

![Dining Philosophers Diagram](dining.png)

## The Deadlock Scenario

The simple solution above is prone to **Deadlock**.

**Case 1:**
Imagine all 5 philosophers (`P0` to `P4`) become hungry at the exact same time.
1. All philosophers execute `take_fork(i)` simultaneously.
2. `P0` picks up fork `F0`.
3. `P1` picks up fork `F1`.
4. `P2` picks up fork `F2`.
5. `P3` picks up fork `F3`.
6. `P4` picks up fork `F4`.

At this point, every philosopher holds their **left fork**.
Now, they all try to execute `take_fork((i+1) % N)` (their right fork).
- `P0` needs `F1`, which is held by `P1`.
- `P1` needs `F2`, which is held by `P2`.
- ...
- `P4` needs `F0`, which is held by `P0`.

This creates a **circular wait**, one of the necessary conditions for deadlock. No philosopher can proceed to `EAT()`, and no one will release their fork. The system comes to a standstill.
