# Part 4: Process Synchronization

---

## 1. Introduction

**Process Synchronization** is the task of coordinating the execution of processes in a way that no two processes can access the same shared data and resources effectively and efficiently at the same time.

### Execution Modes
When processes run, they can operate in:
1.  **Serial Mode**: One after another.
2.  **Parallel Mode**: Simultaneously.

### Types of Processes
In a system, processes can be:
1.  **Independent**: Execution does not affect others.
2.  **Cooperative**: Execution can affect or be affected by other processes. They share:
    -   **Variables**
    -   **Memory**
    -   **Code**
    -   **Resources** (CPU, Printer, Scanner)

When cooperative processes share data, **concurrent access** can lead to data inconsistency. Synchronization ensures data consistency.

---

## 2. The Problem: Race Condition

**Definition**: A situation where several processes access and manipulate the same data concurrently and the outcome of the execution depends on the particular order in which the access takes place.

**Explanation & Example**:
Consider a shared variable `int shared = 5;`.
Two processes process P1 and P2 run concurrently.

| Process P1 | Process P2 |
| :--- | :--- |
| `int x = shared;` (Read 5) | `int y = shared;` (Read 5) |
| `x++;` (x becomes 6) | `y--;` (y becomes 4) |
| `sleep(1);` | `sleep(1);` |
| `shared = x;` (Write 6) | `shared = y;` (Write 4) |

**Scenario**:
1.  P1 reads `shared` (5) into local `x`.
2.  Context Switch -> P2 runs.
3.  P2 reads `shared` (5) into local `y`.
4.  P2 decrements `y` (4) and updates `shared` = 4.
5.  Context Switch -> P1 runs.
6.  P1 increments `x` (6) and updates `shared` = 6.

**Result**: The update by P2 is **lost**. Final value is 6 (should be 5).
This "race" to read/write causes data inconsistency.

---

## 3. The Critical Section Problem

**Definition**: A code segment where shared variables, common files, and global variables are accessed or modified.

**Structure of a Process**:
Any process has both Critical and Non-Critical sections.

```c
main() {
    // Non-Critical Section (A, B)
    
    ENTRY SECTION      // Request permission (e.g., Count++)
    
        CRITICAL SECTION   // Access Shared Resources (CS)
        
    EXIT SECTION       // Release permission (e.g., Count--)
    
    // Remainder Section
}
```

### Synchronization Mechanism (4 Conditions)
To safely solve the Critical Section Problem, a solution should satisfy the following 4 conditions:

1.  **Mutual Exclusion** (Mandatory):
    -   If process **P1** is executing in its critical section, then **P2** (or any other process) cannot enter the critical section.
    -   *Concept*: If P1 is inside, P2 is blocked (X) from entering.

2.  **Progress** (Mandatory):
    -   If the Critical Section is empty, and some processes want to enter, only those processes in the entry section can participate in the decision.
    -   **A non-interested process (in Remainder Section) cannot stop an interested process from entering.**
    -   *Analogy*: If the room is empty, you cannot block me from entering if you don't even want to use it.

3.  **Bounded Waiting** (Optional/Fairness):
    -   There must be a limit (Bound) on the number of times other processes are allowed to enter their critical sections after a process has made a request.
    -   **Goal**: Prevent Starvation. P1 cannot enter infinitely (âˆž) times while P2 waits. P2 must get a chance eventually.

4.  **No Assumption related to Hardware Speed**:
    -   The solution should not depend on the speed of the CPU or the number of processors. It should work correctly regardless of relative process speeds.

---

## 4. Software Solutions (Algorithms)

These algorithms attempt to solve the critical section problem via software logic.

### A. Strict Alternation (Turn Variable)
Uses a shared variable `turn` to alternate between two processes (P0 and P1).

-   **Logic**:
    -   Process 0 enters if `turn == 0`.
    -   Process 1 enters if `turn == 1`.
-   **Issue**: Satisfies Mutual Exclusion but **Violates Progress**.
    -   *Why?* If P0 enters and exits, it sets `turn = 1`. If P0 wants to enter *again* immediately (and P1 is not interested), P0 is blocked by its own `turn` variable waiting for P1.

### B. Peterson's Solution (The Polite Protocol)

**Definition**: A classic software solution that guarantees Mutual Exclusion, Progress, and Bounded Waiting for **two processes** (P0 and P1).

**The Concept (Easy Explanation)**:
Imagine two people trying to enter a single door. They use two tools to coordinate:
1.  **`Flag` (Desire)**: "I raise my hand."
    -   `Flag[i] = True`: Process *i* wants to enter.
2.  **`Turn` (Politeness)**: "After you."
    -   `Turn = j`: Process *i* gives priority to Process *j*.

**Algorithm Steps**:
1.  **I want to enter** (`flag[i] = true`).
2.  **Please, you go first** (`turn = j`).
3.  **Wait** (`while`) only if:
    -   The other person wants to enter (`flag[j] == true`) **AND** 
    -   It is visibly their turn (`turn == j`).
4.  **Critical Section**: Enter and execute.
5.  **I am done** (`flag[i] = false`).

**Code Representation**:
```c
// Structure for Process i (where j is the other process)
do {
    flag[i] = true;          // 1. I want to enter
    turn = j;                // 2. I give priority to you (j)
    
    // 3. Wait while other wants to Enter AND it is their turn
    while (flag[j] == true && turn == j);
    
        CRITICAL SECTION     // 4. Access Shared Resource
         
    flag[i] = false;         // 5. I am done (Exit)
    
        REMAINDER SECTION
} while (true);
```

**Why it works**:
-   **Mutual Exclusion**: Only one process can pass the `while` loop at a time.
-   **Progress**: If acts politely, they won't block each other indefinitely.
-   **Bounded Waiting**: Each process gets a fair chance.


---

## Important Points for Exams
1.  **Race Condition** leads to data inconsistency.
2.  **Peterson's Solution** is the best software solution for 2 processes.
3.  **Semaphores** are used to solve these problems without busy waiting.
