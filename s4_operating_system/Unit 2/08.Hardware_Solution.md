
# Hardware Solutions for Critical Section

Software solutions like Peterson's Solution work but have limitations. Hardware provides more efficient mechanisms.

### A. Disabling Interrupts

**Concept**: Disable all interrupts while in the critical section so no context switch can occur.

```c
void process() {
    disable_interrupts();    // Entry Section
    
    // CRITICAL SECTION
    
    enable_interrupts();     // Exit Section
}
```

**Advantages**:
- Simple to implement
- Works on uniprocessor systems

**Disadvantages**:
- **Not suitable for multiprocessor systems** (other CPUs can still access shared data)
- **Risky**: If a process forgets to enable interrupts, the system hangs
- **Reduces efficiency**: Important interrupts are missed

> [!WARNING]
> This approach is only used by the kernel for short critical sections, never by user processes.

---

### B. Test-and-Set Lock (TSL)

**Definition**: An atomic hardware instruction that tests and modifies a memory word in one uninterruptible operation.

**The TSL Instruction**:
```
TSL RX, LOCK
```
- Reads the value of `LOCK` into register `RX`
- Sets `LOCK` to 1 (non-zero value)
- **Both operations are atomic** (indivisible)

**Implementation**:
```c
// Shared variable
int lock = 0;  // 0 = unlocked, 1 = locked

// TSL Instruction (atomic)
int TestAndSet(int *lock) {
    int old = *lock;    // Read current value
    *lock = 1;          // Set to 1 (locked)
    return old;         // Return old value
}

// Process using TSL
void process() {
    // Entry Section - Busy wait until lock is acquired
    while (TestAndSet(&lock) == 1);  // Spin if already locked
    
    // CRITICAL SECTION
    
    lock = 0;           // Exit Section - Release lock
}
```

**How it Works**:

| Scenario | TestAndSet Returns | Result |
|----------|-------------------|--------|
| Lock was 0 (free) | 0 | Process enters CS, lock becomes 1 |
| Lock was 1 (busy) | 1 | Process keeps spinning (busy wait) |

**Properties**:
- **Mutual Exclusion**: Guaranteed (atomic operation)
- **Progress**: Satisfied
- **Bounded Waiting**: NOT guaranteed (starvation possible)

---

### C. Compare-and-Swap (CAS)

**Definition**: An atomic instruction that compares a memory location with an expected value and, if equal, swaps it with a new value.

**The CAS Operation**:
```c
// Atomic Compare-and-Swap
int CompareAndSwap(int *value, int expected, int new_value) {
    int temp = *value;
    if (*value == expected)
        *value = new_value;
    return temp;        // Return original value
}
```

**Usage for Mutual Exclusion**:
```c
int lock = 0;  // Shared lock variable

void process() {
    // Entry Section
    while (CompareAndSwap(&lock, 0, 1) != 0);  // Wait until lock acquired
    
    // CRITICAL SECTION
    
    lock = 0;  // Exit Section
}
```

**How it Works**:
- If `lock == 0` (expected), set `lock = 1` and return 0 → Enter CS
- If `lock != 0`, return current value (1) → Keep waiting

**Properties**:
- **Mutual Exclusion**: Guaranteed
- **Progress**: Satisfied
- **Bounded Waiting**: NOT guaranteed

---

### D. Bounded Waiting Solution with TSL

To ensure bounded waiting, we use an array to track waiting processes:

```c
int lock = 0;
bool waiting[n];  // All initialized to false

void process(int i) {
    waiting[i] = true;
    int key = 1;
    
    // Wait until: either we get the lock OR we're selected by exiting process
    while (waiting[i] && key == 1)
        key = TestAndSet(&lock);
    
    waiting[i] = false;
    
    // CRITICAL SECTION
    
    // Exit: Find next waiting process
    int j = (i + 1) % n;
    while ((j != i) && !waiting[j])
        j = (j + 1) % n;
    
    if (j == i)
        lock = 0;           // No one waiting, release lock
    else
        waiting[j] = false; // Pass to next waiting process
}
```

**Properties**:
- **Mutual Exclusion**: Guaranteed
- **Progress**: Guaranteed
- **Bounded Waiting**: Guaranteed (circular order ensures fairness)

---
