# Readers-Writers Problem

---

## 1. Introduction

**Definition**: The Readers-Writers Problem is a classical synchronization problem in operating systems that deals with situations where a shared data resource (like a database or file) is accessed by multiple concurrent processes.

### The Core Concept

There are two types of processes:
- **Readers**: Processes that only **read** the shared data
- **Writers**: Processes that **read and write** (modify) the shared data

### Access Scenarios

Consider multiple Readers (R₁, R₂) and Writers (W₁, W₂) trying to access the same database:

```
    ↓R₁  ↓W₁  ↓R₂  ↓W₂
    ┌─────────────────┐
    │       DB        │ ← Same Data
    └─────────────────┘
```

| Scenario | Result | Reason |
|----------|--------|--------|
| **R - W** | Problem | Writer modifying while Reader reading causes inconsistency |
| **W - R** | Problem | Reader may read partially modified data |
| **W - W** | Problem | Two writers simultaneously cause data corruption |
| **R - R** | No Problem | Multiple readers can safely read concurrently |

### Key Constraint

> [!IMPORTANT]
> - **Multiple Readers** can access the database **simultaneously** (no data modification)
> - **Only ONE Writer** can access the database at a time (**exclusive access**)
> - If a Writer is writing, **NO Reader or Writer** can access the database

---

## 2. Problem Analysis

### Why is R-R Safe?
- Reading does not modify data
- All readers see the same consistent state
- No race conditions possible

### Why are R-W, W-R, and W-W Problematic?

1. **R-W (Reader during Writing)**: Reader may read partial/inconsistent data
2. **W-R (Writer during Reading)**: Data modification during read causes dirty read
3. **W-W (Concurrent Writers)**: Lost updates, data corruption, race conditions

---

## 3. Solution Using Semaphores

### Shared Variables

```c
int rc = 0;              // Reader Count - tracks active readers
Semaphore mutex = 1;     // Protects access to 'rc'
Semaphore db = 1;        // Controls access to database
```

### Visual Representation

![Reader-Writer Problem Solution](reader_writer.png)

### Explanation of Variables

| Variable | Type | Initial Value | Purpose |
|----------|------|---------------|---------|
| `rc` | Integer | 0 | Counts the number of active readers |
| `mutex` | Binary Semaphore | 1 | Ensures mutual exclusion when updating `rc` |
| `db` | Binary Semaphore | 1 | Controls exclusive access to the database |

---

## 4. The Reader Process

```c
void Reader(void) {
    while(true) {
        // Entry Section - Entering Critical Region
        down(mutex);           // Lock mutex to safely update rc
        
        rc = rc + 1;           // Increment reader count
        
        if (rc == 1)           // If this is the FIRST reader
            then down(db);     // Lock the database (block writers)
        
        up(mutex);             // Release mutex
        
        // Critical Section
        // ┌─────────┐
        // │   DB    │  ← Read from database
        // └─────────┘
        Process_data;          // Read and process data
        
        // Exit Section - Leaving Critical Region
        down(mutex);           // Lock mutex to safely update rc
        
        rc = rc - 1;           // Decrement reader count
        
        if (rc == 0)           // If this is the LAST reader
            then up(db);       // Unlock database (allow writers)
        
        up(mutex);             // Release mutex
    }
}
```

### Reader Logic Explained

1. **Entry Section**:
   - Acquire `mutex` to safely increment `rc`
   - **First reader** (`rc == 1`) locks the database using `down(db)`
   - Release `mutex`

2. **Critical Section**:
   - Safely read from the database
   - Multiple readers can be here simultaneously

3. **Exit Section**:
   - Acquire `mutex` to safely decrement `rc`
   - **Last reader** (`rc == 0`) unlocks the database using `up(db)`
   - Release `mutex`

> [!NOTE]
> The first reader locks out writers, and only the last reader unlocks for writers. This allows multiple concurrent readers.

---

## 5. The Writer Process

```c
void Writer(void) {
    while(true) {
        // Entry Section
        down(db);              // Lock database (exclusive access)
        
        // Critical Section
        // ┌─────────┐
        // │   DB    │  ← Write to database
        // └─────────┘
        // Write/Modify data
        
        // Exit Section
        up(db);                // Unlock database
    }
}
```

### Writer Logic Explained

1. **Entry Section**:
   - Acquire exclusive access by calling `down(db)`
   - Blocks if any reader (first reader holds `db`) or another writer has access

2. **Critical Section**:
   - Has **exclusive access** to the database
   - Can safely read and write data

3. **Exit Section**:
   - Release the database lock using `up(db)`

> [!TIP]
> Writer's code is simpler because it always needs exclusive access - either it has the database or it waits.

---

## 6. How It Works Together

### Scenario 1: First Reader Arrives
1. Reader calls `down(mutex)` → Gets mutex
2. Increments `rc` from 0 to 1
3. Since `rc == 1`, calls `down(db)` → Locks database from writers
4. Releases mutex, reads data
5. When done, decrements `rc` to 0
6. Since `rc == 0`, calls `up(db)` → Frees database for writers

### Scenario 2: Multiple Readers Arrive
1. First reader locks `db`
2. Second reader: increments `rc` to 2, but `rc != 1`, so doesn't call `down(db)` again
3. Both readers read concurrently
4. As readers leave, they decrement `rc`
5. Only the **last reader** (`rc` becomes 0) unlocks `db`

### Scenario 3: Writer Tries to Access During Reading
1. Readers have locked `db`
2. Writer calls `down(db)` → **BLOCKED** (waiting)
3. Only after all readers exit and last reader calls `up(db)`
4. Writer gets access

### Scenario 4: Reader Tries to Access During Writing
1. Writer has locked `db`
2. Reader calls `down(mutex)` → Gets mutex
3. Increments `rc` to 1
4. Since `rc == 1`, calls `down(db)` → **BLOCKED** (waiting for writer)
5. Subsequent readers also block on `mutex` (held by first waiting reader)

---

## 7. Potential Issues

### Starvation of Writers (First Readers-Writers Problem)

> [!WARNING]
> This solution may lead to **writer starvation** if readers keep arriving!

**Problem**: As long as there is at least one reader in the critical section, new readers can enter. A steady stream of readers could indefinitely block waiting writers.

**Example**:
```
Time: ──────────────────────────────────>
R1:   [████████]
R2:      [████████]
R3:         [████████]
R4:            [████████]
Writer:                 [WAITING INDEFINITELY...]
```

### Solutions to Writer Starvation

1. **Second Readers-Writers Problem**: Give priority to writers (may cause reader starvation)
2. **Fair Solution**: Use additional semaphores to ensure FIFO ordering

---

## 8. Applications

The Readers-Writers problem models many real-world scenarios:

1. **Database Systems**: Multiple users reading, few users writing
2. **File Systems**: Reading files vs. editing files
3. **Web Caching**: Multiple servers reading cache, occasional cache updates
4. **Configuration Files**: Many processes reading config, admin writing
5. **Banking Systems**: Balance inquiries (read) vs. transactions (write)

---

## 9. Key Takeaways

1. **Multiple concurrent readers** are safe and improve throughput
2. **Writers require exclusive access** - no other reader or writer allowed
3. **First reader** locks database, **last reader** unlocks it
4. **Semaphores needed**:
   - `mutex` for protecting reader count
   - `db` for database access control
5. **Basic solution favors readers** - can cause writer starvation
6. **More complex solutions** balance fairness between readers and writers

---
