# Message Passing

**Definition**: **Message Passing** is an IPC (Inter-Process Communication) mechanism where processes communicate by explicitly sending and receiving messages, without sharing memory.

### Why Message Passing?

- **Distributed Systems**: Processes may be on different machines (no shared memory)
- **Protection**: No direct memory access between processes
- **Flexibility**: Works for both local and networked processes

---

### Basic Operations

```c
send(destination, message)    // Send a message
receive(source, message)      // Receive a message
```

---

### Design Issues

#### 1. Naming (Addressing)

**Direct Communication**:
- Processes explicitly name each other
- `send(P, message)` - Send to process P
- `receive(Q, message)` - Receive from process Q

```c
// Process P                    // Process Q
send(Q, "Hello");              receive(P, msg);
```

**Indirect Communication (Mailboxes/Ports)**:
- Messages sent to and received from mailboxes
- Multiple processes can share a mailbox

```c
// Create mailbox
Mailbox A;

// Process P                    // Process Q
send(A, "Hello");              receive(A, msg);
```

| Aspect | Direct | Indirect |
|--------|--------|----------|
| Flexibility | Low (must know receiver) | High (mailbox abstraction) |
| Coupling | Tight | Loose |
| Example | Pipes | Message Queues |

---

#### 2. Synchronization

**Blocking (Synchronous)**:
- **Blocking send**: Sender waits until message is received
- **Blocking receive**: Receiver waits until message is available
- Also called **Rendezvous** when both block

**Non-Blocking (Asynchronous)**:
- **Non-blocking send**: Sender sends and continues
- **Non-blocking receive**: Receiver gets message or null/error

| Type | Send | Receive |
|------|------|---------|
| Synchronous | Blocks until received | Blocks until available |
| Asynchronous | Returns immediately | Returns immediately (may be empty) |

---

#### 3. Buffering

**Zero Capacity (No Buffer)**:
- Sender must wait for receiver (rendezvous)
- No messages can be queued

**Bounded Capacity**:
- Buffer holds up to N messages
- Sender blocks if buffer is full
- Most common implementation

**Unbounded Capacity**:
- Buffer has infinite size (theoretically)
- Sender never blocks

---

### Producer-Consumer Using Message Passing

```c
// Shared: mailbox for data, mailbox for empty slots
Mailbox dataBox;
Mailbox emptyBox;

// Initialize: N empty slots
for (int i = 0; i < N; i++)
    send(emptyBox, "empty");

// PRODUCER
void Producer() {
    while (true) {
        item = produce();
        receive(emptyBox, &empty);   // Wait for empty slot
        send(dataBox, item);         // Send data
    }
}

// CONSUMER
void Consumer() {
    while (true) {
        receive(dataBox, &item);     // Wait for data
        send(emptyBox, "empty");     // Signal empty slot
        consume(item);
    }
}
```

---

### Message Passing vs Shared Memory

| Aspect | Message Passing | Shared Memory |
|--------|-----------------|---------------|
| **Communication** | Explicit send/receive | Read/write to shared location |
| **Synchronization** | Built into send/receive | Requires semaphores/monitors |
| **Speed** | Slower (copying overhead) | Faster (direct access) |
| **Distributed Systems** | Works across network | Local only |
| **Protection** | Automatic isolation | Requires careful programming |
| **Ease of Use** | Easier (no race conditions) | Harder (race conditions possible) |

---

### Message Passing Summary

| Feature | Description |
|---------|-------------|
| **Operations** | `send()` and `receive()` |
| **Naming** | Direct (name process) or Indirect (mailbox) |
| **Synchronization** | Blocking or Non-blocking |
| **Buffering** | Zero, Bounded, or Unbounded |
| **Use Cases** | Distributed systems, microservices, pipes |

---

## 4. Event Counters

**Definition**: **Event Counters** are a synchronization mechanism that provides an alternative to semaphores. An event counter is an integer variable that can only increase.

### Properties

1. **Monotonically Increasing**: Value never decreases
2. **Initial Value**: Starts at 0
3. **No Negative Values**: Always ≥ 0

---

### Operations on Event Counter E

| Operation | Description |
|-----------|-------------|
| `read(E)` | Returns the current value of E |
| `advance(E)` | Atomically increments E by 1 |
| `await(E, v)` | Blocks until E ≥ v (waits for E to reach value v) |

---

### How Event Counters Work

```
Time:     t1      t2      t3      t4      t5
           │       │       │       │       │
E value:   0       1       2       3       4
           │       │       │       │       │
           └─advance─advance─advance─advance

Process A: await(E, 3) ──blocks──────┤ proceeds
                                     │
                              (E reaches 3)
```

---

### Producer-Consumer Using Event Counters

```c
// Event Counters
EventCounter in = 0;     // Counts items produced
EventCounter out = 0;    // Counts items consumed

int buffer[N];

// PRODUCER
void Producer() {
    int sequence = 0;
    while (true) {
        item = produce();
        sequence++;
        
        // Wait until there's space: items produced - items consumed < N
        await(out, sequence - N);
        
        buffer[sequence % N] = item;
        advance(in);             // Signal item produced
    }
}

// CONSUMER
void Consumer() {
    int sequence = 0;
    while (true) {
        sequence++;
        
        // Wait until item is available
        await(in, sequence);
        
        item = buffer[sequence % N];
        advance(out);            // Signal item consumed
        consume(item);
    }
}
```

---

### Event Counters vs Semaphores

| Aspect | Event Counters | Semaphores |
|--------|----------------|------------|
| **Value** | Only increases | Can increase/decrease |
| **Range** | 0 to ∞ | Can be negative (in some implementations) |
| **History** | Tracks cumulative events | Tracks current count |
| **Starvation** | Less prone | Possible |
| **Complexity** | Slightly more complex | Simpler |

---

### Event Counters Summary

| Feature | Description |
|---------|-------------|
| **Purpose** | Synchronization without traditional locks |
| **Operations** | `read()`, `advance()`, `await()` |
| **Key Property** | Monotonically increasing |
| **Advantage** | No starvation; orders events naturally |
| **Usage** | Less common than semaphores/monitors |

---

## Quick Revision: All Synchronization Mechanisms

| Mechanism | Level | Key Feature | Use Case |
|-----------|-------|-------------|----------|
| **Disable Interrupts** | Hardware | Simplest, kernel only | Very short critical sections |
| **TSL / CAS** | Hardware | Atomic test-and-set | Low-level locks |
| **Semaphores** | OS | wait() / signal() | General synchronization |
| **Monitors** | Language | Automatic mutex | High-level, OOP |
| **Message Passing** | OS/Network | send() / receive() | Distributed systems |
| **Event Counters** | OS | Monotonic counter | Order-based sync |

---

## Important Exam Questions

### Short Answer
1. What is the Test-and-Set instruction? How does it provide mutual exclusion?
2. Compare Hardware and Software solutions for critical section problem.
3. What is a Monitor? How is it different from Semaphores?
4. Explain condition variables with `wait()` and `signal()` operations.
5. What is Message Passing? Differentiate between Direct and Indirect communication.

### Long Answer
1. Write and explain the Producer-Consumer solution using Monitors.
2. Compare and contrast Semaphores, Monitors, and Message Passing.
3. Explain the Compare-and-Swap instruction with an example.
4. What are Event Counters? Show Producer-Consumer using Event Counters.

---

## Comparison Chart for Exams

| Feature | Semaphore | Monitor | Message Passing |
|---------|-----------|---------|-----------------|
| **Mutual Exclusion** | Manual (wait/signal) | Automatic | Via message order |
| **Synchronization** | Manual | Condition variables | Blocking send/receive |
| **Error-prone** | Yes | Less | Less |
| **Distributed** | No | No | Yes |
| **Language Support** | OS primitive | Java, C# | MPI, Sockets |
