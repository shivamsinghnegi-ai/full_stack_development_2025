# Part 1: Process Fundamentals

---

## What is a Process?

### Definition
A **process** is a program in execution. It is an active entity that requires resources such as CPU, memory, files, and I/O devices to accomplish its task.

### Key Characteristics
- **Dynamic Nature**: A process is a running instance of a program
- **Resource Consumer**: Requires CPU time, memory, files, and I/O devices
- **Unique Identity**: Each process has a unique Process ID (PID)
- **Independent Execution**: Processes execute independently with their own memory space

### Components of a Process
A process consists of multiple parts:

1. **Text Section** (Code Segment)
   - Contains the executable code
   - Read-only section
   - Shared among multiple instances of the same program

2. **Data Section**
   - Contains global and static variables
   - Initialized and uninitialized data

3. **Heap**
   - Dynamically allocated memory
   - Grows upward in memory
   - Used for dynamic memory allocation (malloc, new)

4. **Stack**
   - Contains temporary data
   - Function parameters, return addresses, local variables
   - Grows downward in memory
   - LIFO (Last In First Out) structure

5. **Program Counter (PC)**
   - Points to the next instruction to execute

6. **CPU Registers**
   - Store current values of variables and intermediate results

```
High Memory Address
+------------------+
|      Stack       | ← Grows Downward
|        ↓         |
+------------------+
|                  |
|   Free Memory    |
|                  |
+------------------+
|        ↑         |
|      Heap        | ← Grows Upward
+------------------+
|   Data Section   |
| (Global/Static)  |
+------------------+
|   Text Section   |
|     (Code)       |
+------------------+
Low Memory Address
```

---

## Process vs Program

| Aspect | Program | Process |
|--------|---------|---------|
| **Nature** | Passive entity (static) | Active entity (dynamic) |
| **Lifespan** | Exists permanently | Temporary, exists only during execution |
| **Resource Usage** | Does not consume resources | Consumes CPU, memory, I/O |
| **Location** | Stored on disk | Loaded in memory |
| **State** | No state | Has various states (new, ready, running, etc.) |
| **Example** | `.exe` file on disk | Running instance of `.exe` |

### Example
- **Program**: `notepad.exe` stored on your hard drive
- **Process**: When you double-click `notepad.exe`, multiple running instances become separate processes

> **Important**: One program can create multiple processes. For example, opening Chrome multiple times creates multiple Chrome processes.

---

## Process Control Block (PCB)

### Definition
The **Process Control Block (PCB)** is a data structure maintained by the operating system for every process. It contains all the information needed to manage and control a process.

### Also Known As
- Task Control Block (TCB)
- Process Descriptor

### Structure of PCB

```
+----------------------------------+
|    Process Control Block (PCB)   |
+----------------------------------+
| Process ID (PID)                 |
| Process State                    |
| Program Counter (PC)             |
| CPU Registers                    |
| CPU Scheduling Information       |
| Memory Management Information    |
| Accounting Information           |
| I/O Status Information           |
+----------------------------------+
```

### PCB Components in Detail

#### 1. **Process Identification**
- **Process ID (PID)**: Unique identifier for each process
- **Parent Process ID (PPID)**: ID of the process that created this process
- **User ID**: Owner of the process

#### 2. **Process State**
- Current state of the process (New, Ready, Running, Waiting, Terminated)

#### 3. **Program Counter**
- Address of the next instruction to be executed
- Critical for resuming process execution after interruption

#### 4. **CPU Registers**
- **Accumulator**: Stores intermediate results
- **Index Registers**: Used for addressing
- **Stack Pointers**: Points to the top of the stack
- **General Purpose Registers**: Store data and addresses
- Must be saved during context switch

#### 5. **CPU Scheduling Information**
- **Priority**: Process priority level
- **Scheduling Queue Pointers**: Pointers to scheduling queues
- **Scheduling Algorithm-specific Parameters**: Time quantum, burst time, etc.

#### 6. **Memory Management Information**
- **Base and Limit Registers**: Define memory boundaries
- **Page Tables**: For paging systems
- **Segment Tables**: For segmentation systems

#### 7. **Accounting Information**
- **CPU Time Used**: Total CPU time consumed
- **Time Limits**: Maximum allowed CPU time
- **Process Start Time**: When the process was created
- **Real Time Used**: Actual elapsed time

#### 8. **I/O Status Information**
- **List of Open Files**: Files currently being used
- **I/O Devices Allocated**: Devices assigned to this process
- **List of I/O Requests**: Pending I/O operations

### Importance of PCB

1. **Process Management**: OS uses PCB to track and manage all processes
2. **Context Switching**: PCB stores process state during context switches
3. **Multiprogramming**: Enables multiple processes to share CPU
4. **Process Scheduling**: Contains information needed for scheduling decisions
5. **Resource Allocation**: Tracks resources allocated to each process

> **Exam Tip**: PCB is like an "identity card" for a process - it contains all information the OS needs to manage that process.

---

## Process States

A process goes through different states during its lifetime. The number of states and their names may vary slightly across different operating systems, but the core concept remains the same.

### The Five-State Process Model

```
         ┌──────────┐
    ┌───→│   NEW    │
    │    └──────────┘
    │          │
    │          │ Admitted
    │          ↓
    │    ┌──────────┐  Scheduler    ┌──────────┐
    │    │  READY   │ ────Dispatch──→│ RUNNING  │
    │    └──────────┘               └──────────┘
    │          ↑                          │
    │          │                          │
    │          │ I/O or Event             │ Exit
    │          │  Completion              │
    │          │                          ↓
    │    ┌──────────┐               ┌──────────┐
    │    │ WAITING  │               │TERMINATED│
    │    └──────────┘               └──────────┘
    │          ↑                          │
    └──────────┴──────────────────────────┘
```

### 1. **NEW (Created)**

**Definition**: The process is being created by the OS.

**Characteristics**:
- Process is just created
- PCB is being initialized
- Resources are being allocated
- Not yet admitted to the pool of executable processes

**Example**: When you double-click an application icon, it enters the NEW state

---

### 2. **READY**

**Definition**: The process is waiting to be assigned to a processor for execution.

**Characteristics**:
- Process has all resources except CPU
- Loaded in main memory
- Waiting in the **Ready Queue**
- Can start execution when CPU becomes available
- Multiple processes can be in READY state simultaneously

**Example**: Multiple applications loaded in memory, waiting for their turn to use the CPU

**Ready Queue**: A queue data structure that holds all processes ready for execution

---

### 3. **RUNNING (Executing)**

**Definition**: The process currently being executed by the CPU.

**Characteristics**:
- Process is actually using the CPU
- Instructions are being executed
- Only **one process per CPU core** can be in RUNNING state
- In multi-core systems, multiple processes can run simultaneously (one per core)

**Duration**: A process stays in running state until:
- It completes execution
- Time quantum expires (in time-sharing systems)
- It requires I/O operation
- Higher priority process arrives

**Example**: The application actively using CPU cycles right now

---

### 4. **WAITING (Blocked)**

**Definition**: The process is waiting for some event to occur or I/O operation to complete.

**Characteristics**:
- Cannot execute even if CPU is available
- Waiting for external events:
  - I/O completion
  - User input
  - Signal from another process
  - Resource availability
- Stored in **Wait Queue** or **Device Queue**
- Multiple wait queues exist (one per event type)

**Example**: 
- A program waiting for user to input data from keyboard
- A process waiting for file to be read from disk
- A browser waiting for network response

---

### 5. **TERMINATED (Exit)**

**Definition**: The process has finished execution.

**Characteristics**:
- Process has completed its task
- Resources are being deallocated
- PCB is being removed
- Exit status is returned to parent process
- Memory is freed

**Reasons for Termination**:
- **Normal Exit**: Process completed successfully
- **Error Exit**: Process encountered an error
- **Fatal Error**: Serious error (division by zero, illegal instruction)
- **Killed by Another Process**: Terminated by parent or OS

**Example**: Closing an application or program finishing its execution

---

## Process State Transitions

### State Transition Events

| Transition | From State | To State | Trigger Event |
|------------|------------|----------|---------------|
| **Admitted** | NEW | READY | OS admits process into ready queue |
| **Dispatch** | READY | RUNNING | Scheduler selects process for execution |
| **Interrupt** | RUNNING | READY | Time quantum expires or higher priority process arrives |
| **I/O or Event Wait** | RUNNING | WAITING | Process requests I/O or waits for event |
| **I/O or Event Completion** | WAITING | READY | I/O operation completes or event occurs |
| **Exit** | RUNNING | TERMINATED | Process completes execution |

### Detailed Transition Descriptions

#### 1. **NEW → READY (Admitted)**
- **Trigger**: OS initialization completes
- **Action**: Process is loaded into memory and added to ready queue
- **Condition**: Sufficient memory and system resources available

#### 2. **READY → RUNNING (Dispatch)**
- **Trigger**: CPU scheduler selects this process
- **Action**: Process state changes to RUNNING, CPU starts executing instructions
- **Decision**: Based on scheduling algorithm (FCFS, SJF, Priority, etc.)

#### 3. **RUNNING → READY (Interrupt/Timeout)**
- **Trigger**: 
  - Time quantum expires (in Round Robin)
  - Higher priority process arrives (in Priority Scheduling)
  - CPU needs to handle an interrupt
- **Action**: Process moved back to ready queue
- **Note**: Process can resume execution later

#### 4. **RUNNING → WAITING (I/O or Event Wait)**
- **Trigger**: 
  - Process requests I/O operation (read file, print document)
  - Waiting for user input
  - Waiting for signal from another process
- **Action**: Process moved to wait queue associated with the event
- **Note**: Cannot use CPU until event completes

#### 5. **WAITING → READY (I/O or Event Completion)**
- **Trigger**: 
  - I/O operation completes
  - Event occurs
  - Resource becomes available
- **Action**: Process moved from wait queue to ready queue
- **Note**: Process can now compete for CPU again

#### 6. **RUNNING → TERMINATED (Exit)**
- **Trigger**: 
  - Process completes execution
  - Fatal error occurs
  - Process is killed
- **Action**: Resources deallocated, PCB removed

---

## Context Switching

### Definition
**Context Switch** is the process of saving the state of a currently running process and restoring the state of another process to resume its execution.

### Steps Involved in Context Switch

1. **Save Current Process State**
   - Save CPU registers to PCB of currently running process
   - Save Program Counter value
   - Save process state as READY or WAITING

2. **Update PCB**
   - Update process state
   - Update accounting information

3. **Move PCB**
   - Move current process to appropriate queue (Ready or Waiting)
   - Select next process from Ready queue

4. **Restore New Process State**
   - Load CPU registers from PCB of new process
   - Load Program Counter
   - Change process state to RUNNING

5. **Resume Execution**
   - CPU starts executing the new process

### Context Switch Time
- **Pure Overhead**: No useful work is done during context switch
- **Typical Duration**: Few milliseconds (1-10 ms)
- **Depends On**:
  - Hardware support
  - Memory speed
  - Number of registers to save
  - OS complexity

### Factors Affecting Context Switch Time

1. **Hardware Support**
   - Multiple register sets reduce switch time
   - Special context switch instructions

2. **Number of Registers**
   - More registers = more time to save/restore

3. **Memory Speed**
   - Faster memory = quicker save/restore operations

4. **Process Complexity**
   - More resources = more state to save

### When Does Context Switch Occur?

1. **Interrupt Handling**: Hardware or software interrupt
2. **Multitasking**: Time quantum expires in time-sharing systems
3. **User and Kernel Mode Switch**: Transition between modes
4. **I/O Operations**: Process waits for I/O completion
5. **Priority Changes**: Higher priority process becomes ready

### Context Switch vs Mode Switch

| Aspect | Context Switch | Mode Switch |
|--------|----------------|-------------|
| **Definition** | Switching between processes | Switching between user and kernel mode |
| **Scope** | Complete process state saved | Only privilege level changes |
| **Overhead** | High (several microseconds) | Low (minimal) |
| **PCB Change** | Yes | No |
| **Example** | Switching from Browser to Music Player | System call execution |

---

## Important Points for Exams

### Process Fundamentals
1. A **process** is a program in execution (active entity)
2. A **program** is passive code stored on disk
3. One program can create multiple processes

### PCB (Process Control Block)
1. PCB is a data structure containing all process information
2. Key components: PID, Process State, Program Counter, CPU Registers, Memory Info
3. Essential for context switching and process management
4. Each process has exactly one PCB

### Process States
1. Five main states: **NEW, READY, RUNNING, WAITING, TERMINATED**
2. Only processes in READY state can transition to RUNNING
3. Process in WAITING state cannot execute even if CPU is free
4. Only one process per CPU core can be in RUNNING state

### State Transitions
1. **NEW → READY**: Admitted (process loaded into memory)
2. **READY → RUNNING**: Dispatch (scheduler selects process)
3. **RUNNING → READY**: Interrupt/Timeout
4. **RUNNING → WAITING**: I/O or event wait
5. **WAITING → READY**: I/O or event completion
6. **RUNNING → TERMINATED**: Exit

### Context Switching
1. Context switch is **pure overhead** (no useful work done)
2. Context switch time depends on hardware support
3. Frequent context switches reduce CPU efficiency
4. Context switch saves entire process state in PCB

---

## Quick Revision Questions

### Short Answer Questions
1. Define a process. How is it different from a program?
2. What is Process Control Block (PCB)? List its main components.
3. Draw and explain the five-state process model.
4. What is context switching? Why is it considered overhead?

### Diagram-Based Questions
1. Draw the process state transition diagram with all transitions labeled.
2. Illustrate the memory layout of a process.
3. Show the structure of a Process Control Block.

### Conceptual Questions
1. Can a process in WAITING state transition directly to RUNNING state? Why or why not?
2. Why is only one process per CPU core allowed in RUNNING state?
3. What happens to the PCB when a context switch occurs?
4. Explain why context switch time should be minimized.

---
