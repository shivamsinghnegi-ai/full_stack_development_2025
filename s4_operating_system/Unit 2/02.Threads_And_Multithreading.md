# Part 2: Threads & Multithreading

---

## What is a Thread?

### Definition
A **thread** is the smallest unit of execution within a process. It is a lightweight process that can execute independently while sharing the same process resources.

### Key Characteristics
- **Lightweight**: Threads are lighter than processes
- **Shared Resources**: All threads of a process share the same memory space
- **Independent Execution**: Each thread has its own execution path
- **Part of a Process**: Threads cannot exist independently; they belong to a process

### Why Threads?
Traditional processes have a single thread of execution. Modern applications need to perform multiple tasks simultaneously:
- Web browser: Download files, render pages, run JavaScript simultaneously
- Word processor: Type text, check spelling, auto-save concurrently
- Media player: Decode audio, display video, handle user input at the same time

---

## Thread Components

Each thread has its own:

### 1. **Thread ID**
- Unique identifier for the thread within the process

### 2. **Program Counter (PC)**
- Points to the next instruction to execute
- Each thread tracks its own position in code

### 3. **Register Set**
- Thread-specific CPU registers
- Stores current working variables and intermediate results

### 4. **Stack**
- Thread-local stack for function calls
- Contains local variables, function parameters, return addresses
- Each thread has its own stack

### What Threads Share (From Parent Process)

Threads within the same process share:

1. **Code Section (Text Segment)**
   - All threads execute the same program code
   
2. **Data Section**
   - Global variables and static variables
   
3. **Heap**
   - Dynamically allocated memory
   
4. **Operating System Resources**
   - Open files
   - I/O devices
   - Signals

```
Process Memory Layout with Threads
+----------------------------------+
|                                  |
|    Thread 1    Thread 2          |
|    Stack       Stack             | ← Each thread has own stack
|      ↓           ↓               |
+----------------------------------+
|                                  |
|        Free Memory               |
|                                  |
+----------------------------------+
|              ↑                   |
|            Heap                  | ← Shared by all threads
+----------------------------------+
|        Data Section              | ← Shared by all threads
|      (Global/Static)             |
+----------------------------------+
|        Text Section              | ← Shared by all threads
|           (Code)                 |
+----------------------------------+
```

---

## Process vs Thread

| Aspect | Process | Thread |
|--------|---------|--------|
| **Definition** | Independent program in execution | Lightweight unit of execution within a process |
| **Memory** | Separate memory space | Shares memory with other threads |
| **Communication** | IPC (expensive) | Direct access to shared memory (cheap) |
| **Creation Time** | Slower (heavyweight) | Faster (lightweight) |
| **Context Switch** | Expensive (more overhead) | Cheaper (less overhead) |
| **Isolation** | Completely isolated | Not isolated (share resources) |
| **Termination** | Terminates all threads | Only that thread terminates |
| **Resources** | Independent resources | Shares process resources |
| **Example** | Two instances of Chrome | Multiple tabs in one Chrome instance |

### Advantages of Threads Over Processes

1. **Faster Creation**: Thread creation is 10-100 times faster than process creation
2. **Faster Termination**: Thread cleanup is quicker
3. **Faster Context Switching**: Less state to save/restore
4. **Efficient Communication**: Shared memory eliminates need for IPC
5. **Resource Sharing**: Automatic sharing of code, data, and files

### Disadvantages of Threads

1. **No Protection**: One thread can corrupt another thread's data
2. **Debugging Complexity**: Race conditions and synchronization bugs are harder to debug
3. **Process Crash**: If one thread crashes, entire process may crash
4. **No Isolation**: Security vulnerabilities in one thread affect all threads

---

## Benefits of Multithreading

### 1. **Responsiveness**
- Application remains responsive even during long operations
- Example: Word processor can accept input while printing document
- GUI applications respond to user while performing background tasks

### 2. **Resource Sharing**
- Threads automatically share process memory and resources
- No need for shared memory or message passing mechanisms
- Efficient communication between threads

### 3. **Economy**
- Creating and managing threads is cheaper than processes
- Context switching between threads is faster
- Less memory overhead

### 4. **Scalability**
- Process can take advantage of multiprocessor/multicore systems
- Different threads can run on different cores simultaneously
- True parallelism on multi-core systems

### Real-World Example: Web Server

**Single-Threaded Server**:
```
Client 1 request → Process → Response
                   ↓ (must wait)
Client 2 request → Process → Response
```

**Multi-Threaded Server**:
```
Client 1 request → Thread 1 → Response
                   ↓
Client 2 request → Thread 2 → Response  (concurrent)
                   ↓
Client 3 request → Thread 3 → Response  (concurrent)
```

---

## Types of Threads

Threads are classified based on who manages them:

### 1. User-Level Threads (ULT)

#### Definition
Threads managed by user-level thread library without kernel involvement. The kernel is unaware of these threads.

#### Characteristics

**Management**: 
- Thread library manages all thread operations
- Thread table maintained in user space
- Examples: POSIX Pthreads (in user mode), Mach C-threads, Solaris threads

**Kernel Awareness**:
- Kernel sees only a single-threaded process
- Kernel manages the process, not individual threads

**Thread Operations**:
- Thread creation, deletion, scheduling done in user space
- No system calls required for thread operations

#### Advantages of User-Level Threads

1. **Fast Thread Operations**
   - Creation, switching, termination are faster
   - No kernel mode switch required
   - No system call overhead

2. **Portable**
   - Can be implemented on any OS
   - Does not require kernel support

3. **Customizable Scheduling**
   - Application can implement its own scheduling algorithm
   - Thread scheduling is application-specific

4. **Scalable**
   - Can create thousands of threads
   - Not limited by kernel's thread limit

#### Disadvantages of User-Level Threads

1. **Blocking System Calls**
   - If one thread makes a blocking system call, entire process blocks
   - All threads stop executing
   - Example: If one thread does I/O, all threads must wait

2. **No True Parallelism**
   - Cannot take advantage of multicore systems
   - Kernel schedules only the process, not individual threads
   - All threads run on single CPU core

3. **Limited Scheduling**
   - Thread cannot be preempted by kernel
   - Cooperative scheduling only (threads must voluntarily yield)

4. **Page Fault Problem**
   - Page fault in one thread blocks entire process

```
User-Level Thread Model

User Space:
+------------------+
| Thread | Thread  |
|   1    |   2     | ← User threads
+------------------+
| Thread Library   | ← Manages threads in user space
+------------------+
        ↓
Kernel Space:
+------------------+
|  Single Process  | ← Kernel sees only one process
+------------------+
```

---

### 2. Kernel-Level Threads (KLT)

#### Definition
Threads managed directly by the operating system kernel. The kernel is fully aware of all threads.

#### Characteristics

**Management**:
- Kernel maintains thread table
- All thread operations require system calls
- Examples: Windows threads, Linux kernel threads (NPTL)

**Kernel Awareness**:
- Kernel knows about all threads
- Kernel schedules threads, not processes

**Thread Operations**:
- Thread creation, deletion performed by kernel
- Requires mode switch to kernel mode

#### Advantages of Kernel-Level Threads

1. **True Parallelism**
   - Different threads can run on different CPU cores simultaneously
   - Takes full advantage of multicore/multiprocessor systems

2. **No Blocking Problem**
   - If one thread blocks on I/O, other threads continue execution
   - Kernel can schedule another thread from same process

3. **Better Responsiveness**
   - Kernel can preempt threads
   - Higher priority threads can interrupt lower priority threads

4. **Kernel Routines Can Be Multithreaded**
   - Kernel itself can be designed to use threads

#### Disadvantages of Kernel-Level Threads

1. **Slow Thread Operations**
   - Thread creation, switching require system calls
   - Mode switching overhead (user → kernel → user)
   - Slower than user-level threads

2. **Limited Scalability**
   - Creating thousands of threads puts burden on kernel
   - Kernel resources are limited

3. **Operating System Dependent**
   - Implementation varies across operating systems
   - Less portable

```
Kernel-Level Thread Model

User Space:
+------------------+
| Thread | Thread  |
|   1    |   2     | ← User-visible threads
+------------------+
        ↓ System calls
Kernel Space:
+------------------+
| KThread| KThread |
|   1    |   2     | ← Kernel threads (one-to-one mapping)
+------------------+
| Kernel Scheduler | ← Schedules individual threads
+------------------+
```

---

### Comparison: User-Level vs Kernel-Level Threads

| Feature | User-Level Threads | Kernel-Level Threads |
|---------|-------------------|---------------------|
| **Management** | Thread library | Operating system kernel |
| **Kernel Awareness** | Kernel unaware | Kernel aware |
| **Speed** | Fast (no system calls) | Slow (system calls required) |
| **Context Switch** | Very fast | Slower |
| **Blocking Calls** | Blocks entire process | Blocks only that thread |
| **Multicore Support** | No true parallelism | True parallelism |
| **Scalability** | Highly scalable | Limited by kernel resources |
| **Portability** | Portable | OS-dependent |
| **Examples** | GNU Portable Threads, POSIX Pthreads (user mode) | Windows threads, Linux NPTL |

---

## Multithreading Models

Multithreading models define the relationship between user-level threads and kernel-level threads.

### 1. Many-to-One Model

#### Description
Many user-level threads are mapped to a single kernel thread.

```
User Threads:       Kernel Thread:
+----------+
| Thread 1 |─┐
+----------+ │
| Thread 2 |─┤
+----------+ ├──────→ +----------+
| Thread 3 |─┤        | KThread  |
+----------+ │        +----------+
| Thread 4 |─┘
+----------+
```

#### Characteristics
- Multiple user threads managed by thread library
- Kernel sees only one kernel thread (the process)
- Thread management done entirely in user space

#### Advantages
1. **Efficient Thread Management**: No kernel involvement
2. **Fast Operations**: Thread creation, switching very fast
3. **No Kernel Support Needed**: Can run on any OS

#### Disadvantages
1. **Blocking Problem**: One blocking system call blocks all threads
2. **No Parallelism**: Cannot run on multiple CPUs
3. **Single Point of Failure**: If kernel thread blocks, all user threads block

#### Examples
- Green threads (older Java implementations)
- GNU Portable Threads

---

### 2. One-to-One Model

#### Description
Each user thread is mapped to a separate kernel thread.

```
User Threads:       Kernel Threads:
+----------+        +----------+
| Thread 1 |───────→| KThread1 |
+----------+        +----------+
| Thread 2 |───────→| KThread2 |
+----------+        +----------+
| Thread 3 |───────→| KThread3 |
+----------+        +----------+
| Thread 4 |───────→| KThread4 |
+----------+        +----------+
```

#### Characteristics
- Each user thread has corresponding kernel thread
- Kernel manages all threads
- One-to-one mapping

#### Advantages
1. **True Concurrency**: Different threads run on different CPUs
2. **No Blocking Issue**: One thread blocking doesn't affect others
3. **Better Responsiveness**: Kernel-level preemption

#### Disadvantages
1. **Overhead**: Creating user thread requires creating kernel thread
2. **Limited Threads**: Number of threads limited by kernel resources
3. **Performance**: Thread operations slower due to system calls

#### Examples
- Windows operating system
- Linux (Native POSIX Thread Library - NPTL)
- Modern implementations of Java threads

---

### 3. Many-to-Many Model

#### Description
Many user threads are multiplexed to a smaller or equal number of kernel threads.

```
User Threads:       Kernel Threads:
+----------+
| Thread 1 |─┐      +----------+
+----------+ ├─────→| KThread1 |
| Thread 2 |─┘      +----------+
+----------+─┐
| Thread 3 | ├─────→+----------+
+----------+─┘      | KThread2 |
| Thread 4 |─┐      +----------+
+----------+ ├─────→+----------+
| Thread 5 |─┘      | KThread3 |
+----------+        +----------+
```

#### Characteristics
- M user threads mapped to N kernel threads (M ≥ N)
- Thread library multiplexes user threads onto kernel threads
- Flexible mapping

#### Advantages
1. **Best of Both Worlds**: Combines benefits of user and kernel threads
2. **Scalability**: Can create many user threads
3. **Concurrency**: Multiple kernel threads provide parallelism
4. **Flexibility**: Application can create as many threads as needed
5. **No Blocking**: Kernel can schedule another kernel thread if one blocks

#### Disadvantages
1. **Complex Implementation**: Difficult to implement
2. **Coordination Overhead**: Thread library and kernel must cooperate
3. **Less Common**: Not widely implemented

#### Examples
- Older versions of Solaris (up to Solaris 9)
- HP-UX
- Tru64 UNIX

---

### 4. Two-Level Model (Hybrid)

#### Description
Variation of Many-to-Many model that allows both many-to-many and one-to-one mappings.

```
User Threads:       Kernel Threads:
+----------+
| Thread 1 |─┐      +----------+
+----------+ ├─────→| KThread1 |
| Thread 2 |─┘      +----------+
+----------+
| Thread 3 |───────→+----------+
+----------+        | KThread2 | (bound thread)
| Thread 4 |─┐      +----------+
+----------+ ├─────→+----------+
| Thread 5 |─┘      | KThread3 |
+----------+        +----------+
```

#### Characteristics
- Similar to Many-to-Many
- Allows user threads to be **bound** to specific kernel thread
- Some threads get dedicated kernel thread

#### Advantages
1. **Flexibility**: Important threads can be bound to kernel threads
2. **Critical Tasks**: Time-critical threads get guaranteed kernel support
3. **Efficiency**: Less critical threads share kernel threads

#### Examples
- Solaris (with bound threads)
- IRIX
- HP-UX

---

## Thread States

Similar to processes, threads also have states:

### Five Thread States

```
         ┌──────────┐
    ┌───→│   NEW    │
    │    └──────────┘
    │          │
    │     Created
    │          ↓
    │    ┌──────────┐  Dispatch    ┌──────────┐
    │    │  READY   │─────────────→│ RUNNING  │
    │    └──────────┘              └──────────┘
    │          ↑                          │
    │          │                          │
    │     Unblocked              Block/Preempt
    │          │                          │
    │    ┌──────────┐                     │
    │    │ BLOCKED  │←────────────────────┘
    │    └──────────┘
    │          ↑
    │          │
    │    ┌──────────┐
    └────│TERMINATED│
         └──────────┘
```

### State Descriptions

1. **NEW**: Thread is being created but not yet started
2. **READY**: Thread is ready to run, waiting for CPU
3. **RUNNING**: Thread is currently executing
4. **BLOCKED**: Thread is waiting for event (I/O, lock, etc.)
5. **TERMINATED**: Thread has finished execution

---

## Thread Operations

### 1. **Thread Creation**

**Purpose**: Create a new thread within the process

**What Happens**:
- Allocate thread ID
- Allocate thread stack
- Initialize program counter
- Thread starts executing from specified function

---

### 2. **Thread Termination**

**Purpose**: End thread execution

**Methods**:
- **Normal termination**: Thread completes its task
- **Explicit exit**: Thread calls exit function
- **Cancellation**: Thread is cancelled by another thread
- **Process termination**: All threads terminated when process exits

---

### 3. **Thread Join**

**Purpose**: Wait for another thread to complete

**Behavior**:
- Calling thread blocks until target thread terminates
- Ensures proper sequencing of operations

**Example**:
```
Main thread creates worker thread
Main thread calls join() on worker thread
Main thread waits until worker completes
Main thread continues after worker terminates
```

---

### 4. **Thread Yield**

**Purpose**: Voluntarily give up CPU to another thread

**Behavior**:
- Thread moves from RUNNING to READY state
- Allows other threads to execute
- Used in cooperative multitasking

---

## Important Points for Exams

### Threads Fundamentals
1. **Thread** = Lightweight process, smallest unit of execution
2. Threads share: Code, Data, Heap, Files
3. Threads have separate: Thread ID, PC, Registers, Stack
4. Thread creation is **10-100x faster** than process creation

### Thread Types
1. **User-Level Threads**: Fast but no true parallelism, blocking problem
2. **Kernel-Level Threads**: Slow but true parallelism, no blocking issue
3. ULT managed by **thread library**, KLT managed by **kernel**

### Multithreading Models
1. **Many-to-One**: M:1 mapping, efficient but blocking problem
2. **One-to-One**: 1:1 mapping, true parallelism but overhead
3. **Many-to-Many**: M:N mapping, best of both worlds
4. **Two-Level**: Hybrid model, allows bound threads

### Multithreading Benefits
1. **Responsiveness**: Application remains responsive
2. **Resource Sharing**: Automatic sharing of memory
3. **Economy**: Cheaper than processes
4. **Scalability**: Utilizes multicore systems

### Challenges
1. **fork()**: Duplicate all threads or only calling thread?
2. **Thread Cancellation**: Asynchronous vs Deferred
3. **Signal Handling**: Which thread receives signal?
4. **Thread Pools**: Reuse threads for efficiency
5. **Thread-Specific Data**: Each thread's private data

---

## Quick Revision Questions

### Short Answer Questions
1. What is a thread? How is it different from a process?
2. What resources do threads share within a process?
3. Explain user-level threads and kernel-level threads with advantages and disadvantages.
4. List four benefits of multithreading.

### Diagram-Based Questions
1. Draw and explain the Many-to-One multithreading model.
2. Draw and explain the One-to-One multithreading model.
3. Illustrate the memory layout of a process with multiple threads.
4. Draw the thread state transition diagram.

### Conceptual Questions
1. Why is thread creation faster than process creation?
2. Why do user-level threads suffer from the blocking problem?
3. Compare Many-to-Many and One-to-One multithreading models.
4. What is the purpose of a thread pool?
5. Explain the fork() problem in multithreaded programs.

### Comparison Questions
1. Compare user-level threads and kernel-level threads.
2. Compare processes and threads.
3. Compare asynchronous and deferred thread cancellation.

---

