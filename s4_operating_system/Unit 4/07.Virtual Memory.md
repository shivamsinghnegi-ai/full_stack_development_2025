# VIRTUAL MEMORY

### 1. Concept

**Definition:** Virtual memory is a technique that allows execution of processes that are **not completely in memory.**

```
Key Idea:
Logical Address Space >> Physical Address Space
(Program's view)          (Actual RAM)
```

**Benefits:**
- Programs can be **larger than physical memory**
- More programs can run simultaneously
- Less I/O needed (only load what's used)
- Efficient use of memory

---

### 2. Virtual Address Space

```
Virtual Memory (Logical View)    Physical Memory
┌──────────────────┐             ┌────────────┐
│  Code   (0-4KB)  │◄────────────│  Frame 0   │ ← In RAM
├──────────────────┤             ├────────────┤
│  Data   (4-8KB)  │◄────────────│  Frame 1   │ ← In RAM
├──────────────────┤             ├────────────┤
│  Heap   (8-12KB) │             │  Frame 2   │   Free
├──────────────────┤             └────────────┘
│      ...         │
│  (not in memory) │◄─────────── Disk (Swap)
├──────────────────┤
│  Stack (100KB)   │◄────────────  Disk (Swap)
└──────────────────┘
```

Large virtual space, only some pages actually in RAM.

---

### 3. Demand Paging

**Principle:** Bring a page into memory **only when it is needed** (demanded).

**"Lazy Loading"** - Don't load what you don't need!

```
Process starts
     ↓
No pages in memory (or very few)
     ↓
CPU tries to execute instruction
     ↓
References a page
     ↓
Is page in RAM?
 ↙         ↘
YES         NO → Page Fault → Load from disk
 ↓
Continue
```

---

### 4. Valid-Invalid Bit

Each page table entry has an extra bit:

```
Page Table Entry:
┌────────────┬──────────────────┐
│ Frame Num  │  Valid/Invalid   │
└────────────┴──────────────────┘
                    │
              1 = Valid (page in RAM)
              0 = Invalid (page on disk or not used)
```

**Complete Page Table Example:**

```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Page # │ Frame # │ V/I │ Dirty │ Referenced
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  0    │    4    │  V  │   0   │     1
  1    │    -    │  I  │   0   │     0      ← On disk
  2    │    6    │  V  │   1   │     1
  3    │    -    │  I  │   0   │     0      ← On disk
  4    │    -    │  I  │   0   │     0      ← On disk
  5    │    9    │  V  │   0   │     1
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

V = In RAM   I = On Disk (will cause page fault)
Dirty = Page was modified (needs write-back to disk)
```

---

### 5. Page Fault Handling - Detailed Steps

**Page Fault:** Occurs when CPU references a page with Invalid bit.

```
COMPLETE PAGE FAULT HANDLING PROCEDURE:

Step 1:  CPU generates address → Page table check
Step 2:  Valid bit = 0 → PAGE FAULT (trap to OS)
Step 3:  OS saves CPU registers, process state (PCB)
Step 4:  OS determines it was a page fault
Step 5:  OS checks if reference was legal:
            - Illegal reference → Abort process
            - Legal reference → Continue
Step 6:  OS finds a free frame (from free-frame list)
Step 7:  OS schedules disk operation to read page:
            - Find page location on disk
            - Read page into the free frame
Step 8:  Wait for disk I/O to complete (process blocked)
Step 9:  OS updates page table:
            - Set frame number
            - Set valid bit = 1
Step 10: Process moves back to ready queue
Step 11: CPU restarts the faulted instruction
Step 12: Process accesses the page normally
```

**Diagram:**

```
     Process P1 executing
           ↓
     Memory Reference
           ↓
     Valid bit = 0
           ↓
     PAGE FAULT! → Trap to OS
           ↓
     Save Process State
           ↓
     Legal reference?
      ↙         ↘
    NO            YES
     ↓              ↓
  Abort        Find free frame
  Process           ↓
                Read page from disk
                    ↓
                Update page table
                    ↓
                Restart instruction
                    ↓
                Continue execution
```

---

### 6. Pure Demand Paging

**Concept:** Start executing process with **ZERO pages** in memory.

- First instruction → Page fault (load page)
- Second instruction → May page fault again
- Eventually: Enough pages loaded, faults decrease
- **Working Set** of pages gets established in memory

**Property:**
- Every page brought in only when actually needed
- No unnecessary loading

**Performance:**
- High initial page faults
- Page faults decrease over time
- Steady state: low page fault rate

---

### 7. Prepaging

**Concept:** Load pages **before** they are referenced.

```
Without Prepaging:
Reference Page 5 → Fault → Load Page 5 only
Next reference: Page 6 → Fault → Load Page 6
...many faults

With Prepaging:
Reference Page 5 → Load Pages 4,5,6,7 together
Next references: Pages 4,6,7 → Already in RAM!
...fewer faults
```

**Based on:** Principle of Locality (spatial locality - nearby pages likely needed)

**Trade-off:**
```
Pages actually used × 100
─────────────────────────── = Prepaging efficiency
  Pages prepaged (extra)
```

If efficiency low → Prepaging is wasteful.

---

### 8. Copy-on-Write (COW)

**Problem:** `fork()` system call creates child process. Copying all parent pages is expensive!

**Solution - COW:**
Pages shared between parent and child initially.
Copying happens **only when a page is written to.**

```
BEFORE any write:
┌────────────┐                    ┌─────────────┐
│  Parent    │                    │   Child     │
│  Page A ──┼────── shared ──────┼── Page A    │
│  Page B ──┼────── shared ──────┼── Page B    │
│  Page C ──┼────── shared ──────┼── Page C    │
└────────────┘                    └─────────────┘

AFTER Child writes to Page B:
┌────────────┐                    ┌─────────────┐
│  Parent    │                    │   Child     │
│  Page A ──┼────── shared ──────┼── Page A    │
│  Page B   │ (original)         │   Page B'   │ ← NEW COPY
│  Page C ──┼────── shared ──────┼── Page C    │
└────────────┘                    └─────────────┘
```

**Pages marked:** COW bit = 1 (shared, copy if written)

**Advantages:**
- ✓ `fork()` is very fast (no actual copying)
- ✓ If child does `exec()` immediately, no copying needed at all!
- ✓ Memory saved (shared pages)
- ✓ Only modified pages copied (efficient)

---

### 9. Memory-Mapped Files

**Concept:** Map a file's disk blocks directly to virtual memory pages.

```
File on Disk:                Virtual Memory:
┌──────────┐                 ┌─────────────┐
│ Block 0  │ ←── mapping ──→ │   Page 10   │
│ Block 1  │ ←── mapping ──→ │   Page 11   │
│ Block 2  │ ←── mapping ──→ │   Page 12   │
└──────────┘                 └─────────────┘
```

- Reading file = Reading memory (fast!)
- Writing memory = Writing to file
- Multiple processes can map **same file** → Shared memory!

---
