## Virtual Memory

### What is Virtual Memory?

**Definition:** Technique that allows execution of processes that are not completely in memory.

**Key Idea:** 
- Logical address space can be much larger than physical address space
- Only part of program needs to be in memory for execution

### Why Virtual Memory?

**Problems it solves:**
1. Program size limited by physical memory
2. Entire program must be in memory
3. Large programs cannot run

**Benefits:**
- Programs can be larger than physical memory
- More programs can run simultaneously
- Less I/O needed to swap processes

### Virtual Address Space

```
Virtual Memory (Logical)     Physical Memory (RAM)
|    Code      | 0 KB         |  Frame 0  | ← Page 5
|    Data      | 4 KB         |  Frame 1  | ← Page 2
|    Heap      | 8 KB         |  Frame 2  | ← Page 0
|              | 12 KB        |  Frame 3  | (Free)
|    Stack     | 100 KB       ↓
                           Disk (Swap space)
                           |  Page 1   |
                           |  Page 3   |
                           |  Page 4   |
```

### Demand Paging

**Principle:** Load pages only when they are demanded (needed).

**How it works:**
1. Process starts with no pages in memory
2. When page is referenced, page fault occurs
3. OS loads the required page from disk
4. Process continues execution

### Valid-Invalid Bit in Page Table

```
Page Table
Page # | Frame # | Valid/Invalid
-------|---------|---------------
  0    |    2    |     V (1)
  1    |    -    |     I (0)
  2    |    1    |     V (1)
  3    |    -    |     I (0)
  4    |    -    |     I (0)
  5    |    0    |     V (1)
```

- **Valid (V or 1):** Page is in memory
- **Invalid (I or 0):** Page not in memory (on disk)

### Page Fault Handling

**Page Fault:** Reference to a page not in memory

**Steps to handle page fault:**

```
1. Check internal table (PCB) → Valid or invalid reference?
2. If invalid reference → Abort process
3. If valid but not in memory:
   a. Find free frame
   b. Read page from disk to frame
   c. Update page table (set valid bit)
   d. Restart instruction
```

**Diagram:**
```
    Instruction references page
              ↓
         Page in memory?
              ↓
         No (Page fault!)
              ↓
    Trap to operating system
              ↓
    Find free frame
              ↓
    Read page from disk
              ↓
    Update page table
              ↓
    Restart instruction
```

### Pure Demand Paging

**Concept:** Start process with NO pages in memory

**Process:**
1. Set all valid bits to invalid
2. First instruction causes page fault
3. Bring required page
4. Continue until sufficient pages loaded

**Advantage:** Never brings a page that is not needed
**Disadvantage:** High page faults initially

### Prepaging

**Concept:** Load multiple pages before they are referenced

**Process:**
- Bring in adjacent pages along with requested page
- Based on **locality of reference**

**Advantage:** Reduces page faults
**Disadvantage:** May bring unnecessary pages

### Copy-on-Write (COW)

**Problem:** When creating child process (fork), copying all pages is expensive

**Solution - Copy-on-Write:**
1. Parent and child initially share same pages
2. Pages marked as copy-on-write
3. If either process writes to page:
   - Create copy of that page
   - Give copy to writing process

```
Parent Process        Initially        Child Process
|  Page A  | ←----  shared pages  ---→ |  Page A  |
|  Page B  |                            |  Page B  |

After Child writes to Page A:
Parent Process                    Child Process
|  Page A  | (original)           |  Page A' | (copy)
|  Page B  | ←---- shared ----→  |  Page B  |
```

**Advantages:**
✓ Faster process creation
✓ Uses less memory
✓ Copy only when needed

### Memory-Mapped Files

**Concept:** Treating file I/O as routine memory access

- Map disk block to page in memory
- Read file → Read from memory
- Write to memory → Write to file

**Advantages:**
✓ Simplifies file access
✓ Multiple processes can share same file
✓ Efficient for large files

---
