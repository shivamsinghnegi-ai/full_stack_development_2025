# Memory Management Fundamentals

## 1. Introduction to Memory Management

### What is Memory Management?
**Memory Management** is the process of controlling and coordinating computer memory, assigning portions called blocks to various running programs to optimize overall system performance.

### Goals of Memory Management
1. **Relocation** - Programs can be loaded anywhere in memory
2. **Protection** - Prevent processes from accessing each other's memory
3. **Sharing** - Allow controlled sharing of memory between processes
4. **Logical Organization** - Support modular programming
5. **Physical Organization** - Manage memory hierarchy efficiently

### Address Binding
**Address Binding** = Mapping logical addresses to physical addresses

**Three Types:**
1. **Compile Time** - Physical address known at compile time (absolute code)
2. **Load Time** - Physical address assigned when program is loaded
3. **Execution Time** - Address can change during execution (needs hardware support)

### Logical vs Physical Address
- **Logical Address (Virtual Address)** - Generated by CPU, used by program
- **Physical Address** - Actual address in RAM
- **MMU (Memory Management Unit)** - Hardware that converts logical to physical addresses

---

## 2. Multiprogramming with Fixed Partitions

### Concept
Memory is divided into **fixed-size partitions** at system startup. Each partition can hold one process.

### Types of Fixed Partitioning

#### A. Equal-Size Partitions
- All partitions are of **same size**
- **Advantage:** Simple to implement
- **Disadvantage:** Internal fragmentation, small programs waste space

#### B. Unequal-Size Partitions
- Partitions of **different sizes**
- Better memory utilization
- Reduces internal fragmentation

### Partition Allocation Strategies

**1. Single Queue**
- One queue for all processes
- Process assigned to **smallest available partition** that fits

**2. Multiple Queues**
- Separate queue for each partition
- Process joins queue of **suitable partition size**

### Advantages
✓ Simple to implement
✓ Minimal OS overhead
✓ Fast process switching

### Disadvantages
✗ **Internal Fragmentation** - Unused space within partition
✗ Limited number of processes
✗ Fixed partition sizes inflexible
✗ Small programs waste memory

### Important Formula
```
Internal Fragmentation = Partition Size - Process Size
```

---

## 3. Dynamic Partitioning

### Concept
Partitions are created **dynamically** based on process requirements. Each process gets **exactly** the memory it needs.

### Advantages
✓ No internal fragmentation
✓ Better memory utilization
✓ Flexible partition sizes

### Disadvantages
✗ **External Fragmentation** - Free memory scattered in small holes
✗ Complex memory management
✗ Compaction needed

---

## 4. Fragmentation

### Internal Fragmentation
- **Wasted space INSIDE** allocated partition
- Occurs in **Fixed Partitioning**
- Example: Process needs 3MB, gets 4MB partition → 1MB wasted

### External Fragmentation
- **Wasted space BETWEEN** partitions (small holes)
- Occurs in **Dynamic Partitioning**
- Total free memory sufficient but not contiguous
- **Solution:** Compaction (moving processes to create larger free block)

### Comparison Table
| Feature | Internal Fragmentation | External Fragmentation |
|---------|----------------------|----------------------|
| Location | Inside partition | Between partitions |
| Occurs in | Fixed Partitioning | Dynamic Partitioning |
| Solution | Use smaller partitions | Compaction |

---

## 5. Swapping

### Definition
**Swapping** = Moving entire process between **main memory** and **backing store (disk)** temporarily.

### Swapping Process
```
Main Memory ←→ Backing Store (Disk)

SWAP OUT: Move process from RAM to Disk
SWAP IN: Move process from Disk to RAM
```

### When Swapping Occurs
- When memory is full
- To bring higher priority process
- Process waiting for I/O
- To prevent deadlock

### Components
1. **Swap Out** - Remove process from memory to disk
2. **Swap In** - Load process from disk to memory
3. **Backing Store** - Fast disk area for swapped processes

### Swapping Time Calculation

**Total Swap Time = Swap Out Time + Swap In Time**
```
Swap Time = (Process Size / Transfer Rate)

Example:
Process Size = 100 MB
Transfer Rate = 50 MB/s
Swap Out Time = 100/50 = 2 seconds
Swap In Time = 100/50 = 2 seconds
Total = 4 seconds
```

### Context Switch Time with Swapping
```
Total Time = Swap Out + Swap In + Context Switch Overhead
```

### Advantages
✓ Supports multiprogramming
✓ Higher degree of multiprogramming
✓ Better CPU utilization
✓ Allows larger processes than physical memory

### Disadvantages
✗ High overhead (disk I/O is slow)
✗ Increases context switch time
✗ Backing store required
✗ Not suitable for real-time systems

### Important Points for Exam
- Swapping moves **entire process**, not just pages
- **Medium-term scheduler** controls swapping
- Process must be **idle** (not running) to swap out
- Modern systems use **paging** instead of pure swapping

---

## 6. Memory Allocation Strategies (Dynamic Partitioning)

When a process requests memory, OS must choose from available holes:

### First Fit
- Allocate **first hole** that is large enough
- **Fast** - stops searching once suitable hole found
- May leave small holes at beginning

### Best Fit
- Allocate **smallest hole** that fits the process
- Searches entire list
- Produces **smallest leftover hole**
- **Slow** - must search entire list

### Worst Fit
- Allocate **largest available hole**
- Produces **largest leftover hole**
- Useful for future large processes
- **Slow** - must search entire list

### Comparison Table
| Algorithm | Speed | Leftover Hole | Memory Utilization |
|-----------|-------|---------------|-------------------|
| First Fit | Fastest | Medium | Good |
| Best Fit | Slowest | Smallest | Best |
| Worst Fit | Slowest | Largest | Worst |

**Exam Tip:** First Fit is generally fastest and most commonly used.

---

## Important Exam Questions & Answers

### Q1. Difference between Fixed and Dynamic Partitioning

| Fixed Partitioning | Dynamic Partitioning |
|-------------------|---------------------|
| Partitions created at boot time | Partitions created as needed |
| Fixed size partitions | Variable size partitions |
| Internal fragmentation | External fragmentation |
| Simple implementation | Complex implementation |
| Limited flexibility | Flexible |

### Q2. Difference between Swapping and Paging

| Swapping | Paging |
|----------|--------|
| Entire process moved | Only pages moved |
| Contiguous memory needed | Non-contiguous allowed |
| Higher overhead | Lower overhead |
| Simple | Complex |
| External fragmentation | No external fragmentation |

### Q3. What is the difference between logical and physical address?
- **Logical:** Generated by CPU, used by program (virtual)
- **Physical:** Actual RAM address
- **MMU** converts logical → physical

### Q4. Calculate internal fragmentation
```
Process size = 18 KB
Partition size = 20 KB
Internal Fragmentation = 20 - 18 = 2 KB
```
---

## Common Numerical Problems

### Problem 1: Internal Fragmentation
**Q:** Process of 7KB allocated to 10KB partition. Calculate internal fragmentation.
**A:** 10KB - 7KB = **3KB**

### Problem 2: Swapping Time
**Q:** Process size 200MB, transfer rate 40MB/s. Calculate total swap time.
**A:** 
- Swap out = 200/40 = 5s
- Swap in = 200/40 = 5s
- Total = **10 seconds**

---
