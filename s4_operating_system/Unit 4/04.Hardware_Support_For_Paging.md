## Hardware Support for Paging

### Challenges Without Hardware Support

1. Page table access requires memory access
2. Data access requires another memory access
3. **Result:** 2 memory accesses for 1 data access (slow!)

### 1. Translation Look-aside Buffer (TLB)

#### What is TLB?
- **Fast associative cache memory**
- Stores recent page-to-frame mappings
- Also called: **Associative Memory**

#### TLB Structure
```
| Page # | Frame # |
|--------|---------|
|   5    |    8    |
|   2    |    3    |
|   7    |    1    |
```

#### How TLB Works

```
CPU generates logical address
         ↓
    Check TLB (parallel search)
         ↓
    ┌────────────┐
    │ TLB Hit?   │
    └────────────┘
      ↙        ↘
   YES         NO
    ↓           ↓
Use frame #   Search Page Table
from TLB      (memory access)
              ↓
              Update TLB
```

### TLB Performance Calculation

**Important Formulas:**

```
Hit Ratio (α) = % of times page # found in TLB

Effective Access Time (EAT) = α × (TLB access + Memory access)
                              + (1-α) × (TLB access + Page table access + Memory access)

Simplified:
EAT = α × (T + M) + (1-α) × (T + M + M)
    = α × (T + M) + (1-α) × (T + 2M)

Where:
T = TLB access time
M = Memory access time
```

### Example Problem: TLB

**Given:**
- TLB access time = 20 ns
- Memory access time = 100 ns
- TLB hit ratio = 80%

**Find:** Effective Access Time

**Solution:**
```
EAT = 0.8 × (20 + 100) + 0.2 × (20 + 100 + 100)
    = 0.8 × 120 + 0.2 × 220
    = 96 + 44
    = 140 ns
```

**Without TLB:** 200 ns (page table + data)
**With TLB:** 140 ns
**Speedup:** 30% faster

### 2. Page Table Structure

#### Problem with Simple Page Table
- For 32-bit address space with 4KB pages
- Page table size = 2^20 entries × 4 bytes = 4MB per process!

#### Solutions:

### A. Hierarchical (Multi-level) Paging

**Two-Level Paging:**

```
Logical Address:
| P1 (outer) | P2 (inner) | Offset |

Page Directory → Page Table → Physical Memory
```

**Advantages:**
- Page table need not be contiguous
- Only active portions loaded

**Example: 32-bit address, 4KB page**
```
Offset = 12 bits (4KB = 2^12)
Remaining = 20 bits for page number
Split: 10 bits (P1) + 10 bits (P2)

Outer page table = 2^10 = 1024 entries
Each inner page table = 2^10 = 1024 entries
```

### B. Hashed Page Tables

- Page number hashed
- Hash table contains linked list of pages
- Used for address spaces > 32 bits

### C. Inverted Page Tables

- **One entry per physical frame** (not per page!)
- Each entry: `(process-id, page-number)`
- Reduces memory for page table
- Increases lookup time (need to search)

**Comparison:**
```
Traditional: One entry per logical page → Large table
Inverted: One entry per physical frame → Small table
```

---
## Practice Problems

### Problem 1
Logical address space = 64 pages, Page size = 512 bytes
Logical address = 10240
Page 20 is in Frame 15
**Find:** Physical address

### Problem 2
Memory access time = 80 ns, TLB access = 10 ns
Hit ratio = 90%
**Find:** EAT with and without TLB

### Problem 3
4 processes: 40KB, 10KB, 20KB, 50KB
Total frames = 60
**Calculate:** Frames allocated to each (proportional allocation)

---
