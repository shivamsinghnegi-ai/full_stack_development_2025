# Page Replacement Algorithms

## 1. Need for Page Replacement

### When is Page Replacement Needed?

**Scenario:**
- Page fault occurs
- Process needs a page from disk
- **All frames are occupied** (memory full)
- Must **remove (replace)** an existing page to make space
```
Memory Full Situation
┌─────────┐
│ Frame 0 │ ← Occupied
├─────────┤
│ Frame 1 │ ← Occupied
├─────────┤
│ Frame 2 │ ← Occupied
├─────────┤
│ Frame 3 │ ← Occupied
└─────────┘
         ↓
    NEW PAGE NEEDED!
         ↓
   Which page to replace?
   → Use replacement algorithm
```

### Page Replacement Process
```
Step 1: Page fault occurs (page not in memory)
         ↓
Step 2: Find the page on disk
         ↓
Step 3: Check for free frame
         ↓
    ┌────┴────┐
    │         │
 Free?      No Free
    │         │
    ↓         ↓
Load page  SELECT VICTIM PAGE
           (Use replacement algorithm)
                ↓
           Write victim to disk (if modified)
                ↓
           Load new page into freed frame
                ↓
           Update page tables
```

### Modified (Dirty) Bit

**Modified Bit** = Indicates if page has been **changed** since loading
```
Modified Bit = 0: Page NOT changed
              → No need to write back to disk
              → Just overwrite it
              → FASTER

Modified Bit = 1: Page has been changed (dirty)
              → MUST write back to disk first
              → Then load new page
              → SLOWER (2 disk I/Os)
```

### Goal of Page Replacement Algorithms

**Minimize page fault rate** = Select victim page that will minimize future page faults

---

## 2. FIFO (First-In-First-Out)

### Concept
**FIFO** = Replace the **oldest page** (first loaded page) in memory

### Algorithm
- Maintain a **queue** of pages in order of arrival
- When replacement needed → Remove page at **front of queue** (oldest)
- New page added at **rear of queue**

### Implementation
```
Queue maintains order of page arrival
Front → [P1] [P2] [P3] [P4] ← Rear
         ↑
    Replace this (oldest)
```

### Example 1: FIFO

**Given:**
- Reference String: **7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2**
- Number of Frames: **3**

**Solution:**
```
Page   Frames          Page Fault?
Ref    [F0] [F1] [F2]
---    ---------------  -----------
7      [7]  [ ]  [ ]    ✓ (Fault 1)
0      [7]  [0]  [ ]    ✓ (Fault 2)
1      [7]  [0]  [1]    ✓ (Fault 3)
2      [2]  [0]  [1]    ✓ (Fault 4) - Replace 7 (oldest)
0      [2]  [0]  [1]    ✗ (Hit)
3      [2]  [3]  [1]    ✓ (Fault 5) - Replace 0 (oldest)
0      [2]  [3]  [0]    ✓ (Fault 6) - Replace 1 (oldest)
4      [4]  [3]  [0]    ✓ (Fault 7) - Replace 2 (oldest)
2      [4]  [2]  [0]    ✓ (Fault 8) - Replace 3 (oldest)
3      [4]  [2]  [3]    ✓ (Fault 9) - Replace 0 (oldest)
0      [0]  [2]  [3]    ✓ (Fault 10) - Replace 4 (oldest)
3      [0]  [2]  [3]    ✗ (Hit)
2      [0]  [2]  [3]    ✗ (Hit)

Total Page Faults: 10
Total References: 13
Page Fault Rate: 10/13 = 76.9%
```

### Step-by-Step Explanation
```
Initial: [ ][ ][ ]  Empty frames

7:  [7][ ][ ]  → Load 7 (Fault)
0:  [7][0][ ]  → Load 0 (Fault)
1:  [7][0][1]  → Load 1 (Fault) - All frames full now
2:  [2][0][1]  → Replace 7 (oldest), Load 2 (Fault)
0:  [2][0][1]  → 0 already present (Hit)
3:  [2][3][1]  → Replace 0 (oldest), Load 3 (Fault)
... and so on
```

### Advantages of FIFO
✓ **Simple** to understand and implement
✓ **Fair** - all pages get equal opportunity
✓ **Low overhead** - just maintain a queue

### Disadvantages of FIFO
✗ **Poor performance** - may replace frequently used pages
✗ **Suffers from Belady's Anomaly** (explained later)
✗ **Ignores page usage** - oldest ≠ least useful

---

## 3. Optimal Page Replacement (OPT)

### Concept
**Optimal** = Replace the page that will **not be used for the longest time** in the future

### Algorithm
- Look **ahead** in reference string
- Replace page with **longest future distance**
- If page never used again → Replace it first

### Example 2: Optimal Algorithm

**Given:**
- Reference String: **7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2**
- Number of Frames: **3**

**Solution:**
```
Page   Frames          Page Fault?  Decision Logic
Ref    [F0] [F1] [F2]
---    ---------------  -----------  ---------------
7      [7]  [ ]  [ ]    ✓ (Fault 1)
0      [7]  [0]  [ ]    ✓ (Fault 2)
1      [7]  [0]  [1]    ✓ (Fault 3)
2      [7]  [0]  [2]    ✓ (Fault 4)  Replace 1 (used at pos 13, farthest)
0      [7]  [0]  [2]    ✗ (Hit)
3      [3]  [0]  [2]    ✓ (Fault 5)  Replace 7 (never used again)
0      [3]  [0]  [2]    ✗ (Hit)
4      [3]  [0]  [4]    ✓ (Fault 6)  Replace 2 (used at pos 12)
2      [3]  [0]  [2]    ✓ (Fault 7)  Replace 4 (never used again)
3      [3]  [0]  [2]    ✗ (Hit)
0      [3]  [0]  [2]    ✗ (Hit)
3      [3]  [0]  [2]    ✗ (Hit)
2      [3]  [0]  [2]    ✗ (Hit)

Total Page Faults: 7
Total References: 13
Page Fault Rate: 7/13 = 53.8%
```

### Decision at Position 4 (Reference = 2)
```
Current frames: [7][0][1]
Future references: 0, 3, 0, 4, 2, 3, 0, 3, 2

Check future usage:
- Page 7: Never used again → Distance = ∞
- Page 0: Used at next position → Distance = 1
- Page 1: Never used again → Distance = ∞

But looking more carefully:
- Page 7: Never appears later
- Page 0: Appears at position 5 (distance = 1)
- Page 1: Never appears later

Replace either 7 or 1 (both never used)
Let's replace 1 in this solution
Actually, better to keep 0 and 2 as they're used soon
Replace 1 (or 7)

Correct decision: Replace 1 (farthest usage)
Load 2 → [7][0][2]
```

### Advantages of Optimal
✓ **Best possible** algorithm (minimum page faults)
✓ **Benchmark** for comparing other algorithms
✓ **No Belady's Anomaly**

### Disadvantages of Optimal
✗ **Impossible to implement** (need to know future)
✗ **Theoretical only** - used for comparison
✗ **Requires future knowledge**

**Note:** Optimal is used as a **reference** to measure performance of practical algorithms

---

## 4. LRU (Least Recently Used)

### Concept
**LRU** = Replace the page that has **not been used for the longest time** in the past

### Key Idea
- Based on **principle of locality**
- Page not used recently → Likely won't be used soon
- **Past usage** predicts future usage

### Algorithm
- Track **last use time** for each page
- When replacement needed → Replace page with **oldest last use time**

### Implementation Methods

**1. Counter Method**
- Each page has a counter (timestamp)
- On access: Update counter to current time
- On replacement: Select page with smallest counter

**2. Stack Method**
- Maintain stack of page numbers
- On access: Move page to top of stack
- On replacement: Replace page at bottom

### Example 3: LRU Algorithm

**Given:**
- Reference String: **7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2**
- Number of Frames: **3**

**Solution:**
```
Page   Frames          Page Fault?  Recent Usage Order (Top = Most Recent)
Ref    [F0] [F1] [F2]
---    ---------------  -----------  ------------------------------------
7      [7]  [ ]  [ ]    ✓ (Fault 1)  7
0      [7]  [0]  [ ]    ✓ (Fault 2)  0, 7
1      [7]  [0]  [1]    ✓ (Fault 3)  1, 0, 7
2      [2]  [0]  [1]    ✓ (Fault 4)  2, 1, 0 (Replace 7 - LRU)
0      [2]  [0]  [1]    ✗ (Hit)      0, 2, 1
3      [2]  [0]  [3]    ✓ (Fault 5)  3, 0, 2 (Replace 1 - LRU)
0      [2]  [0]  [3]    ✗ (Hit)      0, 3, 2
4      [4]  [0]  [3]    ✓ (Fault 6)  4, 0, 3 (Replace 2 - LRU)
2      [4]  [0]  [2]    ✓ (Fault 7)  2, 0, 4 (Replace 3 - LRU)
3      [3]  [0]  [2]    ✓ (Fault 8)  3, 2, 0 (Replace 4 - LRU)
0      [3]  [0]  [2]    ✗ (Hit)      0, 3, 2
3      [3]  [0]  [2]    ✗ (Hit)      3, 0, 2
2      [3]  [0]  [2]    ✗ (Hit)      2, 3, 0

Total Page Faults: 8
Total References: 13
Page Fault Rate: 8/13 = 61.5%
```

### Step-by-Step with Stack Visualization
```
Position 1: Reference 7
Stack: [7]
Frames: [7][ ][ ]  → Fault

Position 2: Reference 0
Stack: [0][7]
Frames: [7][0][ ]  → Fault

Position 3: Reference 1
Stack: [1][0][7]
Frames: [7][0][1]  → Fault

Position 4: Reference 2
Stack before: [1][0][7]
7 is LRU (bottom of stack) → Replace 7
Stack after: [2][1][0]
Frames: [2][0][1]  → Fault

Position 5: Reference 0
Stack before: [2][1][0]
0 already in stack → Move to top
Stack after: [0][2][1]
Frames: [2][0][1]  → Hit
```

### Advantages of LRU
✓ **Good performance** (close to optimal)
✓ **Based on locality** principle
✓ **No Belady's Anomaly**
✓ **Realistic approximation** of optimal

### Disadvantages of LRU
✗ **Expensive to implement** (needs hardware support)
✗ **Overhead** of maintaining counters/stack
✗ **Slower** than FIFO

---

## 5. LFU (Least Frequently Used)

### Concept
**LFU** = Replace the page with the **smallest access count** (used least number of times)

### Algorithm
- Each page has a **counter** (number of accesses)
- On access: Increment counter
- On replacement: Replace page with smallest counter

### Example 4: LFU Algorithm

**Given:**
- Reference String: **7, 0, 1, 2, 0, 3, 0, 4**
- Number of Frames: **3**

**Solution:**
```
Page   Frames          Counters         Page Fault?
Ref    [F0] [F1] [F2]  [C0] [C1] [C2]
---    ---------------  ---------------  -----------
7      [7]  [ ]  [ ]    [1]  [ ]  [ ]    ✓ (Fault 1)
0      [7]  [0]  [ ]    [1]  [1]  [ ]    ✓ (Fault 2)
1      [7]  [0]  [1]    [1]  [1]  [1]    ✓ (Fault 3)
2      [2]  [0]  [1]    [1]  [1]  [1]    ✓ (Fault 4) Replace 7 (count=1)
0      [2]  [0]  [1]    [1]  [2]  [1]    ✗ (Hit) Increment 0's counter
3      [2]  [0]  [3]    [1]  [2]  [1]    ✓ (Fault 5) Replace 1 (count=1)
0      [2]  [0]  [3]    [1]  [3]  [1]    ✗ (Hit) Increment 0's counter
4      [4]  [0]  [3]    [1]  [3]  [1]    ✓ (Fault 6) Replace 2 (count=1)

Total Page Faults: 6
```

### Tie Breaking in LFU
When multiple pages have same count:
- Use **FIFO** (replace oldest)
- Or use **LRU** (replace least recently used)

### Advantages of LFU
✓ Keeps **frequently used pages** in memory
✓ Good for pages with **repeated access patterns**

### Disadvantages of LFU
✗ **Counter overhead**
✗ **Initial bias** - new pages have low count, may be replaced quickly
✗ **Old pages** with high count stay even if no longer needed

---

## 6. MFU (Most Frequently Used)

### Concept
**MFU** = Replace the page with the **highest access count**

### Logic
- Page with high count was **heavily used** → Probably won't be needed soon
- Page with low count **just brought in** → Likely to be used more

### Example 5: MFU Algorithm

**Given:**
- Reference String: **7, 0, 1, 2, 0, 3, 0, 4**
- Number of Frames: **3**

**Solution:**
```
Page   Frames          Counters         Page Fault?
Ref    [F0] [F1] [F2]  [C0] [C1] [C2]
---    ---------------  ---------------  -----------
7      [7]  [ ]  [ ]    [1]  [ ]  [ ]    ✓ (Fault 1)
0      [7]  [0]  [ ]    [1]  [1]  [ ]    ✓ (Fault 2)
1      [7]  [0]  [1]    [1]  [1]  [1]    ✓ (Fault 3)
2      [2]  [0]  [1]    [1]  [1]  [1]    ✓ (Fault 4) Replace any (all count=1)
0      [2]  [0]  [1]    [1]  [2]  [1]    ✗ (Hit) Increment 0's counter
3      [2]  [3]  [1]    [1]  [1]  [1]    ✓ (Fault 5) Replace 0 (count=2, highest)
0      [2]  [3]  [0]    [1]  [1]  [1]    ✓ (Fault 6) Replace any (all count=1)
4      [2]  [3]  [4]    [1]  [1]  [1]    ✓ (Fault 7) Replace 0 (just example)

Total Page Faults: 7
```

### Note on MFU
- **Rarely used** in practice
- **Poor performance** - counterintuitive logic
- Included for **theoretical completeness**

---

## 7. Comparison of Algorithms

### Performance Comparison

**Reference String: 7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2**
**Frames: 3**

| Algorithm | Page Faults | Hit Rate | Performance |
|-----------|-------------|----------|-------------|
| **FIFO** | 10 | 23.1% | Poor |
| **Optimal** | 7 | 46.2% | Best (theoretical) |
| **LRU** | 8 | 38.5% | Good |
| **LFU** | Variable | Variable | Medium |
| **MFU** | High | Low | Poor |

### Ranking (Best to Worst)
```
1. Optimal (OPT)     - Best, but impractical
2. LRU               - Best practical algorithm
3. LFU               - Good in specific scenarios
4. FIFO              - Simple but poor
5. MFU               - Worst performance
```

### Algorithm Selection Guide

**Use FIFO when:**
- Simplicity is priority
- Low overhead needed
- Performance not critical

**Use LRU when:**
- Best performance needed
- Hardware support available
- Locality of reference expected

**Use LFU when:**
- Access patterns show frequency importance
- Some pages accessed repeatedly

**Use Optimal:**
- Only for theoretical comparison
- Cannot be implemented (needs future knowledge)

---

## 8. Belady's Anomaly

### What is Belady's Anomaly?

**Belady's Anomaly** = Increasing the number of frames **increases** page faults (counterintuitive!)

### Expected Behavior
```
More frames → More pages in memory → Fewer page faults ✓
```

### Anomalous Behavior
```
More frames → MORE page faults ✗ (Should not happen!)
```

### Example: Belady's Anomaly with FIFO

**Reference String: 1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5**

**With 3 Frames:**
```
Ref   Frames          Fault?
---   -------------   ------
1     [1][ ][ ]       ✓
2     [1][2][ ]       ✓
3     [1][2][3]       ✓
4     [4][2][3]       ✓ (Replace 1)
1     [4][1][3]       ✓ (Replace 2)
2     [4][1][2]       ✓ (Replace 3)
5     [5][1][2]       ✓ (Replace 4)
1     [5][1][2]       ✗ (Hit)
2     [5][1][2]       ✗ (Hit)
3     [3][1][2]       ✓ (Replace 5)
4     [3][4][2]       ✓ (Replace 1)
5     [3][4][5]       ✓ (Replace 2)

Total Page Faults: 10
```

**With 4 Frames:**
```
Ref   Frames              Fault?
---   -----------------   ------
1     [1][ ][ ][ ]        ✓
2     [1][2][ ][ ]        ✓
3     [1][2][3][ ]        ✓
4     [1][2][3][4]        ✓
1     [1][2][3][4]        ✗ (Hit)
2     [1][2][3][4]        ✗ (Hit)
5     [5][2][3][4]        ✓ (Replace 1)
1     [5][1][3][4]        ✓ (Replace 2)
2     [5][1][2][4]        ✓ (Replace 3)
3     [5][1][2][3]        ✓ (Replace 4)
4     [4][1][2][3]        ✓ (Replace 5)
5     [4][5][2][3]        ✓ (Replace 1)

Total Page Faults: 11 (MORE than with 3 frames!)
```

### Result
```
3 Frames → 10 page faults
4 Frames → 11 page faults

MORE FRAMES = MORE FAULTS! (Belady's Anomaly)
```

### Which Algorithms Suffer from Belady's Anomaly?

**Suffer from Anomaly:**
✗ **FIFO** - Can exhibit Belady's Anomaly

**Do NOT Suffer:**
✓ **LRU** - No anomaly (stack algorithm)
✓ **Optimal** - No anomaly (stack algorithm)
✓ **LFU** - Generally no anomaly

### Stack Algorithms
**Stack Algorithm** = Algorithm where set of pages in memory with n frames is **always a subset** of pages with n+1 frames

- LRU and Optimal are **stack algorithms**
- Stack algorithms **never** show Belady's Anomaly
- FIFO is **NOT** a stack algorithm → Can show anomaly

---
