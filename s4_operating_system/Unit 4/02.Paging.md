# Paging

## 1. Principle of Operation

### What is Paging?
**Paging** is a memory management scheme that eliminates the need for contiguous allocation of physical memory. It divides memory into fixed-size blocks.

### Key Terminology

- **Page** - Fixed-size block of **logical memory** (process memory)
- **Frame** - Fixed-size block of **physical memory** (RAM)
- **Page Size = Frame Size** (typically 4KB, 8KB, or 16KB)

### How Paging Works
```
Logical Memory          Physical Memory
┌──────────┐           ┌──────────┐
│  Page 0  │──────────>│  Frame 2 │
├──────────┤           ├──────────┤
│  Page 1  │──────────>│  Frame 5 │
├──────────┤           ├──────────┤
│  Page 2  │──────────>│  Frame 1 │
├──────────┤           ├──────────┤
│  Page 3  │──────────>│  Frame 7 │
└──────────┘           └──────────┘
```

### Characteristics
- **No External Fragmentation** - Any page fits in any frame
- **Small Internal Fragmentation** - Only in the last page of a process
- **Non-contiguous Allocation** - Pages can be scattered in physical memory
- **Transparent to Programmer** - OS handles all mapping

### Advantages
✓ No external fragmentation
✓ Simple memory allocation
✓ Easy to swap pages in/out
✓ Supports multiprogramming
✓ Process size not limited by contiguous memory

### Disadvantages
✗ Internal fragmentation in last page
✗ Page table overhead (extra memory)
✗ Slower memory access (requires page table lookup)
✗ Hardware support needed (MMU, TLB)

---

## 2. Logical vs Physical Address Space

### Logical Address Space
- **Virtual/Logical Address** - Generated by CPU during program execution
- Consists of: **Page Number + Page Offset**
- Programmer works with logical addresses
- Size = 2^m (where m = bits in logical address)

### Physical Address Space
- **Physical Address** - Actual address in RAM
- Consists of: **Frame Number + Frame Offset**
- Hardware translates logical → physical
- Size = 2^n (where n = bits in physical address)

### Address Structure
```
Logical Address (m bits)
┌─────────────────┬──────────────┐
│  Page Number    │ Page Offset  │
│      (p)        │     (d)      │
└─────────────────┴──────────────┘
     p bits           d bits

Physical Address (n bits)
┌─────────────────┬──────────────┐
│  Frame Number   │Frame Offset  │
│      (f)        │     (d)      │
└─────────────────┴──────────────┘
     f bits           d bits
```

### Important Formulas
```
Page Size = 2^d bytes (where d = offset bits)
Number of Pages = Logical Address Space / Page Size
Number of Frames = Physical Memory Size / Frame Size

Logical Address = (Page Number × Page Size) + Offset
Physical Address = (Frame Number × Frame Size) + Offset
```

### Example
```
Logical Address Space = 64 KB = 2^16 bytes
Page Size = 4 KB = 2^12 bytes
Physical Memory = 128 KB = 2^17 bytes

Number of Pages = 64 KB / 4 KB = 16 pages
Number of Frames = 128 KB / 4 KB = 32 frames

Logical Address bits = 16 (4 bits for page number, 12 for offset)
Physical Address bits = 17 (5 bits for frame number, 12 for offset)
```

---

## 3. Page Tables and Address Translation

### Page Table
**Page Table** = Data structure that stores the mapping from page numbers to frame numbers

### Page Table Structure
```
Page Table (for one process)
┌─────────────┬──────────────┐
│ Page Number │ Frame Number │
├─────────────┼──────────────┤
│      0      │      2       │
│      1      │      5       │
│      2      │      1       │
│      3      │      7       │
│     ...     │     ...      │
└─────────────┴──────────────┘
```

### Page Table Entry (PTE)
Each entry contains:
- **Frame Number** (mandatory)
- **Valid/Invalid Bit** - Is page in memory?
- **Protection Bits** - Read/Write/Execute permissions
- **Reference Bit** - Has page been accessed?
- **Modified Bit (Dirty Bit)** - Has page been modified?
- **Caching Disabled** - For I/O memory
```
Page Table Entry Structure
┌─────┬───────┬──────┬───────┬─────────┬───────────────┐
│ V/I │ Prot. │ Ref. │ Mod.  │ Cache   │ Frame Number  │
└─────┴───────┴──────┴───────┴─────────┴───────────────┘
  1bit  2-3bits 1bit   1bit    1bit      Remaining bits
```

### Address Translation Process

**Step-by-Step Translation:**

1. CPU generates **Logical Address**
2. Extract **Page Number (p)** and **Page Offset (d)**
3. Use **Page Number** as index in Page Table
4. Get **Frame Number (f)** from Page Table
5. Combine **Frame Number + Offset** = **Physical Address**
6. Access memory at Physical Address
```
Address Translation Flow
┌──────────────────┐
│ Logical Address  │
│   (Page, Offset) │
└────────┬─────────┘
         │
         ▼
   ┌─────────────┐
   │  Page Table │ ◄── Page Number used as index
   └──────┬──────┘
          │
          ▼ Frame Number
   ┌──────────────────┐
   │ Physical Address │
   │  (Frame, Offset) │
   └──────────────────┘
```

### Example of Address Translation

**Given:**
- Page Size = 1024 bytes (1 KB) = 2^10
- Logical Address = 2500
- Page Table: Page 2 → Frame 6

**Solution:**
```
Step 1: Find Page Number and Offset
Logical Address = 2500
Page Number = 2500 / 1024 = 2
Page Offset = 2500 % 1024 = 452

Step 2: Lookup Page Table
Page 2 → Frame 6

Step 3: Calculate Physical Address
Physical Address = (Frame Number × Page Size) + Offset
                = (6 × 1024) + 452
                = 6144 + 452
                = 6596
```

---

## 4. Page Allocation Techniques

### Equal Allocation
- All processes get **equal number of frames**
- Simple but inefficient
```
Formula: Frames per process = Total Frames / Number of Processes

Example:
Total Frames = 100
Processes = 5
Each process gets = 100/5 = 20 frames
```

### Proportional Allocation
- Frames allocated **proportional to process size**
- Larger processes get more frames
```
Formula: Frames for process i = (Size of process i / Total size) × Total Frames

Example:
Process P1 = 10 KB
Process P2 = 30 KB
Total Frames = 100

P1 gets = (10/40) × 100 = 25 frames
P2 gets = (30/40) × 100 = 75 frames
```

### Priority-Based Allocation
- High priority processes get **more frames**
- Based on process importance

### Global vs Local Replacement

**Local Replacement:**
- Process can only replace its **own pages**
- Fixed allocation per process

**Global Replacement:**
- Process can replace **any page** in memory
- Dynamic allocation
- Better throughput but less predictable

---

## 5. Hardware Support for Paging

### A. Page Table Base Register (PTBR)

**PTBR** = Register that points to the **starting address** of page table in memory
```
┌──────┐
│ PTBR │──────> Page Table in Memory
└──────┘        ┌─────────────┬──────────────┐
                │ Page Number │ Frame Number │
                ├─────────────┼──────────────┤
                │      0      │      3       │
                │      1      │      7       │
                │     ...     │     ...      │
                └─────────────┴──────────────┘
```

**Characteristics:**
- Each process has its own page table
- PTBR changed during **context switch**
- Points to page table of current process

### B. Translation Lookaside Buffer (TLB)

**TLB** = Special, fast **cache** for page table entries

### Why TLB?
- Page table stored in **main memory** (slow)
- Every memory access needs **2 memory accesses**:
  1. Access page table (get frame number)
  2. Access actual data
- TLB makes translation **faster**

### TLB Structure
```
TLB (Associative Memory - Hardware Cache)
┌─────────────┬──────────────┬─────────────┐
│ Page Number │ Frame Number │ Other Bits  │
├─────────────┼──────────────┼─────────────┤
│      2      │      6       │   Valid=1   │
│      5      │      9       │   Valid=1   │
│      8      │      3       │   Valid=1   │
│     ...     │     ...      │    ...      │
└─────────────┴──────────────┴─────────────┘
     (Small, typically 64-1024 entries)
```

### TLB Operation
```
Address Translation with TLB
┌──────────────────┐
│ Logical Address  │
└────────┬─────────┘
         │
         ▼
    ┌─────────┐
    │   TLB   │ ◄── Check if page number exists
    └────┬────┘
         │
    ┌────┴────┐
    │         │
TLB Hit   TLB Miss
    │         │
    │         ▼
    │    ┌─────────────┐
    │    │  Page Table │ ◄── Access memory
    │    └──────┬──────┘
    │           │
    └───────────┤
                ▼
         ┌──────────────────┐
         │ Physical Address │
         └──────────────────┘
```

### TLB Hit vs TLB Miss

**TLB Hit:**
- Page number found in TLB
- Frame number retrieved **directly**
- **Fast** - No memory access needed
- Time = TLB access time

**TLB Miss:**
- Page number NOT in TLB
- Must access **page table in memory**
- Update TLB with new entry
- **Slow** - Extra memory access needed
- Time = TLB access time + Memory access time

### Effective Access Time (EAT) with TLB
```
EAT = (TLB Hit Ratio × TLB Hit Time) + (TLB Miss Ratio × TLB Miss Time)

Where:
TLB Hit Time = TLB access + Memory access
TLB Miss Time = TLB access + Page Table access + Memory access
```

**Formula:**
```
Let:
α = TLB Hit Ratio (0 to 1)
ε = TLB access time
m = Memory access time

TLB Hit Time = ε + m
TLB Miss Time = ε + m + m = ε + 2m

EAT = α(ε + m) + (1-α)(ε + 2m)
    = ε + m + (1-α)m
    = ε + (2-α)m
```

### Example: EAT Calculation
```
Given:
TLB Hit Ratio = 80% = 0.8
TLB access time = 20 ns
Memory access time = 100 ns

Solution:
EAT = α(ε + m) + (1-α)(ε + 2m)
    = 0.8(20 + 100) + 0.2(20 + 200)
    = 0.8(120) + 0.2(220)
    = 96 + 44
    = 140 ns

Without TLB: 200 ns (always 2 memory accesses)
With TLB: 140 ns
Speedup = 200/140 = 1.43x
```

### TLB Characteristics
- **Size:** Small (64-1024 entries)
- **Speed:** Very fast (part of CPU)
- **Access:** Parallel/Associative search
- **Update:** On context switch, TLB is flushed
- **Hit Ratio:** Typically 80-99%

### C. Page Table Length Register (PTLR)

**PTLR** = Stores the **size** (number of entries) of page table

- Used for **bounds checking**
- Prevents access to invalid page numbers
- If page number ≥ PTLR → Error

---
## Important Exam Questions & Answers

### Q1. What is the main advantage of paging over contiguous allocation?
**Answer:** Paging eliminates external fragmentation and allows non-contiguous allocation. Process can be loaded into any available frames without worrying about contiguous memory blocks.

### Q2. Why is page size always a power of 2?
**Answer:** 
- Simplifies address translation (bit shifting instead of division)
- Easy to extract page number and offset using bit masking
- Hardware implementation is simpler and faster

### Q3. What is the difference between TLB and Page Table?
| TLB | Page Table |
|-----|------------|
| Hardware cache (fast) | Stored in memory (slow) |
| Small (64-1024 entries) | Large (all pages) |
| Part of CPU | In RAM |
| Checked first | Checked on TLB miss |
| Associative search | Direct indexing |

### Q4. Why is EAT important?
**Answer:** EAT (Effective Access Time) measures the actual average time to access memory considering TLB hits and misses. It helps evaluate paging system performance and TLB efficiency.

### Q5. What happens during context switch in paging?
**Answer:**
1. Save current PTBR value
2. Flush/invalidate TLB (entries belong to old process)
3. Load new process's PTBR
4. TLB gradually fills with new process's pages

---

## Quick Revision Formulas
```
1. Page Number = Logical Address / Page Size
2. Page Offset = Logical Address % Page Size
3. Physical Address = (Frame Number × Page Size) + Offset
4. Number of Pages = Logical Address Space / Page Size
5. Number of Frames = Physical Memory / Frame Size
6. Page Table Size = Number of Pages × Entry Size
7. Internal Fragmentation = Page Size - (Process Size % Page Size)
8. EAT = ε + (2 - α)m  [where α = hit ratio, ε = TLB time, m = memory time]
9. Offset Bits = log₂(Page Size)
10. Page Number Bits = Total Address Bits - Offset Bits
```

---
