## Segmentation

### What is Segmentation?

**Concept:** Memory management scheme that supports user's view of memory.

- A program is a collection of segments (logical units)
- Each segment is a logical grouping of related information
- Segments vary in size

### Logical Segments Examples

A user program consists of:
- Main program
- Functions/Procedures
- Methods
- Stack
- Symbol table
- Arrays
- Objects

### Segment vs Page

| Segmentation | Paging |
|--------------|--------|
| Variable size | Fixed size |
| User's view | System's view |
| Logical units | Physical units |
| Programmer aware | Programmer unaware |
| External fragmentation | Internal fragmentation |

### Segment Table

Each entry in segment table contains:
1. **Base (Starting Address):** Physical address where segment begins in memory
2. **Limit (Size):** Length of the segment

```
Segment Table
Segment # | Base  | Limit
----------|-------|-------
    0     | 1400  |  1000
    1     | 6300  |  400
    2     | 4300  |  400
    3     | 3200  |  1100
    4     | 4700  |  1000
```

### Logical Address in Segmentation

```
| Segment Number (s) | Offset (d) |
```

- **Segment Number (s):** Index to segment table
- **Offset (d):** Distance from beginning of segment

### Address Translation Process

**Steps:**

1. Extract segment number (s) from logical address
2. Check if s < segment table length
3. Get base and limit from segment table
4. Check if offset (d) < limit (protection)
5. Physical address = base + offset

```
Logical Address: (Segment #, Offset)
                      ↓
                Segment Table
                      ↓
         Check: Offset < Limit?
                      ↓
         Physical Address = Base + Offset
```

### Example Problem

**Given:**
- Logical address: (Segment 2, Offset 53)
- Segment Table:
  - Segment 2: Base = 4300, Limit = 400

**Find:** Physical address

**Solution:**
```
Step 1: Offset = 53
Step 2: Check if 53 < 400 (limit) → Yes, valid
Step 3: Physical address = 4300 + 53 = 4353
```

### Protection in Segmentation

**Advantages:**
- Each segment can have different protection
- Can specify: Read, Write, Execute permissions
- Sharing is easy (multiple processes can share same segment)

**Protection Check:**
- If offset ≥ limit → Segmentation fault (trap to OS)

### Segmentation with Paging

**Concept:** Combine benefits of both schemes
- User's view: Segmentation
- Memory management: Paging

**Process:**
1. Logical address → Segment number + Offset
2. Segment table gives page table base
3. Offset divided into page number + page offset
4. Page table gives frame number
5. Physical address = Frame + Page offset

### Advantages of Segmentation

✓ No internal fragmentation
✓ Supports user's logical view
✓ Easy to share segments between processes
✓ Better protection (segment-level)
✓ Dynamic growth of segments

### Disadvantages of Segmentation

✗ External fragmentation
✗ Difficult memory allocation (variable size)
✗ More complex than paging
✗ Segments must be allocated contiguously

---
