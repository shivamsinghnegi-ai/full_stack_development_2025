# SEGMENTATION

### 1. What is Segmentation?

Segmentation is a memory management scheme that supports the **user's view of memory**.

- A program is a collection of **segments** (logical units)
- Each segment is a **named and sized** logical unit of a program
- Segments have **variable lengths** (unlike pages which are fixed)
- User is **aware** of segments

### 2. Segments in a Program

A typical user program consists of:

```
┌───────────────────────────────────────┐
│           User Program                │
├───────────────────────────────────────┤
│  Segment 0  → Main Program            │
│  Segment 1  → Function / Subroutines  │
│  Segment 2  → Local Variables, Stack  │
│  Segment 3  → Symbol Table            │
│  Segment 4  → Arrays / Global Data    │
└───────────────────────────────────────┘
```

Each of these is a **separate segment** with its own size.

---

### 3. Segment Table

Each process has a **Segment Table**. Each entry contains:

```
┌──────────────┬──────────────┐
│     BASE     │    LIMIT     │
│ (Start Addr) │   (Size)     │
└──────────────┴──────────────┘
```

- **BASE:** Starting physical address of the segment in memory
- **LIMIT:** Length/Size of the segment

**Example Segment Table:**

```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Segment #  |  Base   |  Limit
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    0      |  1400   |  1000
    1      |  6300   |   400
    2      |  4300   |   400
    3      |  3200   |  1100
    4      |  4700   |  1000
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

---

### 4. Logical Address in Segmentation

Logical address has **two parts:**

```
┌────────────────────┬──────────────┐
│  Segment Number(s) │  Offset (d)  │
└────────────────────┴──────────────┘
```

- **s** → Which segment?
- **d** → How far from beginning of segment?

---

### 5. Address Translation - Step by Step

```
Logical Address (s, d)
        ↓
   Get s and d
        ↓
   Check: Is s valid? (s < total segments)
        ↓ YES
   Go to Segment Table → Entry s
        ↓
   Get Base and Limit
        ↓
   Check: Is d < Limit?
     ↙         ↘
   YES           NO
    ↓             ↓
Physical       TRAP to OS
Address =      (Segmentation
Base + d        Fault!)
```

**Formula:**
```
Physical Address = Base[s] + d

Condition (MUST check): d < Limit[s]
If d >= Limit → SEGMENTATION FAULT
```

---

### 6. Solved Examples - Address Translation

**Example 1: Valid Access**

```
Given:
Segment Table:
Seg 0: Base=219,  Limit=600
Seg 1: Base=2300, Limit=14
Seg 2: Base=90,   Limit=100
Seg 3: Base=1327, Limit=580
Seg 4: Base=1952, Limit=96

Find Physical address for (0, 430):

Solution:
s = 0, d = 430
Limit of Segment 0 = 600
Check: 430 < 600? YES ✓
Physical Address = Base[0] + d
                = 219 + 430
                = 649 ✓
```

**Example 2: Another Valid Access**

```
Logical address = (1, 10)

s = 1, d = 10
Limit of Segment 1 = 14
Check: 10 < 14? YES ✓
Physical Address = 2300 + 10 = 2310 ✓
```

**Example 3: INVALID Access (Segmentation Fault)**

```
Logical address = (2, 500)

s = 2, d = 500
Limit of Segment 2 = 100
Check: 500 < 100? NO ✗

Result: SEGMENTATION FAULT!
        Trap to OS → Process terminated
```

**Example 4:**

```
Logical address = (3, 400)

s = 3, d = 400
Limit of Segment 3 = 580
Check: 400 < 580? YES ✓
Physical Address = 1327 + 400 = 1727 ✓
```

**Example 5:**

```
Logical address = (4, 112)

s = 4, d = 112
Limit of Segment 4 = 96
Check: 112 < 96? NO ✗

Result: SEGMENTATION FAULT!
```

---

### 7. Memory Diagram - Segmentation

```
Physical Memory
─────────────────────────────────
   0    │                        │
        │                        │
  219   ╠════════════════════════╣ ← Seg 0 Start
        ║    Segment 0           ║
        ║   (Main Program)       ║
        ║    Size = 600          ║
  819   ╠════════════════════════╣ ← Seg 0 End
        │                        │
 1327   ╠════════════════════════╣ ← Seg 3 Start
        ║    Segment 3           ║
        ║   (Symbol Table)       ║
        ║    Size = 1100         ║
 2427   ╠════════════════════════╣ ← Seg 3 End
 2300   ╠════════════════════════╣ ← Seg 1 Start
        ║    Segment 1           ║
        ║   (Functions)          ║
        ║    Size = 400          ║
 2700   ╠════════════════════════╣ ← Seg 1 End
        │          ...           │
─────────────────────────────────
```

---

### 8. Protection in Segmentation

Each segment can have different **protection bits:**

```
Segment Table (with protection):
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Seg # | Base | Limit | Read | Write | Execute
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  0   | 1400 | 1000  |  1   |   1   |    1
  1   | 6300 |  400  |  1   |   0   |    1   ← Read-only!
  2   | 4300 |  400  |  1   |   1   |    0
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

- Code segment → Read + Execute only (no write)
- Data segment → Read + Write (no execute)
- Stack segment → Read + Write

---

### 9. Sharing in Segmentation

Multiple processes can **share same segment:**

```
Process 1's Segment Table          Process 2's Segment Table
━━━━━━━━━━━━━━━━━━━━━━━━          ━━━━━━━━━━━━━━━━━━━━━━━━
Seg 0 → Base: 43062               Seg 0 → Base: 68348
Seg 1 → Base: 43062  ─────────→ SHARED CODE SEGMENT
━━━━━━━━━━━━━━━━━━━━━━━━          ━━━━━━━━━━━━━━━━━━━━━━━━
```

Both processes point to **same physical address** for shared segment.

---

### 10. Segmentation vs Paging - Complete Comparison

```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Feature            | Paging          | Segmentation
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Division           | Fixed size      | Variable size
Unit               | Page / Frame    | Segment
User visibility    | Hidden          | Visible
Fragmentation      | Internal only   | External only
Address format     | Page# + Offset  | Seg# + Offset
Table entry        | Frame#          | Base + Limit
Protection         | Page level      | Segment level
Sharing            | Difficult       | Easy
Allocation         | Any free frame  | Contiguous block
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

---

### 11. Segmented Paging (Combined Approach)

Modern systems combine both to get benefits of each:

```
Logical Address
      ↓
┌─────────────────────────────────┐
│ Seg# │   Page#   │   Offset    │
└─────────────────────────────────┘
      ↓
 Segment Table
      ↓
 Page Table Base (for that segment)
      ↓
 Page Table → Frame Number
      ↓
 Physical Address = Frame + Offset
```

**Benefit:** User sees segments, OS manages pages inside each segment.

---

### 12. Advantages & Disadvantages

**Advantages:**
- ✓ Supports user's logical view of memory
- ✓ No internal fragmentation
- ✓ Easy and efficient sharing of segments
- ✓ Better protection at segment level
- ✓ Segments can grow independently

**Disadvantages:**
- ✗ External fragmentation (variable size)
- ✗ Allocation more complex than paging
- ✗ Each segment needs contiguous physical memory
- ✗ Compaction may be needed (costly)

---
