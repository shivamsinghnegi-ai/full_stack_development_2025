# Segmentation

## 1. Concept of Segmentation

### What is Segmentation?
**Segmentation** is a memory management scheme that divides the **logical address space** into variable-sized segments based on the **logical structure** of the program.

### Key Idea
- Program is divided into **meaningful segments**
- Each segment represents a **logical unit** (function, array, stack, etc.)
- Segments have **variable sizes**
- Reflects the **programmer's view** of memory

### Logical Segments
A program typically consists of:
1. **Main Program** - Main code segment
2. **Subroutines/Functions** - Procedure segments
3. **Stack** - Local variables and function calls
4. **Heap** - Dynamic memory allocation
5. **Symbol Table** - Variable and function names
6. **Arrays/Data Structures** - Large data segments
```
Program Structure (Programmer's View)
┌─────────────────┐
│  Main Program   │ ← Segment 0
├─────────────────┤
│   Function 1    │ ← Segment 1
├─────────────────┤
│   Function 2    │ ← Segment 2
├─────────────────┤
│     Stack       │ ← Segment 3
├─────────────────┤
│   Symbol Table  │ ← Segment 4
├─────────────────┤
│     Array       │ ← Segment 5
└─────────────────┘
```

### Segment
Each segment has:
- **Segment Name/Number** - Identifier
- **Segment Base Address** - Starting physical address
- **Segment Limit/Length** - Size of segment
- **Protection Bits** - Read/Write/Execute permissions

### Logical Address in Segmentation
Logical Address = **<Segment Number, Offset>**
```
Logical Address
┌──────────────────┬─────────────────┐
│ Segment Number   │     Offset      │
│      (s)         │       (d)       │
└──────────────────┴─────────────────┘

Where:
s = Segment number
d = Offset within segment (0 to segment limit)
```

---

## 2. Segment Table

### What is Segment Table?
**Segment Table** = Data structure that stores information about each segment

### Segment Table Structure
```
Segment Table
┌────────┬──────────────┬───────────────┬──────────────┐
│ Seg No │  Base Addr   │  Limit/Length │ Protection   │
├────────┼──────────────┼───────────────┼──────────────┤
│   0    │    1400      │      1000     │   R/W/X      │
│   1    │    6300      │       400     │   R/X        │
│   2    │    4300      │       400     │   R/W        │
│   3    │    3200      │      1100     │   R/W        │
│   4    │    4700      │       1000    │   R          │
└────────┴──────────────┴───────────────┴──────────────┘

Base = Starting physical address of segment
Limit = Size/Length of segment in bytes
```

### Segment Table Entry Fields
1. **Base Address** - Physical starting address
2. **Limit** - Length of segment
3. **Valid Bit** - Is segment in memory?
4. **Protection Bits** - Read/Write/Execute
5. **Reference Bit** - Recently accessed?
6. **Modified Bit** - Has been modified?

---

## 3. Address Translation in Segmentation

### Translation Process

**Step-by-Step:**
1. CPU generates **Logical Address** = (segment, offset)
2. Extract **Segment Number (s)** and **Offset (d)**
3. Check: **Offset < Segment Limit?** (Bounds checking)
   - If NO → **Segmentation Fault/Trap**
   - If YES → Continue
4. Get **Base Address** from Segment Table[s]
5. Calculate: **Physical Address = Base + Offset**
6. Access memory at Physical Address
```
Address Translation Flow
┌─────────────────────┐
│  Logical Address    │
│ (Segment, Offset)   │
└──────────┬──────────┘
           │
           ▼
    ┌──────────────┐
    │Segment Number│
    └──────┬───────┘
           │
           ▼
    ┌─────────────────┐
    │  Segment Table  │
    │ Get Base, Limit │
    └──────┬──────────┘
           │
           ▼
    ┌─────────────────┐      NO
    │ Offset < Limit? │────────> TRAP (Error)
    └──────┬──────────┘
           │ YES
           ▼
    ┌─────────────────────┐
    │ Physical Address =  │
    │   Base + Offset     │
    └─────────────────────┘
```

### Example: Address Translation

**Given:**
Segment Table:
```
Seg 0: Base = 1400, Limit = 1000
Seg 1: Base = 6300, Limit = 400
Seg 2: Base = 4300, Limit = 400
```

**Problem:** Translate logical address (1, 53)

**Solution:**
```
Step 1: Extract segment number and offset
Segment Number = 1
Offset = 53

Step 2: Check bounds
Segment 1 Limit = 400
Is 53 < 400? YES ✓

Step 3: Get base address
Segment 1 Base = 6300

Step 4: Calculate physical address
Physical Address = Base + Offset
                = 6300 + 53
                = 6353
```

**Problem:** Translate logical address (2, 500)

**Solution:**
```
Step 1: Extract segment number and offset
Segment Number = 2
Offset = 500

Step 2: Check bounds
Segment 2 Limit = 400
Is 500 < 400? NO ✗

Step 3: TRAP - Segmentation Fault
Error: Trying to access beyond segment limit
```

---

## 4. Segmentation vs Paging

### Detailed Comparison

| Feature | Segmentation | Paging |
|---------|-------------|---------|
| **Division Basis** | Logical units (functions, arrays) | Fixed-size blocks |
| **Size** | Variable size segments | Fixed size pages |
| **Programmer View** | Visible (logical division) | Transparent (hidden) |
| **Address** | 2D (segment, offset) | 1D (single linear address) |
| **Fragmentation** | External fragmentation | Internal fragmentation |
| **Protection** | Easy (per segment) | Difficult (per page) |
| **Sharing** | Easy (entire segment) | Difficult |
| **Table Size** | Small (few segments) | Large (many pages) |
| **User Awareness** | User aware of segments | User unaware |
| **Address Space Growth** | Easy (segments grow) | Difficult |
| **Memory Utilization** | Poor (external frag) | Better |
| **Implementation** | Complex | Simpler |

### Conceptual Difference
```
PAGING (Physical Division)
┌────┬────┬────┬────┐
│ P0 │ P1 │ P2 │ P3 │  All pages same size
└────┴────┴────┴────┘  No logical meaning

SEGMENTATION (Logical Division)
┌──────────┬─────┬────────────┬──────┐
│   Main   │Func1│   Stack    │Array │  Variable sizes
└──────────┴─────┴────────────┴──────┘  Logical meaning
```

### When to Use What?

**Use Paging When:**
- Simple memory management needed
- Eliminating external fragmentation is priority
- Transparent to user
- Fixed-size allocation acceptable

**Use Segmentation When:**
- Logical program structure important
- Protection and sharing needed
- User wants control over memory layout
- Variable-size allocation needed

---

## 5. Advantages of Segmentation

### 1. Logical Organization
✓ Matches **programmer's view** of program
✓ Each segment has **logical meaning**
✓ Natural program structure

### 2. Protection
✓ **Easy to protect** each segment separately
✓ Different segments can have different permissions
✓ Example:
  - Code segment: Read + Execute only
  - Data segment: Read + Write
  - Stack segment: Read + Write
```
Segment Protection Example
┌─────────────┬────────────┐
│   Segment   │ Protection │
├─────────────┼────────────┤
│ Code        │   R-X      │ (Read-Execute)
│ Data        │   RW-      │ (Read-Write)
│ Stack       │   RW-      │ (Read-Write)
│ Const Data  │   R--      │ (Read Only)
└─────────────┴────────────┘
```

### 3. Sharing
✓ **Easy to share** entire segments between processes
✓ Multiple processes can share **same code segment**
✓ Example: Multiple programs using same library
```
Shared Segment Example
Process A          Shared Code         Process B
┌────────┐        ┌──────────┐        ┌────────┐
│ Data A │        │  Library │◄───────┤ Data B │
├────────┤    ┌──►│   Code   │        ├────────┤
│Code Seg│────┘   └──────────┘        │Code Seg│
└────────┘                             └────────┘
```

### 4. Dynamic Linking
✓ Segments can be **loaded on demand**
✓ Libraries loaded when first called
✓ Saves memory

### 5. Dynamic Growth
✓ Segments can **grow or shrink** dynamically
✓ Useful for stack and heap
✓ No need to pre-allocate fixed size

### 6. Modularity
✓ Supports **modular programming**
✓ Each module = separate segment
✓ Easy to compile and modify modules independently

---

## 6. Disadvantages of Segmentation

### 1. External Fragmentation ✗
- Variable-size segments create **memory holes**
- Free memory **scattered** in small blocks
- Total free memory sufficient but **not contiguous**
- **Solution:** Compaction (expensive)
```
External Fragmentation Example
Memory State:
┌─────┬──────┬─────┬────┬─────┐
│Seg A│ Free │Seg B│Free│Seg C│
│100KB│ 50KB │80KB │30KB│70KB │
└─────┴──────┴─────┴────┴─────┘
         ↑            ↑
      Can't allocate 90KB segment
      (Total free = 80KB but not contiguous)
```

### 2. Complex Memory Management ✗
- **Harder to implement** than paging
- Need to find **suitable hole** for variable sizes
- Allocation algorithms complex (First Fit, Best Fit, Worst Fit)

### 3. Overhead ✗
- Segmentation table stored in memory
- Extra memory access for address translation
- **No TLB** equivalent (variable sizes make caching difficult)

### 4. Costly Compaction ✗
- External fragmentation requires **compaction**
- Moving segments in memory is **expensive**
- System slowdown during compaction

### 5. Limited Segment Table Size ✗
- Number of segments **limited** by segment table size
- Can't have too many small segments

### 6. No Automatic Memory Management ✗
- Programmer must be **aware** of segments
- More burden on programmer
- Unlike paging which is transparent

---

## 7. Segmented Paging

### What is Segmented Paging?
**Segmented Paging** = Hybrid approach combining **benefits of both** segmentation and paging

### Concept
- Program divided into **segments** (logical view)
- Each segment divided into **pages** (physical allocation)
- Combines **logical organization** of segmentation with **efficient allocation** of paging

### Why Segmented Paging?
**Problem with Pure Segmentation:**
- External fragmentation
- Difficult to allocate large variable-size segments

**Solution:**
- Keep logical segmentation for programmer
- Use paging internally for physical allocation
- **Best of both worlds**

### Architecture
```
Logical View (Segmentation)
┌────────────────┐
│  Main Program  │ ← Segment 0
├────────────────┤
│   Function 1   │ ← Segment 1
├────────────────┤
│     Stack      │ ← Segment 2
└────────────────┘

Physical Storage (Paging)
Each segment divided into pages:
Segment 0: Pages 0, 1, 2, 3
Segment 1: Pages 0, 1
Segment 2: Pages 0, 1, 2
```

### Two-Level Address Translation

**Logical Address = <Segment Number, Page Number, Offset>**
```
Logical Address Structure
┌──────────┬────────────┬──────────┐
│ Segment  │    Page    │  Offset  │
│ Number   │   Number   │          │
└──────────┴────────────┴──────────┘
     s          p            d
```

### Data Structures

**1. Segment Table**
- Entry for each segment
- Contains: **Base address of page table** for that segment
- Contains: **Limit** (number of pages in segment)
```
Segment Table
┌────────┬─────────────────────┬──────────────┐
│ Seg No │ Page Table Base     │ Page Limit   │
├────────┼─────────────────────┼──────────────┤
│   0    │   Page Table 0 Addr │      4       │
│   1    │   Page Table 1 Addr │      2       │
│   2    │   Page Table 2 Addr │      3       │
└────────┴─────────────────────┴──────────────┘
```

**2. Page Tables (One per Segment)**
- Each segment has its **own page table**
- Maps page numbers to frame numbers
```
Page Table for Segment 0
┌──────────┬──────────────┐
│ Page No  │ Frame Number │
├──────────┼──────────────┤
│    0     │      5       │
│    1     │      8       │
│    2     │      2       │
│    3     │     12       │
└──────────┴──────────────┘
```

### Address Translation Process

**Step-by-Step Translation:**

1. CPU generates: **(segment, page, offset)**
2. Use **segment number** to index Segment Table
3. Get **page table base address** and **page limit**
4. Check: **page number < page limit?**
   - If NO → TRAP
   - If YES → Continue
5. Access **page table** at: page_table_base + page_number
6. Get **frame number** from page table entry
7. Calculate: **Physical Address = (frame × page_size) + offset**
```
Segmented Paging Translation
┌───────────────────────┐
│   Logical Address     │
│ (Seg, Page, Offset)   │
└──────────┬────────────┘
           │
           ▼
    ┌─────────────────┐
    │ Segment Table   │
    │ Get PT Base     │
    └──────┬──────────┘
           │
           ▼
    ┌─────────────────┐      NO
    │ Page < Limit?   │────────> TRAP
    └──────┬──────────┘
           │ YES
           ▼
    ┌─────────────────┐
    │ Page Table      │
    │ Get Frame No.   │
    └──────┬──────────┘
           │
           ▼
    ┌─────────────────┐
    │Physical Address │
    │ Frame + Offset  │
    └─────────────────┘
```

### Example: Segmented Paging Translation

**Given:**
- Page Size = 1 KB = 1024 bytes
- Logical Address = (1, 2, 300)  [Segment 1, Page 2, Offset 300]

**Segment Table:**
```
Seg 0: PT Base = 2000, Page Limit = 4
Seg 1: PT Base = 3000, Page Limit = 3
```

**Page Table for Segment 1 (at address 3000):**
```
Page 0 → Frame 5
Page 1 → Frame 9
Page 2 → Frame 3
```

**Solution:**
```
Step 1: Extract components
Segment = 1
Page = 2
Offset = 300

Step 2: Access Segment Table
Segment 1: PT Base = 3000, Limit = 3

Step 3: Check bounds
Is Page 2 < Limit 3? YES ✓

Step 4: Access Page Table
Page Table at address 3000
Page 2 → Frame 3

Step 5: Calculate Physical Address
Physical Address = (Frame × Page Size) + Offset
                = (3 × 1024) + 300
                = 3072 + 300
                = 3372
```

---

## 8. Comparison: Paging vs Segmentation vs Segmented Paging

| Feature | Paging | Segmentation | Segmented Paging |
|---------|--------|--------------|------------------|
| **Division** | Fixed pages | Variable segments | Both |
| **Logical View** | Hidden | Visible | Visible |
| **External Frag** | No | Yes | No |
| **Internal Frag** | Yes (last page) | No | Yes (last page) |
| **Protection** | Difficult | Easy | Easy |
| **Sharing** | Difficult | Easy | Easy |
| **Memory Waste** | Less | More (ext. frag) | Less |
| **Complexity** | Medium | Medium | High |
| **Address** | 1D | 2D | 3D |
| **Translation** | 1 level | 1 level | 2 levels |
| **Examples** | Most modern OS | Intel 8086 | Intel x86 |

---

## 9. Advantages of Segmented Paging

### Benefits from Segmentation:
✓ **Logical organization** - Programmer's view preserved
✓ **Easy protection** - Different segments have different permissions
✓ **Easy sharing** - Share entire segments (code segments)
✓ **Modularity** - Each module = segment

### Benefits from Paging:
✓ **No external fragmentation** - Pages fit in any frame
✓ **Efficient memory use** - Better than pure segmentation
✓ **Flexible allocation** - Segments can be any size
✓ **Easy swap** - Swap individual pages, not entire segments

### Combined Benefits:
✓ Best of both worlds
✓ Solves external fragmentation problem
✓ Maintains logical structure
✓ Used in modern systems (Intel x86)

---

## 10. Disadvantages of Segmented Paging

### 1. Complex Implementation ✗
- **Most complex** memory management scheme
- Requires sophisticated hardware
- Two levels of address translation

### 2. Memory Overhead ✗
- Need **segment table** AND **page tables** (one per segment)
- More memory consumed by tables
- Example: 100 segments × 1000 pages each = large overhead

### 3. Slower Address Translation ✗
- **Two memory accesses** needed:
  1. Segment table access
  2. Page table access
- Additional access for actual data = **3 total accesses**
- TLB helps but still slower than pure paging

### 4. Small Internal Fragmentation ✗
- Still has internal fragmentation (last page of each segment)
- Multiple segments → multiple last pages → more waste

### 5. Hardware Complexity ✗
- Needs special hardware support
- Expensive to implement
- Not all processors support it

---

## 11. Real-World Examples

### Intel x86 Architecture
- Uses **segmented paging**
- Supports both segmentation and paging
- Segments: Code, Data, Stack, Extra
- Each segment divided into 4KB pages

### Intel 8086 (Old)
- Pure **segmentation**
- Four segments: CS, DS, SS, ES
- 64 KB per segment
- No paging

### Modern Linux/Windows on x86-64
- Primarily use **paging**
- Segmentation minimal (flat memory model)
- 4KB or 2MB pages
- Focus on paging for simplicity

---

## Important Exam Questions & Answers

### Q1. Why is segmentation called a "logical" division?
**Answer:** Segmentation divides program based on **logical structure** (functions, arrays, stack) rather than arbitrary fixed sizes. Each segment has **meaning** to the programmer, reflecting how the program is written.

### Q2. How does segmentation provide better protection than paging?
**Answer:** In segmentation, each **logical unit** (code, data, stack) is a separate segment with its own protection bits. Code can be read-execute only, data read-write. In paging, pages are arbitrary blocks that may contain mixed types of data, making protection harder.

### Q3. What is segmentation fault?
**Answer:** **Segmentation fault** occurs when a process tries to access memory outside its segment limit (offset ≥ limit) or violates protection (writing to read-only segment). Operating system terminates the process.

### Q4. Why use segmented paging instead of pure segmentation?
**Answer:** Pure segmentation suffers from **external fragmentation** (variable-size segments create holes). Segmented paging **eliminates external fragmentation** by dividing segments into fixed-size pages while **preserving logical organization**.

### Q5. Can segments overlap in memory?
**Answer:** No. Segments are **independent** and **non-overlapping**. Each segment has its own base address and exists in separate physical memory area (though segments can share if needed for code sharing).

---

## Quick Formulas
```
SEGMENTATION:
1. Physical Address = Segment Base + Offset
2. Check: Offset < Segment Limit (else TRAP)

SEGMENTED PAGING:
1. Segment Table: Get Page Table Base Address
2. Page Table: Get Frame Number
3. Physical Address = (Frame Number × Page Size) + Offset
4. Check: Page Number < Page Limit
5. Check: Offset < Page Size
```
---

## Comparison Summary Table

| Aspect | Segmentation | Paging | Segmented Paging |
|--------|-------------|--------|------------------|
| Size | Variable | Fixed | Fixed (pages) |
| View | Logical | Physical | Both |
| Fragmentation | External | Internal | Internal |
| Address | 2D | 1D | 3D |
| Tables | 1 Seg Table | 1 Page Table | Seg Table + Multiple PT |
| Translation | 1 step | 1 step | 2 steps |
| Protection | Easy | Hard | Easy |
| Sharing | Easy | Hard | Easy |
| Complexity | Medium | Low | High |

---

## Memory Diagram Examples

### Segmentation Memory Layout
```
Physical Memory
┌──────────────┐ 0
│              │
│   OS         │
│              │
├──────────────┤ 1400 ← Segment 0 Base
│ Main Program │
│   (1000 B)   │
├──────────────┤ 2400
│              │
│   Hole       │
│              │
├──────────────┤ 4300 ← Segment 2 Base
│    Stack     │
│   (400 B)    │
├──────────────┤ 4700
│ Symbol Table │
│  (1000 B)    │
├──────────────┤ 5700
│              │
│   Hole       │
│              │
├──────────────┤ 6300 ← Segment 1 Base
│  Function 1  │
│   (400 B)    │
└──────────────┘
```

---
