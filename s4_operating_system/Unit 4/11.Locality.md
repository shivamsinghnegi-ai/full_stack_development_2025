## Locality of Reference

### What is Locality?

**Principle:** Programs tend to reference a relatively small portion of their address space at any instant.

**Types:**

### 1. Temporal Locality
**Concept:** Recently accessed items likely to be accessed again soon

**Examples:**
- Loop variables
- Frequently called functions
- Stack frames

```c
// Example: Loop variable 'i' accessed repeatedly
for (int i = 0; i < 100; i++) {
    sum += i;  // 'i' has temporal locality
}
```

### 2. Spatial Locality
**Concept:** Items near recently accessed items likely to be accessed soon

**Examples:**
- Array elements (sequential access)
- Sequential instruction execution
- Data structures in contiguous memory

```c
// Example: Array elements accessed sequentially
int arr[100];
for (int i = 0; i < 100; i++) {
    arr[i] = 0;  // Sequential memory access
}
```

### Locality Graph

```
Page
Refs
 |   ****                    ****
 |  *    *                  *    *
 | *      *                *      *
 |*        ****        ****        ****
 |____________________________________________ Time
  
  Locality 1  Transition  Locality 2  Transition
```

### Working Set and Locality

**Relationship:**
- Working set represents current locality
- As program moves to new phase, working set changes
- Good locality → Small working set → Fewer page faults

```
Phase 1: Initialization → Pages {1,2,3,4}
Phase 2: Main Loop     → Pages {5,6,7,8}
Phase 3: Cleanup       → Pages {9,10,11}

Each phase has its own locality
```

### Impact on Virtual Memory

**Good Locality:**
✓ Small working set
✓ Low page fault rate
✓ Better performance
✓ Less thrashing risk

**Poor Locality:**
✗ Large working set
✗ High page fault rate
✗ Poor performance
✗ Thrashing risk

### Exploiting Locality in Design

#### Programming Practices:
1. **Keep related data together**
   - Structs, objects
   - Arrays instead of scattered variables

2. **Access data sequentially**
   - Row-major order for arrays
   - Sequential file processing

3. **Minimize function calls**
   - Inline small functions
   - Reduce call overhead

4. **Optimize loops**
   - Keep loop bodies small
   - Access data in cache-friendly order

#### Example: Matrix Access

**Good Locality (Row-major):**
```c
// Accesses memory sequentially
for (i = 0; i < N; i++)
    for (j = 0; j < N; j++)
        sum += matrix[i][j];
```

**Poor Locality (Column-major in C):**
```c
// Jumps across memory
for (j = 0; j < N; j++)
    for (i = 0; i < N; i++)
        sum += matrix[i][j];
```

---

## Summary & Key Points for Exam

### Page Replacement Algorithms

| Algorithm | Complexity | Page Faults | Anomaly | Practical |
|-----------|------------|-------------|---------|-----------|
| FIFO | Low | High | Yes | No |
| Optimal | N/A | Lowest | No | No (theoretical) |
| LRU | High | Low | No | No (too expensive) |
| Second Chance | Medium | Medium | No | **Yes** |

### Critical Formulas
```
1. Page Fault Rate = Page Faults / Total References

2. For comparison: Count page faults for same reference string

3. Belady's Anomaly: More frames → More faults (FIFO only)
```

### Thrashing Key Points
- High page fault rate
- CPU utilization drops
- Caused by insufficient frames
- Prevented by: Working Set, PFF, Local Replacement

### Locality Types
- **Temporal:** Recently used → Use again soon
- **Spatial:** Nearby items → Use soon
- Good locality → Low page faults

---

## Practice Problems

### Problem 1: Page Replacement
```
Reference string: 7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1
Frames = 4

Calculate page faults for:
a) FIFO
b) Optimal
c) LRU
```

### Problem 2: Thrashing
```
Given:
- 100 processes
- Each needs minimum 10 frames
- Available frames = 500

Questions:
a) Can all processes run without thrashing?
b) What's maximum degree of multiprogramming?
c) Suggest prevention strategy
```

### Problem 3: Working Set
```
Reference string: 1,2,3,4,5,1,2,1,2,3,1,5,1,2,1,2,3,4,5,6

Questions:
a) Working set at time t=15 (window Δ=6)
b) Working set at time t=20 (window Δ=6)
c) Working set size
```

### Problem 4: Locality
```
Analyze locality in this code:
for (int i = 0; i < 1000; i++)
    for (int j = 0; j < 1000; j++)
        array[j][i] = i + j;

a) Identify spatial locality issues
b) Suggest optimization
c) Explain impact on page faults
```

---
