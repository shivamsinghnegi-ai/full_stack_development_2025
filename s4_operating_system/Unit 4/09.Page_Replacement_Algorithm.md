## Page Replacement Algorithms

### Need for Page Replacement

**Scenario:** Page fault occurs, but no free frames available

**Solution:** Select a victim page and replace it

```
Page Fault → No Free Frame → Replace a Page
```

**Goals:**
- Minimize page fault rate
- Select best victim page
- Improve system performance

### Page Replacement Process

**Steps:**
1. Find location of desired page on disk
2. Find a free frame:
   - If free frame exists → Use it
   - If no free frame → Use page replacement algorithm to select victim
3. Read desired page into free frame
4. Update page and frame tables
5. Restart process

### Performance Metrics

**Page Fault Rate = Number of Page Faults / Total References**

Lower page fault rate = Better algorithm

---

## 1.1 FIFO (First-In-First-Out)

### Concept
- Replace the **oldest page** in memory
- Pages kept in a **queue**
- Simplest algorithm

### Algorithm
1. Maintain queue of pages in order of arrival
2. When page fault occurs, replace page at front of queue
3. Add new page to rear of queue

### Example Problem 1

**Given:**
- Reference string: 7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2
- Number of frames: 3

**Find:** Number of page faults using FIFO

**Solution:**

```
Reference:  7   0   1   2   0   3   0   4   2   3   0   3   2
Frame 1:    7   7   7   2   2   2   2   4   4   4   0   0   0
Frame 2:        0   0   0   0   3   3   3   2   2   2   2   2
Frame 3:            1   1   1   1   0   0   0   3   3   3   3
Fault:      ✓   ✓   ✓   ✓       ✓   ✓   ✓   ✓   ✓       ✓       

Total Page Faults = 10
```

**Step-by-step:**
- 7: Frame empty → Load 7 (Fault)
- 0: Frame empty → Load 0 (Fault)
- 1: Frame empty → Load 1 (Fault)
- 2: All full, replace 7 (oldest) → Load 2 (Fault)
- 0: Already present (No fault)
- 3: Replace 0 (oldest) → Load 3 (Fault)
- And so on...

### Belady's Anomaly

**Definition:** Increasing number of frames may **increase** page faults!

### Example: Belady's Anomaly

**Reference string:** 1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5

**With 3 frames:**
```
Reference:  1   2   3   4   1   2   5   1   2   3   4   5
Frame 1:    1   1   1   4   4   4   4   4   4   3   3   3
Frame 2:        2   2   2   1   1   5   5   5   5   4   4
Frame 3:            3   3   3   2   2   1   1   1   1   5
Faults:     ✓   ✓   ✓   ✓   ✓   ✓   ✓   ✓   ✓   ✓   ✓   ✓

Total = 9 page faults
```

**With 4 frames:**
```
Reference:  1   2   3   4   1   2   5   1   2   3   4   5
Frame 1:    1   1   1   1   1   1   1   1   1   1   1   1
Frame 2:        2   2   2   2   2   2   2   2   2   2   5
Frame 3:            3   3   3   3   3   3   3   3   3   3
Frame 4:                4   4   4   4   5   5   5   4   4
Faults:     ✓   ✓   ✓   ✓           ✓       ✓       ✓   ✓

Total = 10 page faults (MORE!)
```

**Conclusion:** FIFO suffers from Belady's Anomaly

### Advantages & Disadvantages

| Advantages | Disadvantages |
|------------|---------------|
| Simple to implement | Poor performance |
| Low overhead | Belady's Anomaly |
| Easy to understand | May replace frequently used pages |

---

## 1.2 Optimal Page Replacement

### Concept
- Replace page that will **not be used for longest time** in future
- Also called: **MIN** or **OPT** algorithm
- **Theoretically optimal** (lowest page fault rate)

### Algorithm
1. Look ahead in reference string
2. Find page that won't be used for longest time
3. Replace that page

### Example Problem

**Given:**
- Reference string: 7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2
- Number of frames: 3

**Find:** Number of page faults using Optimal

**Solution:**

```
Reference:  7   0   1   2   0   3   0   4   2   3   0   3   2
Frame 1:    7   7   7   2   2   2   2   2   2   2   2   2   2
Frame 2:        0   0   0   0   0   0   0   0   0   0   0   0
Frame 3:            1   1   1   3   3   4   4   3   3   3   3
Fault:      ✓   ✓   ✓   ✓       ✓       ✓       ✓            

Total Page Faults = 7
```

**Explanation at key points:**
- Position 5 (reference 3): 
  - Current: [2, 0, 1]
  - Future usage: 1 used at position 8, 0 used at position 6, 2 used at position 8
  - 0 used earliest (position 6) → Replace 1 (used latest)
  
### Why Optimal is Best?
- Guaranteed minimum page faults
- No Belady's Anomaly
- Best possible performance

### Why Not Used in Practice?
**Problem:** Requires **future knowledge**
- Cannot predict future page references
- Only useful for comparison/benchmarking

### Use of Optimal Algorithm
- **Benchmark** for other algorithms
- Compare real algorithms with optimal
- Research and simulation

---

## 1.3 LRU (Least Recently Used)

### Concept
- Replace page that has **not been used for longest time**
- Based on **past behavior** (approximates optimal)
- Uses **principle of locality**

### Algorithm
1. Track time of last use for each page
2. When page fault occurs, replace page with oldest timestamp
3. Update timestamp on every page reference

### Example Problem

**Given:**
- Reference string: 7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2
- Number of frames: 3

**Find:** Number of page faults using LRU

**Solution:**

```
Reference:  7   0   1   2   0   3   0   4   2   3   0   3   2
Frame 1:    7   7   7   2   2   2   2   4   4   4   0   0   0
Frame 2:        0   0   0   0   0   0   0   2   2   2   2   2
Frame 3:            1   1   1   3   3   3   3   3   3   3   3
Fault:      ✓   ✓   ✓   ✓       ✓       ✓   ✓   ✓   ✓        

Total Page Faults = 9
```

**Detailed tracking:**
```
After ref 7: [7]                    Last used: 7(1)
After ref 0: [7, 0]                 Last used: 7(1), 0(2)
After ref 1: [7, 0, 1]              Last used: 7(1), 0(2), 1(3)
After ref 2: [2, 0, 1]              Last used: 0(2), 1(3), 2(4)  [7 removed - LRU]
After ref 0: [2, 0, 1]              Last used: 1(3), 2(4), 0(5)  [0 updated]
After ref 3: [2, 0, 3]              Last used: 2(4), 0(5), 3(6)  [1 removed - LRU]
...and so on
```

### Implementation Methods

#### Method 1: Counter Implementation
- Each page entry has counter (timestamp)
- Increment counter on every memory access
- On page fault, search for page with smallest counter

**Problem:** Search time + overhead

#### Method 2: Stack Implementation
- Keep stack of page numbers
- On page reference:
  - Remove page from middle (if present)
  - Push on top of stack
- Bottom of stack = LRU page

```
Example with references: A, B, C, D, B

After A:     After B:     After C:     After D:     After B:
Top → A      Top → B      Top → C      Top → D      Top → B
              ↓ A          ↓ B          ↓ C          ↓ D
                           ↓ A          ↓ B          ↓ C
                                        ↓ A          ↓ A
LRU → A      LRU → A      LRU → A      LRU → A      LRU → A
```

**Advantage:** No search required
**Disadvantage:** Expensive stack operations

### Advantages & Disadvantages

| Advantages | Disadvantages |
|------------|---------------|
| Good approximation of optimal | Implementation overhead |
| No Belady's Anomaly | Requires hardware support |
| Good performance | Expensive counter/stack updates |
| Considers recency | Not practical in pure form |

---

## 1.4 LRU Approximation Algorithms

### Why Approximations?
- Pure LRU too expensive to implement
- Need hardware support for every memory reference
- Approximations provide **good performance** with **less overhead**

---

### A. Second Chance Algorithm (Clock Algorithm)

#### Concept
- Uses **Reference Bit** (R bit) for each page
- Approximates FIFO with second chance
- Also called: **Clock Algorithm**

#### Reference Bit
- Set to 1 when page is referenced
- Checked during replacement
- Gives page a "second chance"

#### Algorithm

```
1. Arrange pages in circular queue (clock)
2. Keep pointer to next victim
3. When page fault occurs:
   a. Check page at pointer
   b. If R = 0: Replace this page
   c. If R = 1: Set R = 0, move pointer, check next page
   d. Repeat until page with R = 0 found
```

#### Visual Representation

```
        Page C (R=1)
              ↑
    Page B    |    Page D
    (R=0) ←---|--→ (R=1)
              |
        Page A (R=1)
```

#### Example

**Given:**
- Pages in memory: A, B, C, D (circular)
- Reference bits: A=1, B=0, C=1, D=1
- Pointer at A
- New page E needs to be loaded

**Process:**
```
Step 1: Check A (R=1) → Set R=0, move pointer
Step 2: Check B (R=0) → Replace B with E

Result: B replaced, E loaded
```

#### Advantages
✓ Better than FIFO
✓ Simple implementation
✓ Low overhead
✓ One reference bit sufficient

---

### B. Enhanced Second Chance Algorithm

#### Concept
Uses **two bits**: Reference bit (R) and Modify bit (M)

**Four classes:**
1. (R=0, M=0): Not recently used, not modified → **Best to replace**
2. (R=0, M=1): Not recently used, but modified → Replace if no class 1
3. (R=1, M=0): Recently used, not modified → Give second chance
4. (R=1, M=1): Recently used and modified → **Worst to replace**

#### Algorithm
1. Scan for class (0,0) → Replace if found
2. If not found, scan for class (0,1) → Replace if found
3. During scan, set R=0 for all pages
4. If no class (0,0) or (0,1), scan again (now R bits are cleared)

**Advantage:** Prefers clean pages (not modified) to avoid disk write

---

### C. Counting Algorithms

#### 1. LFU (Least Frequently Used)
- Replace page with **smallest reference count**
- Keep counter for each page
- Increment on each reference

**Problem:** 
- Page used heavily initially but not later → High count, but not needed
- Recently loaded pages always have low count

**Example:**
```
Page A: Count = 10 (used heavily early, not used now)
Page B: Count = 2 (recently loaded, frequently used now)

LFU replaces B (wrong choice!)
```

#### 2. MFU (Most Frequently Used)
- Replace page with **largest reference count**
- Logic: Page with smallest count was just brought in

**Problem:** Counterintuitive, not commonly used

---

## 1.5 Comparison of Algorithms

### Comprehensive Example

**Reference string:** 1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5
**Number of frames:** 3

#### FIFO
```
Reference:  1   2   3   4   1   2   5   1   2   3   4   5
Frame 1:    1   1   1   4   4   4   4   4   4   3   3   3
Frame 2:        2   2   2   1   1   5   5   5   5   4   4
Frame 3:            3   3   3   2   2   1   1   1   1   5

Page Faults: 9
```

#### Optimal
```
Reference:  1   2   3   4   1   2   5   1   2   3   4   5
Frame 1:    1   1   1   1   1   1   1   1   1   1   4   4
Frame 2:        2   2   4   4   4   4   4   4   3   3   3
Frame 3:            3   3   3   3   5   5   5   5   5   5

Page Faults: 6 (Optimal!)
```

#### LRU
```
Reference:  1   2   3   4   1   2   5   1   2   3   4   5
Frame 1:    1   1   1   4   4   4   4   4   4   3   3   3
Frame 2:        2   2   2   1   1   1   1   1   1   4   4
Frame 3:            3   3   3   2   5   5   5   5   5   5

Page Faults: 8
```

### Algorithm Comparison Table

| Algorithm | Page Faults | Implementation | Overhead | Anomaly |
|-----------|-------------|----------------|----------|---------|
| FIFO | 9 | Simple | Low | Yes |
| Optimal | 6 | Impossible | N/A | No |
| LRU | 8 | Complex | High | No |
| Second Chance | ~9 | Moderate | Low | No |

### Performance Ranking
```
Best  → Optimal (6 faults)
       ↓
       LRU (8 faults)
       ↓
Worst → FIFO (9 faults)
```

### Practical Choice
**LRU Approximations (Second Chance)** - Best trade-off between:
- Performance (close to LRU)
- Implementation complexity (simple)
- Overhead (low)

---

