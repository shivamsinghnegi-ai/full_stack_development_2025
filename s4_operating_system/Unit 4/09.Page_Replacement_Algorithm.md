# Page Replacement Algorithms

---

## Need for Page Replacement

**Scenario:** Page fault occurs, but no free frames available

**Solution:** Select a victim page and replace it

```
Page Fault → No Free Frame → Replace a Page
```

**Goals:**
- Minimize page fault rate
- Select best victim page
- Improve system performance

---

## Page Replacement Process

**Steps:**
1. Find location of desired page on disk
2. Find a free frame:
   - If free frame exists → Use it
   - If no free frame → Use page replacement algorithm to select victim
3. Read desired page into free frame
4. Update page and frame tables
5. Restart process

---

## Performance Metrics

```
Page Fault Rate = Number of Page Faults / Total References

Lower page fault rate = Better algorithm
```

---

## 1. FIFO (First-In-First-Out)

### Concept
- Replace the **oldest page** in memory
- Pages kept in a **queue**
- Simplest algorithm
- Based on **arrival time** (not usage)

### Algorithm
1. Maintain queue of pages in order of arrival
2. When page fault occurs, replace page at front of queue
3. Add new page to rear of queue

### Working Example

**Given:**
- Reference string: 7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2
- Number of frames: 3

**Find:** Number of page faults using FIFO

**Solution:**

```
Reference:  7   0   1   2   0   3   0   4   2   3   0   3   2
─────────────────────────────────────────────────────────────
Frame 1:    7   7   7   2   2   2   2   4   4   4   0   0   0
Frame 2:        0   0   0   0   3   3   3   2   2   2   2   2
Frame 3:            1   1   1   1   0   0   0   3   3   3   3
─────────────────────────────────────────────────────────────
Fault?      ✓   ✓   ✓   ✓       ✓   ✓   ✓   ✓   ✓       ✓       

Total Page Faults = 10
```

**Step-by-step Explanation:**

```
Position 1 (Ref: 7):  Empty → Load 7 → [7, -, -] → Fault ✓
Position 2 (Ref: 0):  Empty → Load 0 → [7, 0, -] → Fault ✓
Position 3 (Ref: 1):  Empty → Load 1 → [7, 0, 1] → Fault ✓
Position 4 (Ref: 2):  Full! Replace oldest (7) → [2, 0, 1] → Fault ✓
Position 5 (Ref: 0):  Present in memory → [2, 0, 1] → No fault
Position 6 (Ref: 3):  Replace oldest (0) → [2, 3, 1] → Fault ✓
Position 7 (Ref: 0):  Replace oldest (1) → [2, 3, 0] → Fault ✓
Position 8 (Ref: 4):  Replace oldest (2) → [4, 3, 0] → Fault ✓
Position 9 (Ref: 2):  Replace oldest (3) → [4, 2, 0] → Fault ✓
Position 10 (Ref: 3): Replace oldest (0) → [4, 2, 3] → Fault ✓
Position 11 (Ref: 0): Replace oldest (4) → [0, 2, 3] → Fault ✓
Position 12 (Ref: 3): Present in memory → [0, 2, 3] → No fault
Position 13 (Ref: 2): Present in memory → [0, 2, 3] → No fault

Total: 10 page faults
```

---

### Belady's Anomaly (Important!)

**Definition:** Increasing number of frames may **increase** page faults!

This is a strange phenomenon unique to FIFO.

### Example: Belady's Anomaly

**Reference string:** 1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5

**With 3 frames:**
```
Reference:  1   2   3   4   1   2   5   1   2   3   4   5
─────────────────────────────────────────────────────────
Frame 1:    1   1   1   4   4   4   4   4   4   3   3   3
Frame 2:        2   2   2   1   1   5   5   5   5   4   4
Frame 3:            3   3   3   2   2   1   1   1   1   5
─────────────────────────────────────────────────────────
Faults:     ✓   ✓   ✓   ✓   ✓   ✓   ✓   ✓   ✓   ✓   ✓   ✓

Total = 9 page faults
```

**With 4 frames (MORE FRAMES!):**
```
Reference:  1   2   3   4   1   2   5   1   2   3   4   5
─────────────────────────────────────────────────────────
Frame 1:    1   1   1   1   1   1   1   1   1   1   1   1
Frame 2:        2   2   2   2   2   2   2   2   2   2   5
Frame 3:            3   3   3   3   3   3   3   3   3   3
Frame 4:                4   4   4   4   5   5   5   4   4
─────────────────────────────────────────────────────────
Faults:     ✓   ✓   ✓   ✓               ✓       ✓       ✓   ✓

Total = 10 page faults (MORE than with 3 frames!)
```

**Conclusion:** 
- 3 frames → 9 faults
- 4 frames → 10 faults (WORSE!)
- This anomaly makes FIFO unpredictable

---

### FIFO - Advantages & Disadvantages

**Advantages:**
- ✓ Very simple to implement
- ✓ Low overhead
- ✓ Easy to understand
- ✓ No need for hardware support

**Disadvantages:**
- ✗ Poor performance
- ✗ Suffers from Belady's Anomaly
- ✗ May replace frequently used pages
- ✗ Doesn't consider page usage pattern

---

## 2. Optimal Page Replacement (OPT/MIN)

### Concept
- Replace page that will **not be used for longest time** in future
- Also called: **MIN** or **OPT** algorithm
- **Theoretically optimal** - guaranteed minimum page faults
- No Belady's Anomaly

### Algorithm
1. Look ahead in reference string
2. Find page that won't be used for longest time in future
3. If a page will never be used again, replace it first
4. Replace that page

### Working Example

**Given:**
- Reference string: 7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2
- Number of frames: 3

**Find:** Number of page faults using Optimal

**Solution:**

```
Reference:  7   0   1   2   0   3   0   4   2   3   0   3   2
─────────────────────────────────────────────────────────────
Frame 1:    7   7   7   2   2   2   2   2   2   2   2   2   2
Frame 2:        0   0   0   0   0   0   0   0   0   0   0   0
Frame 3:            1   1   1   3   3   4   4   3   3   3   3
─────────────────────────────────────────────────────────────
Fault?      ✓   ✓   ✓   ✓       ✓       ✓       ✓            

Total Page Faults = 7 (Minimum possible!)
```

**Detailed Decision Points:**

```
Position 4 (Ref: 2) - Need to replace one of [7, 0, 1]:
Future usage:
- 7: Never used again → Replace 7! ✓
- 0: Used at position 5 (next!)
- 1: Used at position... never

Replace 7 → [2, 0, 1]

─────────────────────────────────────────────

Position 6 (Ref: 3) - Need to replace one of [2, 0, 1]:
Future usage:
- 2: Used at position 9 (3 steps away)
- 0: Used at position 7 (1 step away) ← Earliest!
- 1: Never used again → Replace 1! ✓

Replace 1 → [2, 0, 3]

─────────────────────────────────────────────

Position 8 (Ref: 4) - Need to replace one of [2, 0, 3]:
Future usage:
- 2: Used at position 9 (1 step away) ← Earliest!
- 0: Used at position 11 (3 steps away)
- 3: Used at position 10 (2 steps away) → Replace 3 ✓

Replace 3 → [2, 0, 4]

─────────────────────────────────────────────

Position 10 (Ref: 3) - Need to replace one of [2, 0, 4]:
Future usage:
- 2: Used at position 13 (3 steps away)
- 0: Used at position 11 (1 step away) ← Earliest!
- 4: Never used again → Replace 4! ✓

Replace 4 → [2, 0, 3]
```

---

### Why Optimal is Best?
- ✓ Guaranteed **minimum page faults** possible
- ✓ No Belady's Anomaly
- ✓ Best possible performance theoretically

### Why Not Used in Practice?

**Problem:** Requires **future knowledge**
- OS cannot predict which pages will be referenced in future
- Would need to know entire execution sequence beforehand
- Impossible to implement in real systems

### Use of Optimal Algorithm
- **Benchmark** to compare other algorithms
- **Research** and simulation studies
- **Upper bound** on performance (best we can achieve)

---

### Optimal - Advantages & Disadvantages

**Advantages:**
- ✓ Minimum page faults guaranteed
- ✓ No Belady's Anomaly
- ✓ Best theoretical performance
- ✓ Useful for comparison

**Disadvantages:**
- ✗ Requires future knowledge (impossible!)
- ✗ Cannot be implemented in practice
- ✗ Only used for benchmarking

---

## 3. LRU (Least Recently Used)

### Concept
- Replace page that has **not been used for longest time**
- Based on **past usage** (approximates optimal)
- Uses **principle of locality**
- Most practical algorithm that's close to optimal

### Algorithm
1. Track time of last use for each page
2. When page fault occurs, replace page with oldest timestamp (used longest ago)
3. Update timestamp on every page reference

### Working Example

**Given:**
- Reference string: 7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2
- Number of frames: 3

**Find:** Number of page faults using LRU

**Solution:**

```
Reference:  7   0   1   2   0   3   0   4   2   3   0   3   2
─────────────────────────────────────────────────────────────
Frame 1:    7   7   7   2   2   2   2   4   4   4   0   0   0
Frame 2:        0   0   0   0   0   0   0   2   2   2   2   2
Frame 3:            1   1   1   3   3   3   3   3   3   3   3
─────────────────────────────────────────────────────────────
Fault?      ✓   ✓   ✓   ✓       ✓       ✓   ✓   ✓   ✓        

Total Page Faults = 9
```

**Detailed Tracking with Last Use Time:**

```
Position 1 (Ref: 7):
[7] → Last used: 7(1) → Fault ✓

Position 2 (Ref: 0):
[7, 0] → Last used: 7(1), 0(2) → Fault ✓

Position 3 (Ref: 1):
[7, 0, 1] → Last used: 7(1), 0(2), 1(3) → Fault ✓

Position 4 (Ref: 2):
Which is LRU? 7 used at position 1 (longest ago)
Replace 7 → [2, 0, 1] → Last used: 0(2), 1(3), 2(4) → Fault ✓

Position 5 (Ref: 0):
0 already present, update usage
[2, 0, 1] → Last used: 1(3), 2(4), 0(5) → No fault

Position 6 (Ref: 3):
Which is LRU? 1 used at position 3 (longest ago)
Replace 1 → [2, 0, 3] → Last used: 2(4), 0(5), 3(6) → Fault ✓

Position 7 (Ref: 0):
0 already present, update usage
[2, 0, 3] → Last used: 2(4), 3(6), 0(7) → No fault

Position 8 (Ref: 4):
Which is LRU? 2 used at position 4 (longest ago)
Replace 2 → [4, 0, 3] → Last used: 3(6), 0(7), 4(8) → Fault ✓

Position 9 (Ref: 2):
Which is LRU? 3 used at position 6 (longest ago)
Replace 3 → [4, 0, 2] → Last used: 0(7), 4(8), 2(9) → Fault ✓

Position 10 (Ref: 3):
Which is LRU? 0 used at position 7 (longest ago)
Replace 0 → [4, 2, 3] → Last used: 4(8), 2(9), 3(10) → Fault ✓

Position 11 (Ref: 0):
Which is LRU? 4 used at position 8 (longest ago)
Replace 4 → [0, 2, 3] → Last used: 2(9), 3(10), 0(11) → Fault ✓

Position 12 (Ref: 3):
3 already present, update usage
[0, 2, 3] → Last used: 2(9), 0(11), 3(12) → No fault

Position 13 (Ref: 2):
2 already present, update usage
[0, 2, 3] → Last used: 0(11), 3(12), 2(13) → No fault

Total: 9 page faults
```

---

### Implementation Methods

**Method 1: Counter/Timestamp Implementation**

```
Page Table Entry:
┌─────────┬─────────┬───────────┐
│ Frame # │ Valid   │ Counter   │
└─────────┴─────────┴───────────┘

- Logical clock/counter increments on every reference
- Each page gets timestamp when accessed
- On page fault: Replace page with smallest counter

Problem: Overhead of updating counter on every access
```

**Method 2: Stack Implementation**

```
Keep stack of page numbers:
- Most recently used → Top of stack
- Least recently used → Bottom of stack

On page access:
1. If page in stack: Remove from middle
2. Push page on top

On page fault: Remove bottom (LRU)

Example: Access sequence A, B, C, D, B

After A:  [A]         Top = A, Bottom = A
After B:  [B, A]      Top = B, Bottom = A  
After C:  [C, B, A]   Top = C, Bottom = A
After D:  [D, C, B, A] (if 4 frames)
After B:  [B, D, C, A] (B moved to top)

Problem: Stack manipulation expensive
```

---

### LRU - Advantages & Disadvantages

**Advantages:**
- ✓ Good approximation of optimal
- ✓ No Belady's Anomaly
- ✓ Good performance in practice
- ✓ Exploits locality of reference
- ✓ Better than FIFO

**Disadvantages:**
- ✗ High implementation overhead
- ✗ Requires hardware support
- ✗ Expensive to update on every access
- ✗ Not practical in pure form (use approximations)

---

## 4. MRU (Most Recently Used)

### Concept
- Replace the **most recently used** page
- Opposite of LRU
- Counter-intuitive but useful in specific scenarios
- Based on assumption: Just-used page unlikely to be needed again soon

### When MRU Works Well?

**Scenario: Sequential File Scanning**

```
Reading large file sequentially:
Page 1 → Read → Won't need again
Page 2 → Read → Won't need again
Page 3 → Read → Won't need again
...

Here, most recently used page is LEAST likely to be needed!
```

**Example use cases:**
- Database table scans
- One-time sequential file processing
- Batch processing of records
- Looping through large datasets once

### Algorithm
1. Track time of last use for each page
2. When page fault occurs, replace **most recently used** page
3. Update timestamp on every page reference

---

### Working Example

**Given:**
- Reference string: 1, 2, 3, 4, 2, 1, 5, 6, 2, 1, 2, 3, 7, 6, 3
- Number of frames: 4

**Find:** Number of page faults using MRU

**Solution:**

```
Reference:  1   2   3   4   2   1   5   6   2   1   2   3   7   6   3
─────────────────────────────────────────────────────────────────────
Frame 1:    1   1   1   1   1   1   1   1   1   1   1   1   1   1   1
Frame 2:        2   2   2   2   2   2   2   2   2   2   2   2   2   2
Frame 3:            3   3   3   3   3   3   3   3   3   3   3   3   3
Frame 4:                4   4   4   5   6   6   6   6   6   7   7   7
─────────────────────────────────────────────────────────────────────
Fault?      ✓   ✓   ✓   ✓           ✓   ✓               ✓           

Total Page Faults = 7
```

**Detailed Step-by-step:**

```
Position 1 (Ref: 1): Empty → Load 1 → [1, -, -, -] → Fault ✓
Position 2 (Ref: 2): Empty → Load 2 → [1, 2, -, -] → Fault ✓
Position 3 (Ref: 3): Empty → Load 3 → [1, 2, 3, -] → Fault ✓
Position 4 (Ref: 4): Empty → Load 4 → [1, 2, 3, 4] → Fault ✓

Position 5 (Ref: 2): Already present → [1, 2, 3, 4] → No fault
                     (2 now MRU)

Position 6 (Ref: 1): Already present → [1, 2, 3, 4] → No fault
                     (1 now MRU)

Position 7 (Ref: 5): Need replacement
                     MRU = 1 (last accessed)
                     Replace 1 → [5, 2, 3, 4] → Fault ✓

Position 8 (Ref: 6): MRU = 5 (just loaded)
                     Replace 5 → [6, 2, 3, 4] → Fault ✓

Position 9 (Ref: 2): Already present → [6, 2, 3, 4] → No fault
                     (2 now MRU)

Position 10 (Ref: 1): MRU = 2, but need to load 1
                      Replace 2 → [6, 1, 3, 4] → Fault ✓

Position 11 (Ref: 2): MRU = 1, but need to load 2
                      Replace 1 → [6, 2, 3, 4] → Fault ✓

Position 12 (Ref: 3): Already present → [6, 2, 3, 4] → No fault
                      (3 now MRU)

Position 13 (Ref: 7): MRU = 3
                      Replace 3 → [6, 2, 7, 4] → Fault ✓

Position 14 (Ref: 6): Already present → [6, 2, 7, 4] → No fault
                      (6 now MRU)

Position 15 (Ref: 3): MRU = 6, but need to load 3
                      Replace 6 → [3, 2, 7, 4] → Fault ✓

Total: 10 page faults
```

---

### Comparison Example: MRU vs LRU

**Reference string:** 1, 2, 3, 4, 1, 2, 5, 6
**Frames:** 3

**LRU:**
```
Reference:  1   2   3   4   1   2   5   6
─────────────────────────────────────────
Frame 1:    1   1   1   4   4   4   4   4
Frame 2:        2   2   2   1   1   5   5
Frame 3:            3   3   3   2   2   6
─────────────────────────────────────────
Fault?      ✓   ✓   ✓   ✓   ✓   ✓   ✓   ✓

LRU Faults = 8
```

**MRU:**
```
Reference:  1   2   3   4   1   2   5   6
─────────────────────────────────────────
Frame 1:    1   1   1   1   1   2   2   2
Frame 2:        2   2   2   2   5   5   5
Frame 3:            3   4   4   4   4   6
─────────────────────────────────────────
Fault?      ✓   ✓   ✓   ✓       ✓   ✓   ✓

MRU Faults = 7 (Better in this case!)
```

---

### MRU - Advantages & Disadvantages

**Advantages:**
- ✓ Good for sequential access patterns
- ✓ Better than LRU for certain workloads
- ✓ Simple to implement (same as LRU)
- ✓ No Belady's Anomaly
- ✓ Effective for database table scans

**Disadvantages:**
- ✗ Counter-intuitive (seems wrong!)
- ✗ Poor performance for most general workloads
- ✗ Only good for specific access patterns
- ✗ Requires hardware support like LRU
- ✗ Not commonly used in general-purpose OS

---

## Complete Comparison - All 4 Algorithms

### Comparison Table

```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Algorithm  │ Basis        │ Complexity │ Belady's │ Practical? │ Use Case
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
FIFO       │ Arrival time │ Low        │ YES ✗    │ NO         │ None
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Optimal    │ Future use   │ Impossible │ NO ✓     │ NO         │ Benchmark
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
LRU        │ Past use     │ High       │ NO ✓     │ YES ✓      │ General OS
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
MRU        │ Recent use   │ High       │ NO ✓     │ Limited    │ Sequential
           │ (opposite)   │            │          │            │ scans
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

---

### Performance Comparison (Same Reference String)

**Reference string:** 7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2
**Frames:** 3

```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Algorithm      │  Page Faults
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
FIFO           │      10
Optimal (MIN)  │       7  ← Best!
LRU            │       9
MRU            │      11  ← Worst for this pattern
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

---

### Key Differences

```
┌────────────────────────────────────────────────────────┐
│                                                        │
│  FIFO:     Replace OLDEST arrival                      │
│  LRU:      Replace OLDEST use (longest time ago)       │
│  MRU:      Replace NEWEST use (just now)               │
│  Optimal:  Replace FARTHEST future use                 │
│                                                        │
└────────────────────────────────────────────────────────┘
```

---

### Which Algorithm to Use?

```
Workload Type               →  Recommended Algorithm
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
General purpose OS          →  LRU (or approximation)
Sequential file processing  →  MRU
Benchmarking/Research       →  Optimal
Simple/Educational          →  FIFO
```

---

## Practice Problems for Exam

### Problem 1 (Must Practice!)

**Given:**
Reference string: 1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5
Frames: 3

**Calculate page faults for:**
a) FIFO
b) Optimal
c) LRU
d) MRU

**Also:** Show which has minimum faults.

---

### Problem 2 (Belady's Anomaly)

**Given:**
Reference string: 3, 2, 1, 0, 3, 2, 4, 3, 2, 1, 0, 4
Frames: 3 and 4

Using **FIFO only**, show:
- Page faults with 3 frames
- Page faults with 4 frames
- Does Belady's Anomaly occur?

---

### Problem 3 (Comparison)

**Given:**
Reference string: 7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1
Frames: 4

**Calculate and compare:**
- FIFO faults
- LRU faults
- Which is better?

---

### Problem 4 (MRU Special Case)

**Given:**
Sequential access pattern: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10
Frames: 3

**Compare:**
- LRU page faults
- MRU page faults
- Which works better for sequential access?

---

## Exam Tips & Common Questions

### 5-Mark Questions
1. Explain any two page replacement algorithms with examples.
2. What is Belady's Anomaly? Demonstrate with example.
3. Compare FIFO and LRU algorithms.
4. Explain MRU algorithm. When is it useful?

### 10-Mark Questions
1. Given reference string, calculate page faults for FIFO, LRU, and Optimal. Compare results.
2. Explain all page replacement algorithms with advantages and disadvantages.
3. What is optimal page replacement? Why can't it be implemented? Compare with LRU.

---

## Quick Revision Formulas

```
┌─────────────────────────────────────────────────────┐
│                                                     │
│  Page Fault Rate = Page Faults / Total References   │
│                                                     │
│  Lower rate = Better algorithm                      │
│                                                     │
└─────────────────────────────────────────────────────┘
```

---
