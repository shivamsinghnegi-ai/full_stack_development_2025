## Paging - Principle of Operation

### Why Paging?
- **Problem:** Fixed partitions lead to fragmentation
- **Solution:** Divide memory into small fixed-size blocks
- **Benefit:** Eliminates external fragmentation, minimizes internal fragmentation

### Basic Concept

**Physical Memory:** Divided into fixed-size blocks called **FRAMES**
**Logical Memory:** Divided into fixed-size blocks called **PAGES**

- Page size = Frame size (typically 4KB, 8KB, etc.)
- Pages are loaded into any available frames (non-contiguous)

### Memory Organization

```
Logical Memory (Process)      Physical Memory (RAM)
|  Page 0  |                  |  Frame 0  | ← OS
|  Page 1  |                  |  Frame 1  | ← Page 3
|  Page 2  |                  |  Frame 2  | ← Page 1
|  Page 3  |                  |  Frame 3  | ← Page 0
                              |  Frame 4  | ← Page 2
                              |  Frame 5  | (Free)
```

### Address Translation

#### Logical Address Structure
```
| Page Number (p) | Page Offset (d) |
```

- **Page Number (p):** Index into page table
- **Page Offset (d):** Location within the page

#### Physical Address Structure
```
| Frame Number (f) | Page Offset (d) |
```

**Formula:**
- If logical address space = 2^m bytes
- Page size = 2^n bytes
- Then: Page number bits = m - n, Offset bits = n

### Page Table

- **Purpose:** Maps logical pages to physical frames
- **Contents:** Frame number for each page
- **Location:** Maintained by OS in main memory

```
Page Table
Page #  |  Frame #
--------|----------
   0    |    3
   1    |    2
   2    |    4
   3    |    1
```

### Address Translation Process

**Step-by-step:**

1. Extract page number (p) from logical address
2. Use p as index to page table
3. Get frame number (f) from page table
4. Extract offset (d) from logical address
5. Physical address = (f × page size) + d

### Example Problem

**Given:**
- Logical address space = 16 pages
- Page size = 1KB (1024 bytes)
- Logical address = 5120

**Find:** Physical address if Page 5 is in Frame 7

**Solution:**
```
Step 1: Page size = 1024 = 2^10 bytes
Step 2: Page number = 5120 / 1024 = 5
Step 3: Offset = 5120 % 1024 = 0
Step 4: Frame number (from page table) = 7
Step 5: Physical address = (7 × 1024) + 0 = 7168
```

### Internal Fragmentation in Paging

- Only in the last page of a process
- **Average internal fragmentation = Page size / 2**
- **No external fragmentation**

### Advantages of Paging

✓ No external fragmentation
✓ Memory utilization is better
✓ Easy to allocate memory (any free frame)
✓ Easy to swap processes
✓ Process can be larger than physical memory (with virtual memory)

### Disadvantages of Paging

✗ Internal fragmentation (last page)
✗ Overhead of page table storage
✗ Memory access time increases (table lookup)

---

