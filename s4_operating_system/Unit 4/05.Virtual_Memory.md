# Virtual Memory

## 1. Concept of Virtual Memory

### What is Virtual Memory?
**Virtual Memory** is a memory management technique that allows execution of processes that **may not be completely in physical memory**. It gives the illusion of a very large main memory.

### Basic Idea
- Process **doesn't need to be entirely** in memory to execute
- Only **required pages/segments** are loaded
- Rest stays on **disk** (secondary storage)
- Programs can be **larger than physical RAM**
```
Virtual Memory Concept
┌─────────────────────┐
│   Virtual Memory    │  ← Programmer sees this
│    (e.g., 4 GB)     │     (Logical view)
└──────────┬──────────┘
           │
           ▼
┌─────────────────────┐
│  Physical Memory    │  ← Actually available
│    (e.g., 512 MB)   │     (Real RAM)
└──────────┬──────────┘
           │
           ▼
┌─────────────────────┐
│   Disk (Swap)       │  ← Rest stored here
│    (e.g., 2 GB)     │     (Slow storage)
└─────────────────────┘
```

### Key Terminology

**1. Virtual Address Space**
- Address space seen by the **process**
- Can be **larger** than physical memory
- Example: 32-bit system = 4 GB virtual space

**2. Physical Address Space**
- **Actual RAM** available
- Example: 512 MB RAM

**3. Virtual Address**
- Address generated by **CPU** (logical address)
- May or may not be in physical memory

**4. Physical Address**
- **Real address** in RAM

**5. Address Mapping**
- Virtual address → Physical address translation
- Done by **MMU (Memory Management Unit)**

---

## 2. Why Virtual Memory?

### Problems Without Virtual Memory
- Program size limited by physical RAM
- Multiprogramming difficult (limited processes)
- Memory waste (entire process must be loaded)
- No memory isolation between processes

### Advantages of Virtual Memory

**1. Large Address Space**
✓ Programs can be **larger than physical RAM**
✓ Example: Run 2 GB program on 512 MB RAM

**2. More Processes**
✓ **Higher degree of multiprogramming**
✓ More processes can run simultaneously
✓ Better CPU utilization

**3. Protection**
✓ Each process has **separate virtual address space**
✓ One process **cannot access** another's memory
✓ Security and isolation

**4. Efficient Memory Use**
✓ Load only **needed pages**
✓ Rarely used code stays on disk
✓ Better memory utilization

**5. Sharing**
✓ Multiple processes can **share code** (libraries)
✓ Save memory
✓ Example: Multiple programs using same DLL

**6. No Relocation Problem**
✓ Process always sees **same virtual addresses**
✓ Can be loaded anywhere in physical memory
✓ Simplified programming

---

## 3. Demand Paging

### What is Demand Paging?
**Demand Paging** = Pages are loaded into memory **only when demanded** (accessed), not in advance.

### Core Concept
- Initially, **no pages in memory** (or minimal)
- When page is needed → **Page Fault** occurs
- OS loads the page from disk
- **Lazy loading** strategy

### How It Works
```
Process Execution with Demand Paging

1. Process starts → No pages in memory
2. CPU tries to access page 5
3. Page 5 not in memory → PAGE FAULT
4. OS loads page 5 from disk to memory
5. Process continues
6. CPU tries to access page 2
7. Page 2 not in memory → PAGE FAULT
8. OS loads page 2 from disk to memory
9. Process continues...
```

### Valid-Invalid Bit Scheme

Each page table entry has a **valid-invalid bit**:
- **Valid (V)** = Page is in physical memory
- **Invalid (I)** = Page is on disk (not in memory)
```
Page Table with Valid-Invalid Bits
┌──────────┬──────────────┬─────────┐
│ Page No  │ Frame Number │  V/I    │
├──────────┼──────────────┼─────────┤
│    0     │      5       │   V     │ ← In memory
│    1     │      -       │   I     │ ← On disk
│    2     │      3       │   V     │ ← In memory
│    3     │      -       │   I     │ ← On disk
│    4     │      8       │   V     │ ← In memory
└──────────┴──────────────┴─────────┘
```

---

## 4. Page Fault

### What is Page Fault?
**Page Fault** = Exception/trap that occurs when process tries to access a page that is **not in physical memory**.

### Page Fault Not an Error!
- Page fault is **normal** in demand paging
- Simply means page needs to be loaded
- OS handles it **transparently**

### Page Fault Handling Steps
```
Page Fault Handling Process

1. TRAP to OS (interrupt)
   ↓
2. Save process state
   ↓
3. Check if page reference is valid
   - If invalid address → Abort process
   - If valid but not in memory → Continue
   ↓
4. Find free frame in memory
   - If no free frame → Use page replacement
   ↓
5. Issue disk I/O to read page from disk
   ↓
6. Wait for disk I/O (process blocked)
   ↓
7. Update page table (set valid bit)
   ↓
8. Restore process state
   ↓
9. Restart instruction that caused page fault
```

### Page Fault Service Time Components
```
Page Fault Service Time = 
    Trap time
  + Page table check
  + Find free frame
  + Disk read time (MAJOR - slowest)
  + Update page table
  + Restart instruction
```

### Example Scenario

**Process has pages: 0, 1, 2, 3, 4**
**Physical memory can hold: 3 pages**
```
Initial State: No pages in memory
Page Table:
Page 0: Invalid
Page 1: Invalid
Page 2: Invalid
Page 3: Invalid
Page 4: Invalid

Access Page 0:
→ Page Fault! Load Page 0
→ Page 0 now in Frame 1 (Valid)

Access Page 1:
→ Page Fault! Load Page 1
→ Page 1 now in Frame 2 (Valid)

Access Page 0:
→ No page fault (already in memory)
→ Access directly

Access Page 2:
→ Page Fault! Load Page 2
→ Page 2 now in Frame 3 (Valid)

Access Page 3:
→ Page Fault! Memory full!
→ Replace a page (use replacement algorithm)
→ Load Page 3
```

---

## 5. Performance of Demand Paging

### Effective Access Time (EAT)

**EAT** = Average time to access memory considering page faults

### Key Parameters
```
p = Page fault rate (0 ≤ p ≤ 1)
    Example: p = 0.01 means 1% accesses cause page fault

ma = Memory access time
     Typical: 100-200 nanoseconds

pft = Page fault time (very slow!)
      Components:
      - Trap overhead: ~1-10 μs
      - Disk I/O: 8-10 milliseconds (MAJOR)
      - Update tables: ~1-10 μs
      Typical total: 8-10 milliseconds
```

### EAT Formula
```
EAT = (1 - p) × ma + p × pft

Where:
(1 - p) = Probability of NO page fault
p = Probability of page fault
ma = Memory access time (when no fault)
pft = Page fault time (when fault occurs)
```

### Simplified EAT Formula

Since `pft >> ma`, we can approximate:
```
EAT ≈ ma + p × pft
```

### Example Calculations

**Example 1: Basic EAT**
```
Given:
Memory access time (ma) = 200 ns
Page fault time (pft) = 8 ms = 8,000,000 ns
Page fault rate (p) = 0.001 (0.1%)

Solution:
EAT = (1 - p) × ma + p × pft
    = (1 - 0.001) × 200 + 0.001 × 8,000,000
    = 0.999 × 200 + 0.001 × 8,000,000
    = 199.8 + 8,000
    = 8,199.8 ns
    ≈ 8.2 μs

Interpretation:
Without page faults: 200 ns
With 0.1% page faults: 8,200 ns
Slowdown = 41 times!
```

**Example 2: Effect of Page Fault Rate**
```
Given:
ma = 100 ns
pft = 10 ms = 10,000,000 ns

Calculate EAT for different page fault rates:

p = 0.001 (0.1%):
EAT = 100 + 0.001 × 10,000,000
    = 100 + 10,000
    = 10,100 ns

p = 0.01 (1%):
EAT = 100 + 0.01 × 10,000,000
    = 100 + 100,000
    = 100,100 ns

p = 0.1 (10%):
EAT = 100 + 0.1 × 10,000,000
    = 100 + 1,000,000
    = 1,000,100 ns

Conclusion: Even small increase in page fault rate
           drastically increases EAT!
```

**Example 3: Acceptable Performance**
```
Question: 
Maximum acceptable slowdown = 10%
ma = 200 ns
pft = 8 ms = 8,000,000 ns
Find maximum acceptable page fault rate.

Solution:
10% slowdown means: EAT ≤ 1.1 × ma
1.1 × 200 = 220 ns

EAT = ma + p × pft ≤ 220
200 + p × 8,000,000 ≤ 220
p × 8,000,000 ≤ 20
p ≤ 20 / 8,000,000
p ≤ 0.0000025
p ≤ 0.00025%

Answer: Page fault rate must be less than 0.00025%
        (1 page fault per 400,000 accesses)
```

---

## 6. Components of Page Fault Time

### Detailed Breakdown
```
Total Page Fault Time ≈ 8-10 milliseconds

1. Service the page fault interrupt
   Time: 1-100 μs
   
2. Read the page from disk
   Time: 8 milliseconds (DOMINANT - 99% of time)
   
   Breakdown:
   - Seek time: 3-5 ms (move disk head)
   - Rotational latency: 2-4 ms (wait for rotation)
   - Transfer time: 0.5-1 ms (read data)
   
3. Update page tables
   Time: 1-100 μs
   
4. Restart the process
   Time: 1-100 μs
```

### Why Disk I/O Dominates?
```
Comparison (approximate):
Memory access: 100 ns = 0.0001 ms
Disk access: 8 ms = 8,000,000 ns

Disk is 80,000 times slower than RAM!
```

---

## 7. Optimizing Demand Paging Performance

### Goal: Minimize Page Faults

**Strategies:**

**1. Increase Memory Size**
- More frames → More pages can stay in memory
- Reduces page fault rate

**2. Better Page Replacement Algorithms**
- Choose victim page wisely
- Keep frequently used pages in memory

**3. Locality of Reference**
- Programs tend to access nearby memory locations
- If program has good locality → Fewer page faults

**4. Working Set**
- Keep process's working set in memory
- Working set = pages currently in active use

**5. Prepaging**
- Load pages before they're needed (prediction)
- Reduces some page faults

**6. Page Size Selection**
- Larger pages: Less page table overhead, more internal fragmentation
- Smaller pages: More page table overhead, less internal fragmentation
- Typical: 4 KB

---

## 8. Advantages of Demand Paging

✓ **Reduced Memory Usage**
  - Only needed pages loaded
  - More processes can run simultaneously

✓ **Faster Process Start**
  - No need to load entire program
  - Process starts with minimal pages

✓ **Large Programs**
  - Programs larger than RAM can execute
  - Example: 4 GB program on 1 GB RAM

✓ **Better CPU Utilization**
  - More processes in memory
  - Higher multiprogramming degree

✓ **I/O Reduction**
  - Load only what's needed
  - Less disk I/O overall (for multiple processes)

---

## 9. Disadvantages of Demand Paging

✗ **Page Fault Overhead**
  - Each page fault = 8-10 ms delay
  - Can significantly slow execution

✗ **Thrashing Risk**
  - Too many page faults
  - System spends more time paging than executing

✗ **Complex Implementation**
  - Needs sophisticated OS support
  - Page replacement algorithms required

✗ **Unpredictable Performance**
  - Depends on page fault rate
  - Hard to predict execution time

✗ **Disk I/O Bottleneck**
  - Slow disk limits performance
  - SSD helps but still slower than RAM

---

## 10. Pure Demand Paging vs Prepaging

### Pure Demand Paging
- Start process with **no pages** in memory
- Load pages **only on fault**
- First few instructions cause many page faults
- **Lazy approach**

### Prepaging
- Load some pages **before** they're needed
- Predict which pages will be used
- Reduces initial page faults
- **Eager approach**
```
Pure Demand Paging:
Process starts → Fault → Load → Fault → Load → Fault → Load

Prepaging:
Process starts → Load predicted pages → Fewer faults initially
```

**When to Use:**
- Prepaging: Process restart after swap-out
- Demand paging: New process execution

---

## 11. Copy-on-Write (COW)

### Concept
**Copy-on-Write** = Optimization technique for process creation (fork)

### Traditional fork()
```
Parent Process creates Child Process
→ Copy entire parent memory to child
→ Slow and wasteful (child may exec() immediately)
```

### Copy-on-Write fork()
```
Parent Process creates Child Process
→ Parent and child SHARE same pages (read-only)
→ Only copy page when either writes to it
→ Fast and efficient
```

### How COW Works
```
Initially:
Parent and Child point to same physical pages
All pages marked as READ-ONLY

When Child/Parent tries to WRITE to page:
1. Trap occurs (write to read-only page)
2. OS creates a COPY of that page
3. Give copy to writing process
4. Mark both pages as READ-WRITE
5. Continue execution

Result: Only modified pages are copied
```

### Benefits
✓ Fast process creation
✓ Memory efficient
✓ Most processes don't modify all pages

---

## Important Exam Questions & Answers

### Q1. Explain the concept of virtual memory.
**Answer:** Virtual memory is a memory management technique that allows processes to execute even when they're not completely in physical memory. It creates an illusion of large memory by using disk as extension of RAM. Only required pages are kept in memory, rest stay on disk.

### Q2. What is the difference between paging and demand paging?
**Answer:**
- **Paging:** All pages of process loaded into memory
- **Demand Paging:** Pages loaded only when accessed (on demand)
- Demand paging reduces memory usage and allows larger programs

### Q3. What is a page fault? Is it an error?
**Answer:** Page fault is a trap that occurs when CPU tries to access a page not in physical memory. It is NOT an error—it's a normal event in demand paging. OS handles it by loading the required page from disk.

### Q4. Why does page fault severely impact performance?
**Answer:** Page fault requires disk I/O which takes ~8-10 milliseconds, while memory access takes ~100-200 nanoseconds. Disk is about 80,000 times slower than RAM, so even a small page fault rate drastically increases effective access time.

### Q5. What happens during a page fault?
**Answer:**
1. Trap to OS
2. Check if page reference is valid
3. Find free frame (use replacement if needed)
4. Read page from disk to frame
5. Update page table
6. Restart instruction

### Q6. Calculate EAT if ma = 200 ns, pft = 8 ms, p = 0.01
**Answer:**
```
EAT = ma + p × pft
    = 200 + 0.01 × 8,000,000
    = 200 + 80,000
    = 80,200 ns
    = 80.2 μs
```

---

## Quick Formulas
```
1. EAT = (1 - p) × ma + p × pft
   OR
   EAT ≈ ma + p × pft

2. Slowdown factor = EAT / ma

3. Page fault rate = (Number of page faults) / (Total memory accesses)

4. For acceptable performance:
   EAT ≤ (1 + acceptable_slowdown) × ma
   
5. Maximum p for n% slowdown:
   p ≤ (n% × ma) / pft
```

---
## Common Numerical Problems

### Problem 1: Basic EAT
```
Q: ma = 100 ns, pft = 10 ms, p = 0.001. Find EAT.

Solution:
EAT = 100 + 0.001 × 10,000,000
    = 100 + 10,000
    = 10,100 ns
```

### Problem 2: Find Maximum Page Fault Rate
```
Q: Maximum slowdown = 20%, ma = 200 ns, pft = 8 ms. 
   Find maximum p.

Solution:
20% slowdown: EAT ≤ 1.2 × 200 = 240 ns

240 = 200 + p × 8,000,000
40 = p × 8,000,000
p = 40 / 8,000,000
p = 0.000005 = 0.0005%
```

### Problem 3: Compare Two Systems
```
Q: System A: p = 0.001, pft = 8 ms
   System B: p = 0.01, pft = 5 ms
   ma = 200 ns for both. Which is faster?

Solution:
System A: EAT = 200 + 0.001 × 8,000,000 = 8,200 ns
System B: EAT = 200 + 0.01 × 5,000,000 = 50,200 ns

System A is faster (lower EAT)
```

---
