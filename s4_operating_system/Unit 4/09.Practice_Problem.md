## Revision & Problem Solving

### Key Concepts Summary

### Memory Management Hierarchy
```
1. Fixed Partitioning
   ↓
2. Dynamic Partitioning
   ↓
3. Paging
   ↓
4. Segmentation
   ↓
5. Virtual Memory (Demand Paging)
   ↓
6. Working Set Model
```

---

### Formula Sheet

**1. Address Translation (Paging)**
```
Logical Address bits = Page bits + Offset bits
Page Number = Logical Address / Page Size
Offset = Logical Address % Page Size
Physical Address = (Frame Number × Page Size) + Offset
Number of Pages = Logical Address Space / Page Size
```

**2. Effective Access Time**
```
EAT = (1-p) × ma + p × pft
OR
EAT = ma + p × pft  (simplified)

where:
p = page fault rate
ma = memory access time
pft = page fault time
```

**3. Fragmentation**
```
Internal Fragmentation = Partition Size - Process Size
External Fragmentation = Total Free - Largest Contiguous Block
```

**4. Page Fault Metrics**
```
Page Fault Rate = Page Faults / Total References
Hit Ratio = Hits / Total References = 1 - Page Fault Rate
```

**5. Working Set**
```
Working Set Size = |Pages in last Δ references|
Total WS = Σ(Working Set of all processes)
Thrashing Risk = Total WS > Available Frames
```

---

### Problem-Solving Strategies

### Strategy 1: Address Translation Problems

**Steps:**
1. Identify page size (calculate offset bits)
2. Calculate page number and offset
3. Look up page table for frame number
4. Compute physical address
5. Check valid bit

**Template:**
```
Given: Logical Address = X, Page Size = Y

Step 1: Offset bits = log₂(Page Size)
Step 2: Page Number = X / Y
Step 3: Offset = X % Y
Step 4: Frame Number = Page_Table[Page Number]
Step 5: Physical Address = Frame × Page_Size + Offset
```

---

### Strategy 2: Page Replacement Problems

**Steps:**
1. Draw table with columns: Ref, Frames, Fault/Hit
2. Track algorithm-specific data (queue/stack/counters)
3. For each reference:
   - Check if page in memory
   - If yes → Hit
   - If no → Apply replacement algorithm
4. Count total faults
5. Calculate fault rate

**Template for FIFO:**
```
Maintain queue of pages
For each reference:
    If page in frames:
        Hit
    Else:
        If frames full:
            Replace oldest (front of queue)
        Add page to frames
        Add to rear of queue
        Fault
```

---

### Strategy 3: Thrashing Detection

**Indicators:**
```
✓ Page fault rate > 80%
✓ CPU utilization < 20%
✓ Disk constantly active
✓ Long process wait times
✓ Total WS > Available memory
```

**Solution Steps:**
1. Calculate working set for each process
2. Sum total working set requirements
3. Compare with available frames
4. If total > available → Suspend processes

---

### Practice Problem 1: Comprehensive Address Translation

**Question:**
```
Logical Address Space: 64 KB
Physical Memory: 128 KB
Page Size: 2 KB

a) How many bits for logical address?
b) How many bits for page number?
c) How many bits for offset?
d) How many pages possible?
e) How many frames available?
f) Translate logical address 10,500
```

**Solution:**
```
a) Logical Address = 64 KB = 2^16 bytes
   Bits needed = 16 bits

b) Page Size = 2 KB = 2^11 bytes
   Offset bits = 11
   Page bits = 16 - 11 = 5 bits

c) Offset bits = 11 bits

d) Number of Pages = 2^5 = 32 pages

e) Physical Memory = 128 KB = 2^17 bytes
   Frames = 128 KB / 2 KB = 64 frames

f) Logical Address = 10,500
   Page Number = 10,500 / 2,048 = 5
   Offset = 10,500 % 2,048 = 356
   
   Assume Page Table: Page 5 → Frame 12
   
   Physical Address = 12 × 2,048 + 356
                    = 24,576 + 356
                    = 24,932
```

---

### Practice Problem 2: Working Set Analysis

**Question:**
```
Reference String: 1,2,3,4,1,2,5,1,2,3,4,5,1,2,3
Window Size (Δ): 6

Calculate working set at each position after first 6 references
```

**Solution:**
```
Pos  Last 6 Refs       Working Set       Size
---  --------------     -------------     ----
6    1,2,3,4,1,2        {1,2,3,4}         4
7    2,3,4,1,2,5        {1,2,3,4,5}       5
8    3,4,1,2,5,1        {1,2,3,4,5}       5
9    4,1,2,5,1,2        {1,2,4,5}         4
10   1,2,5,1,2,3        {1,2,3,5}         4
11   2,5,1,2,3,4        {1,2,3,4,5}       5
12   5,1,2,3,4,5        {1,2,3,4,5}       5
13   1,2,3,4,5,1        {1,2,3,4,5}       5
14   2,3,4,5,1,2        {1,2,3,4,5}       5
15   3,4,5,1,2,3        {1,2,3,4,5}       5

Working Set Size: Ranges from 4 to 5 pages
Average WS Size: ~4.7 pages
```

---

### Practice Problem 3: Thrashing Prevention

**Question:**
```
System: 200 frames available

Process A: Working Set = 40 frames
Process B: Working Set = 35 frames
Process C: Working Set = 45 frames
Process D: Working Set = 50 frames
Process E: Working Set = 40 frames

Which processes should run to avoid thrashing?
```

**Solution:**
```
Total if all run: 40+35+45+50+40 = 210 frames
Available: 200 frames
210 > 200 → Cannot run all

Strategy 1: Suspend largest (D)
A+B+C+E = 40+35+45+40 = 160 ≤ 200 ✓

Strategy 2: Suspend D and C
A+B+E = 40+35+40 = 115 ≤ 200 ✓
(More memory left for growth)

Strategy 3: Priority-based
If priorities: B > A > E > C > D
Run B, A, E, C = 40+35+40+45 = 160 ✓

Best Choice: Strategy 1 (maximize processes while ensuring no thrashing)
Run: A, B, C, E (4 processes)
Suspend: D (1 process)
```

---

### Practice Problem 4: EAT with Working Set

**Question:**
```
Working Set Size: 50 pages
Allocated Frames: 60 pages
Page Size: 4 KB
Memory Access Time: 100 ns
Page Fault Time: 8 ms

Assume 95% of references are to working set.
Calculate effective access time.
```

**Solution:**
```
Case 1: Reference to Working Set (95%)
All WS pages in memory (60 frames > 50 WS)
Page fault rate = 0%
Time = 100 ns

Case 2: Reference outside WS (5%)
Page must be loaded
Page fault rate = 100%
Time = 8 ms = 8,000,000 ns

EAT = 0.95 × 100 + 0.05 × 8,000,000
    = 95 + 400,000
    = 400,095 ns
    ≈ 400 μs

Note: Even 5% faults significantly impact performance!
```

---

## Important Exam Questions & Answers

### Q1. What is thrashing? How can it be prevented?

**Answer:**
Thrashing is a condition where excessive paging causes the system to spend more time swapping pages than executing processes, leading to severe performance degradation.

**Prevention methods:**
1. **Local page replacement** - Limit page replacement to process's own pages
2. **Working set model** - Ensure each process has sufficient frames
3. **Page fault frequency** - Monitor and adjust frame allocation dynamically
4. **Load control** - Suspend processes if total WS > available memory
5. **Increase memory** - Add more RAM to system

---

### Q2. Explain temporal and spatial locality with examples.

**Answer:**
**Temporal Locality:** Recently accessed items will likely be accessed again soon.
Example: Loop counter variable accessed repeatedly in each iteration

**Spatial Locality:** Items near recently accessed items will likely be accessed soon.
Example: Sequential array traversal accesses adjacent memory locations

Both types of locality are exploited by:
- Virtual memory (working sets)
- CPU cache (cache lines)
- Prefetching mechanisms

---

### Q3. What is the working set model? How does it prevent thrashing?

**Answer:**
Working Set Model defines working set as the set of pages a process actively uses in a time window Δ.

**Thrashing Prevention:**
- Calculate total working set: Σ(WSᵢ) for all processes
- If total WS ≤ available frames: Run all processes
- If total WS > available frames: Suspend some processes
- Only run processes whose combined WS fits in memory
- This ensures no process lacks necessary frames, preventing thrashing

---

### Q4. Compare working set model with page fault frequency scheme.

**Answer:**
| Working Set | Page Fault Frequency |
|-------------|---------------------|
| Proactive approach | Reactive approach |
| Predicts frame needs | Responds to fault rate |
| Based on reference history | Based on current faults |
| Complex to implement | Simpler to implement |
| Prevents thrashing | Corrects thrashing |
| Higher overhead | Lower overhead |

Both can be used together for best results.

---

### Q5. Why is locality of reference important for virtual memory?

**Answer:**
Locality of reference is crucial because:
1. **Enables working sets** - Programs use small page sets at a time
2. **Reduces page faults** - Predictable access patterns
3. **Makes demand paging feasible** - Most references hit in memory
4. **Prevents thrashing** - Small working sets fit in available frames
5. **Improves performance** - High hit rates, low page fault rates

Without locality, virtual memory would fail due to constant page faults.

---

## Quick Revision Points 

**Thrashing:**
1. More time paging than executing
2. Caused by insufficient frames per process
3. Detected by high page fault rate + low CPU utilization
4. Prevented by working set model, PFF, load control
5. Effect: System becomes extremely slow

**Locality:**
1. **Temporal** - Recently used → Used again (time-based)
2. **Spatial** - Nearby locations accessed (space-based)
3. Examples: Loop variables (temporal), arrays (spatial)
4. Enables efficient virtual memory and caching
5. Programs with good locality → Fewer page faults

**Working Set:**
1. Set of actively used pages in time window Δ
2. Size changes with program phase
3. Total WS ≤ Available Frames → No thrashing
4. Used for admission control and scheduling
5. Reflects program's locality of reference

---

## Comparison Tables

### Thrashing Indicators

| Indicator | Normal System | Thrashing System |
|-----------|---------------|------------------|
| CPU Utilization | 70-90% | < 20% |
| Page Fault Rate | < 5% | > 80% |
| Disk Activity | Low | Constantly high |
| Process Wait Time | Short | Very long |
| Response Time | Fast | Extremely slow |

---

### Memory Management Evolution

| Technique | Fragmentation | Complexity | Performance |
|-----------|---------------|------------|-------------|
| Fixed Partitions | Internal | Low | Poor |
| Dynamic Partitions | External | Medium | Medium |
| Paging | Internal (small) | Medium | Good |
| Virtual Memory | Internal (small) | High | Excellent |
| Working Set Model | Minimal | Very High | Optimal |

---
