# Deadlock Avoidance

---

## 1. DEADLOCK AVOIDANCE

**Definition:** Dynamically check if granting a resource request leads to a safe state. Grant only if SAFE.

**Requirements:** Max needs of each process must be known in advance.

---

## 2. SAFE vs UNSAFE STATE

### Safe State
- Safe sequence exists where all processes can complete
- Deadlock **CANNOT** occur

### Unsafe State  
- No safe sequence exists
- Deadlock **MAY** occur (not guaranteed)

**Remember:** UNSAFE ≠ DEADLOCK

---

## 3. EXAMPLE: SAFE vs UNSAFE

**System:** Total = 12 units

```
Process   Max   Allocated   Need
P₀        10       5         5
P₁         4       2         2
P₂         9       2         7

Available = 12 - (5+2+2) = 3
```

**Check Safety:**
- P₁ needs 2, Available = 3 → Execute P₁ → Available = 3+4 = 7
- P₀ needs 5, Available = 7 → Execute P₀ → Available = 7+10 = 17
- P₂ needs 7, Available = 17 → Execute P₂

**Safe Sequence: <P₁, P₀, P₂>** → **SAFE STATE ✓**

**If P₂ had Allocated = 4:**
Available = 1, No process can execute → **UNSAFE ✗**

---

## 4. BANKER'S ALGORITHM (SINGLE RESOURCE)

### Data Structures
- **Available (A):** Free resources
- **Max (M):** Maximum need of each process
- **Allocated (C):** Currently allocated
- **Need (N):** Max - Allocated

### Resource Request Algorithm

**When Process Pᵢ requests R units:**

```
Step 1: Check Request ≤ Need[i]
        If NO → Error
        
Step 2: Check Request ≤ Available
        If NO → Wait
        
Step 3: Trial Allocation:
        Available = Available - Request
        Allocated[i] = Allocated[i] + Request
        Need[i] = Need[i] - Request

Step 4: Run Safety Algorithm
        If SAFE → Grant request
        If UNSAFE → Rollback (deny request)
```

### Safety Algorithm

```
Step 1: Work = Available
        Finish[i] = false for all

Step 2: Find Pi where:
        - Finish[i] = false
        - Need[i] ≤ Work
        
Step 3: Work = Work + Allocated[i]
        Finish[i] = true
        Go to Step 2

Step 4: If all Finish = true → SAFE
        Else → UNSAFE
```

---

## 5. EXAMPLE: SINGLE RESOURCE

**Initial State:**
```
Total = 10

Process   Max   Allocated   Need   Available = 3
P₀         7       2         5
P₁         3       2         1
P₂         9       3         6
```

**Is it SAFE?**

```
Work = 3

P₁: Need=1 ≤ Work=3 ✓ → Work = 3+2 = 5
P₀: Need=5 ≤ Work=5 ✓ → Work = 5+2 = 7
P₂: Need=6 ≤ Work=7 ✓ → Work = 7+3 = 10

Safe Sequence: <P₁, P₀, P₂> → SAFE ✓
```

**P₂ requests 1 resource:**

```
Step 1: 1 ≤ Need[P₂]=6 ✓
Step 2: 1 ≤ Available=3 ✓
Step 3: Trial:
        Available = 3-1 = 2
        Allocated[P₂] = 3+1 = 4
        Need[P₂] = 6-1 = 5

Safety Check (Work = 2):
P₁: Need=1 ≤ 2 ✓ → Work = 4
P₀: Need=5 > 4 ✗
P₂: Need=5 > 4 ✗

No process can complete → UNSAFE ✗
Decision: DENY request
```

---

## 6. BANKER'S ALGORITHM (MULTIPLE RESOURCES)

### Data Structures (n processes, m resource types)

- **Available[m]:** Available instances of each resource
- **Max[n][m]:** Max demand
- **Allocation[n][m]:** Currently allocated
- **Need[n][m]:** Max - Allocation

### Safety Algorithm

```
Step 1: Work = Available
        Finish[i] = false for all

Step 2: Find i where:
        - Finish[i] = false
        - Need[i] ≤ Work (for ALL resources)
        
        Need[i] ≤ Work means:
        Need[i][0] ≤ Work[0] AND
        Need[i][1] ≤ Work[1] AND ...

Step 3: Work = Work + Allocation[i]
        Finish[i] = true
        Go to Step 2

Step 4: If all Finish = true → SAFE
        Else → UNSAFE
```

### Resource Request Algorithm

```
Step 1: Check Request ≤ Need[i]
Step 2: Check Request ≤ Available
Step 3: Trial Allocation
Step 4: Run Safety Algorithm
        SAFE → Grant
        UNSAFE → Deny
```

---

## 7. COMPLETE EXAMPLE: MULTIPLE RESOURCES

**System:** 3 resources (A, B, C), 5 processes

```
         Allocation      Max         Need
         A  B  C       A  B  C     A  B  C
P₀       0  1  0       7  5  3     7  4  3
P₁       2  0  0       3  2  2     1  2  2
P₂       3  0  2       9  0  2     6  0  0
P₃       2  1  1       2  2  2     0  1  1
P₄       0  0  2       4  3  3     4  3  1

Available = [3, 3, 2]
```

**Find Safe Sequence:**

```
Work = [3,3,2]

P₁: Need=[1,2,2] ≤ [3,3,2] ✓
    Work = [3,3,2] + [2,0,0] = [5,3,2]

P₃: Need=[0,1,1] ≤ [5,3,2] ✓
    Work = [5,3,2] + [2,1,1] = [7,4,3]

P₀: Need=[7,4,3] ≤ [7,4,3] ✓
    Work = [7,4,3] + [0,1,0] = [7,5,3]

P₂: Need=[6,0,0] ≤ [7,5,3] ✓
    Work = [7,5,3] + [3,0,2] = [10,5,5]

P₄: Need=[4,3,1] ≤ [10,5,5] ✓
    Work = [10,5,5] + [0,0,2] = [10,5,7]

Safe Sequence: <P₁, P₃, P₀, P₂, P₄> → SAFE ✓
```

**P₁ requests [1, 0, 2]:**

```
Step 1: [1,0,2] ≤ Need[P₁]=[1,2,2] ✓
Step 2: [1,0,2] ≤ Available=[3,3,2] ✓
Step 3: Trial:
        Available = [2,3,0]
        Allocation[P₁] = [3,0,2]
        Need[P₁] = [0,2,0]

Safety Check:
Work = [2,3,0]
P₁: [0,2,0] ≤ [2,3,0] ✓ → Work = [5,3,2]
P₃: [0,1,1] ≤ [5,3,2] ✓ → Work = [7,4,3]
P₀: [7,4,3] ≤ [7,4,3] ✓ → Work = [7,5,3]
P₂: [6,0,0] ≤ [7,5,3] ✓ → Work = [10,5,5]
P₄: [4,3,1] ≤ [10,5,5] ✓

Safe Sequence: <P₁, P₃, P₀, P₂, P₄> → SAFE ✓
Decision: GRANT ✓
```

**P₄ requests [3, 3, 0]:**

```
Step 1: [3,3,0] ≤ Need[P₄]=[4,3,1] ✓
Step 2: [3,3,0] ≤ Available=[3,3,2] ✓
Step 3: Trial:
        Available = [0,0,2]
        
Safety Check:
Work = [0,0,2]
All processes have Need > [0,0,2] → UNSAFE ✗
Decision: DENY ✗
```

---

## 8. IMPORTANT FORMULAS

```
1. Need = Max - Allocation

2. Available = Total - Σ(Allocation)

3. Vector A ≤ B means:
   A[0]≤B[0] AND A[1]≤B[1] AND ... A[m-1]≤B[m-1]

4. Safe State ⟺ All Finish[i] = true
```

---

## 9. EXAM QUESTIONS & ANSWERS

### Q1. Difference between Safe and Unsafe state?

| Safe | Unsafe |
|------|--------|
| Safe sequence exists | No safe sequence |
| Deadlock cannot occur | Deadlock may occur |
| All processes complete | Some may not complete |

### Q2. Steps in Banker's Algorithm when process requests resources?

1. Check Request ≤ Need (valid?)
2. Check Request ≤ Available (possible?)
3. Trial allocation (temporarily allocate)
4. Run safety algorithm (safe?)
   - If SAFE → Grant
   - If UNSAFE → Deny/Rollback

### Q3. What is a safe sequence?

Sequence <P₁, P₂, ..., Pₙ> where each process can complete using:
- Available resources
- Resources released by previous processes

### Q4. Why is Banker's Algorithm not practical?

- Max needs must be known in advance (usually unknown)
- Fixed number of processes (no dynamic creation)
- Fixed resources (cannot add/remove)
- High overhead for checking safety
- Not suitable for large systems

---

## 10. PROBLEM-SOLVING STEPS

**For Safety Check:**
1. Calculate Need = Max - Allocation
2. Set Work = Available, Finish = false for all
3. Find process where Need ≤ Work
4. Work = Work + Allocation, mark finished
5. Repeat until all finished (SAFE) or stuck (UNSAFE)

**For Request:**
1. Check Request ≤ Need
2. Check Request ≤ Available
3. Trial allocate
4. Run safety algorithm
5. Grant if SAFE, Deny if UNSAFE

---

## 11. KEY POINTS FOR EXAM

✓ Safe state = Deadlock impossible  
✓ Unsafe state = Deadlock possible (not certain)  
✓ Banker's avoids deadlock by ensuring safe state  
✓ Need = Max - Allocation  
✓ Always run safety algorithm after trial allocation  
✓ Single resource uses scalars, multiple uses vectors  
✓ Vector comparison: ALL elements must satisfy condition  
✓ When process finishes: Work = Work + Allocation  

---

## 12. COMMON MISTAKES

Unsafe = Deadlock (WRONG)  
Unsafe = Deadlock possible

Forgetting to add Allocation when process finishes  
Work = Work + Allocation[i]

Using > instead of ≤ for comparisons  
Need ≤ Work (process can proceed)

Not checking ALL resources in vector comparison  
Must check Need[0]≤Work[0] AND Need[1]≤Work[1] AND ...

---

## 13. QUICK REVISION

**Safe State:**
- All processes can complete in some order
- Deadlock impossible

**Unsafe State:**
- No safe sequence
- Deadlock possible

**Banker's Algorithm:**
- Request → Check validity → Check availability → Trial → Safety check
- Grant if SAFE, Deny if UNSAFE

**Safety Algorithm:**
- Find process with Need ≤ Work
- Simulate completion, release resources
- Repeat until all finish or stuck

**Need = Max - Allocation**

---
