# Deadlock Detection & Recovery
---

## 1. DEADLOCK DETECTION

### 1.1 Overview
- Used when deadlock **prevention** and **avoidance** are not implemented
- System periodically checks if deadlock exists
- If detected → apply recovery mechanism

---

### 1.2 Detection Algorithms

#### **A. Single Instance of Each Resource Type**

**Wait-for Graph Method**

- Simplified version of Resource Allocation Graph (RAG)
- **Nodes**: Only processes (no resource nodes)
- **Edges**: P₁ → P₂ means P₁ is waiting for P₂ to release a resource

**Deadlock Detection Rule:**
```
Deadlock exists ⟺ Wait-for graph contains a CYCLE
```

**Example:**
```
P1 → P2 → P3 → P1  (CYCLE = Deadlock!)
P4 → P5             (No cycle = Safe)
```

**Algorithm:**
1. Maintain wait-for graph
2. Periodically invoke cycle detection algorithm
3. If cycle found → Deadlock exists

**Time Complexity:** O(n²) where n = number of processes

---

#### **B. Multiple Instances of Each Resource Type**

Uses **Banker's Algorithm-like** approach for detection

**Data Structures:**
- **Available**: Vector of length m (available instances of each resource)
- **Allocation**: n×m matrix (currently allocated resources)
- **Request**: n×m matrix (current requests from each process)

Where:
- n = number of processes
- m = number of resource types

**Detection Algorithm:**

```
Step 1: Initialize
   Work = Available
   Finish[i] = false for all i

Step 2: Find process Pi such that:
   - Finish[i] == false
   - Request[i] ≤ Work
   
   If found → Go to Step 3
   If not found → Go to Step 4

Step 3: Execute process Pi
   Work = Work + Allocation[i]
   Finish[i] = true
   Go to Step 2

Step 4: Check deadlock
   If Finish[i] == false for some i
   → Process Pi is DEADLOCKED
```

**Example Problem:**

Given:
```
Available = [0, 0, 0]

       Allocation    Request
       A  B  C       A  B  C
P0     0  1  0       0  0  0
P1     2  0  0       2  0  2
P2     3  0  3       0  0  0
P3     2  1  1       1  0  0
P4     0  0  2       0  0  2
```

**Solution:**
```
Work = [0, 0, 0], All Finish = false

Check P0: Request[0,0,0] ≤ Work[0,0,0] ✓
→ Work = [0,0,0] + [0,1,0] = [0,1,0]
→ Finish[P0] = true

Check P2: Request[0,0,0] ≤ Work[0,1,0] ✓
→ Work = [0,1,0] + [3,0,3] = [3,1,3]
→ Finish[P2] = true

Check P3: Request[1,0,0] ≤ Work[3,1,3] ✓
→ Work = [3,1,3] + [2,1,1] = [5,2,4]
→ Finish[P3] = true

Check P1: Request[2,0,2] ≤ Work[5,2,4] ✓
→ Work = [5,2,4] + [2,0,0] = [7,2,4]
→ Finish[P1] = true

Check P4: Request[0,0,2] ≤ Work[7,2,4] ✓
→ Work = [7,2,4] + [0,0,2] = [7,2,6]
→ Finish[P4] = true

Result: No deadlock (all finished)
```

---

### 1.3 When to Invoke Detection Algorithm?

**Option 1: Every time a request cannot be granted immediately**
- Advantage: Quick detection
- Disadvantage: High overhead

**Option 2: At regular intervals**
- Example: Once per hour, or when CPU utilization drops below 40%
- Trade-off between overhead and detection speed

**Option 3: Based on system load**
- When deadlock is more likely (many processes waiting)

---

## 2. DEADLOCK RECOVERY

Once deadlock is detected, system must recover. Two main approaches:

---

### 2.1 Process Termination

#### **A. Abort All Deadlocked Processes**

**Advantages:**
- Simple to implement
- Breaks the deadlock immediately

**Disadvantages:**
- All processes lose their progress
- Expensive (wasted computation)
- Processes may have been running for hours

---

#### **B. Abort One Process at a Time**

**Method:**
1. Abort one deadlocked process
2. Run deadlock detection algorithm again
3. If still deadlocked → Abort another process
4. Repeat until deadlock is resolved

**Advantages:**
- Minimal process loss
- May resolve deadlock with fewer terminations

**Disadvantages:**
- High overhead (repeated detection)
- Need to choose which process to abort

---

#### **Process Selection Criteria (Which Process to Abort?)**

Consider these factors:

1. **Priority of process**
   - Abort lower priority first

2. **How long process has computed**
   - Abort process that has computed least (minimize loss)

3. **How much longer to completion**
   - Abort process that has longer to go

4. **Resources held by process**
   - Abort process holding many resources

5. **Resources needed by process**
   - Consider future resource needs

6. **Number of processes to be terminated**
   - Minimize total number

7. **Interactive vs. Batch**
   - Prefer aborting batch processes

**Example Priority:**
```
P1: Priority 10, Time run = 50 min, Resources = 5
P2: Priority 5,  Time run = 10 min, Resources = 3
P3: Priority 8,  Time run = 30 min, Resources = 7

Abort order: P2 → P1 → P3
(lowest priority, least time invested)
```

---

### 2.2 Resource Preemption

Gradually take resources from processes and give to others to break deadlock.

---

#### **Key Issues in Resource Preemption:**

#### **A. Selecting a Victim**
- Which resources and processes to preempt?
- Use similar criteria as process termination:
  - Minimize cost
  - Choose process with minimum resources held
  - Choose process with least computation done

**Cost Factors:**
```
Cost = (Resources held) + (Progress lost) + (Rollback overhead)
```

---

#### **B. Rollback**

**Problem:** If we preempt a resource from a process, what happens to that process?

**Solutions:**

1. **Total Rollback**
   - Abort the process
   - Restart it from beginning
   - Simple but wasteful

2. **Partial Rollback**
   - Roll back process to a **safe state**
   - Restart from that checkpoint
   - Requires system to maintain checkpoints (save points)

**Checkpoint Example:**
```
P1 execution timeline:
Start → CP1 → CP2 → CP3 → [Resource Preempted] → End

Rollback to CP2 (most recent safe state before deadlock)
```

---

#### **C. Starvation**

**Problem:**
- Same process might always be selected as victim
- Process never completes (starved)

**Solutions:**

1. **Include number of rollbacks in cost factor**
   ```
   Cost = Base_cost + (Rollback_count × Penalty)
   ```
   - Process rolled back many times gets lower cost → Less likely to be selected again

2. **Limit number of times a process can be rolled back**
   - Example: Maximum 3 rollbacks per process
   - After limit → process cannot be selected as victim

3. **Age-based selection**
   - Older processes (waiting longer) have higher priority
   - Less likely to be preempted

**Example:**
```
P1: Rolled back 2 times → Cost increased by 20%
P2: Rolled back 0 times → Normal cost
P3: Rolled back 4 times → Cost increased by 40%

Selection: P2 (lowest adjusted cost)
```

---

## 3. COMPARISON: DETECTION vs. PREVENTION vs. AVOIDANCE

| Aspect | Detection | Prevention | Avoidance |
|--------|-----------|-----------|-----------|
| **When applied** | After deadlock occurs | Before deadlock can occur | Dynamically at runtime |
| **Resource utilization** | High | Low | Medium |
| **Overhead** | Detection + Recovery | Constraints on system | Runtime checking (Banker's) |
| **Complexity** | Medium | Low | High |
| **Best for** | Systems where deadlocks are rare | Simple systems | Systems with known max needs |

---

## 4. EXAM-STYLE QUESTIONS & ANSWERS

### **Q1. Explain wait-for graph with example.**

**Answer:**
Wait-for graph is used for deadlock detection when there is **single instance** of each resource type.

- **Nodes**: Processes only
- **Edges**: P₁ → P₂ means P₁ waiting for resource held by P₂
- **Deadlock**: Exists if and only if graph contains a cycle

**Example:**
```
P1 holds R1, waiting for R2
P2 holds R2, waiting for R3
P3 holds R3, waiting for R1

Wait-for graph: P1 → P2 → P3 → P1 (CYCLE)
Result: DEADLOCK detected
```

---

### **Q2. Difference between aborting all processes vs. one at a time?**

**Answer:**

| Aspect | Abort All | Abort One at a Time |
|--------|-----------|---------------------|
| **Speed** | Immediate deadlock resolution | Slower (repeated detection) |
| **Cost** | High (all progress lost) | Lower (minimal loss) |
| **Complexity** | Simple | Complex (need victim selection) |
| **Overhead** | One-time | Repeated detection overhead |
| **Use case** | Critical systems needing quick recovery | Systems where process loss is expensive |

---

### **Q3. How to prevent starvation in resource preemption?**

**Answer:**

**Three main methods:**

1. **Rollback counter in cost calculation**
   - Cost increases with each rollback
   - Makes repeatedly preempted process less attractive

2. **Maximum rollback limit**
   - Limit = 3 or 5 rollbacks per process
   - After limit, process cannot be victim

3. **Age-based priority**
   - Older waiting processes get higher priority
   - Recent processes more likely to be victims

**Example calculation:**
```
Process P1 (2 rollbacks): 
   Final_Cost = Base_Cost × (1 + 0.5 × Rollback_Count)
              = 100 × (1 + 0.5 × 2) = 200

Process P2 (0 rollbacks):
   Final_Cost = 100 × (1 + 0) = 100

Select P2 as victim (lower cost)
```

---

### **Q4. Explain deadlock detection algorithm for multiple instances.**

**Answer:**

**Data Structures:**
- Available[m]: Available resources
- Allocation[n][m]: Current allocation
- Request[n][m]: Current requests

**Algorithm Steps:**

```
1. Initialize: Work = Available, Finish[i] = false

2. Find Pi where Finish[i] = false AND Request[i] ≤ Work
   - If found → Execute step 3
   - If not found → Go to step 4

3. Simulate allocation:
   Work = Work + Allocation[i]
   Finish[i] = true
   Repeat step 2

4. Deadlock check:
   If any Finish[i] = false → That process is deadlocked
```

**Key Point:** If a process cannot complete (Finish remains false), it's in deadlock.

---

### **Q5. When should deadlock detection algorithm be invoked?**

**Answer:**

**Three strategies:**

1. **On every resource request denial**
   - Pros: Immediate detection
   - Cons: Very high overhead

2. **At fixed intervals**
   - Examples: Every hour, every 100 requests
   - Pros: Balanced overhead
   - Cons: Delayed detection

3. **Based on system state**
   - When: CPU utilization < 40%, many processes waiting
   - Pros: Invoked when deadlock likely
   - Cons: Complex to implement

**Exam Tip:** State that frequency depends on:
- How often deadlocks occur
- Acceptable detection delay
- Available system resources

---

## 5. IMPORTANT FORMULAS & KEY POINTS

### **Formulas:**

1. **Wait-for Graph Deadlock:**
   ```
   Deadlock ⟺ Cycle exists in wait-for graph
   ```

2. **Detection Algorithm Condition:**
   ```
   Process can proceed if: Request[i] ≤ Work
   ```

3. **Victim Selection Cost:**
   ```
   Cost = Resources_held + Progress_lost + Rollback_overhead
   ```

4. **Starvation Prevention:**
   ```
   Adjusted_Cost = Base_Cost × (1 + α × Rollback_Count)
   ```

### **Key Points to Remember:**

✓ **Detection** = Used when prevention/avoidance not applied  
✓ **Wait-for graph** = For single instance resources only  
✓ **Banker's-style algorithm** = For multiple instances  
✓ **Process termination** = Either all or one-by-one  
✓ **Resource preemption** = Requires rollback mechanism  
✓ **Starvation** = Major concern in preemption, use counters/limits  
✓ **Victim selection** = Based on priority, resources, time, etc.  
✓ **Rollback types** = Total (restart) vs. Partial (checkpoint)  

---

## 6. SAMPLE NUMERICAL PROBLEM

**Problem:** Detect deadlock using the following data:

```
Available = [2, 1, 0]

       Allocation    Request
       A  B  C       A  B  C
P0     2  0  1       0  1  1
P1     0  1  2       1  0  1
P2     1  0  3       0  0  1
```

**Solution:**

```
Work = [2, 1, 0], All Finish = false

Step 1: Check P0
Request[0] = [0,1,1], Work = [2,1,0]
0≤2? ✓, 1≤1? ✓, 1≤0? ✗
Cannot proceed

Step 2: Check P1
Request[1] = [1,0,1], Work = [2,1,0]
1≤2? ✓, 0≤1? ✓, 1≤0? ✗
Cannot proceed

Step 3: Check P2
Request[2] = [0,0,1], Work = [2,1,0]
0≤2? ✓, 0≤1? ✓, 1≤0? ✗
Cannot proceed

No process can proceed → All processes are DEADLOCKED
```

---
