# Deadlock Prevention & Ignorance

---

## 1. DEADLOCK PREVENTION - OVERVIEW

**Definition:** Ensure that at least ONE of the four necessary conditions for deadlock CANNOT hold.

**Four Necessary Conditions for Deadlock:**
1. **Mutual Exclusion**
2. **Hold and Wait**
3. **No Preemption**
4. **Circular Wait**

**Prevention Strategy:** Make at least one condition impossible → Deadlock cannot occur.

---

## 2. BREAKING MUTUAL EXCLUSION

### Concept
Make resources **sharable** instead of mutually exclusive.

### Methods

**1. Use Spooling (Simultaneous Peripheral Operations OnLine)**
- Instead of direct access, use spooling for devices like printers
- Multiple processes submit jobs to a queue
- Only spooler daemon accesses the printer

**Example:**
```
Without Spooling:
P1 → Printer (locked)
P2 → Waits for Printer → Deadlock possible

With Spooling:
P1 → Spool → |
              | → Spooler → Printer
P2 → Spool → |

No process directly holds printer → No mutual exclusion
```

**2. Use Read-Only Files**
- Read-only resources can be shared
- Multiple processes can read simultaneously

**3. Virtual Resources**
- Convert non-sharable to sharable using virtualization
- Example: Virtual printers, virtual devices

### Advantages
Simple concept
No waiting for resources

### Disadvantages
Not applicable to all resources (e.g., tape drives, databases)
Some resources are inherently non-sharable
May reduce protection and consistency

**Practical Use:** Limited - many resources MUST be mutually exclusive

---

## 3. BREAKING HOLD AND WAIT

### Concept
Ensure processes do NOT hold resources while waiting for others.

### Methods

**Method 1: Request All Resources at Once**

- Process must request ALL needed resources before execution
- If any resource unavailable → Release everything and wait
- Grant resources only when ALL are available

**Example:**
```
Process needs: Printer, Scanner, Disk

Traditional (Hold & Wait):
Get Printer → Wait for Scanner → Wait for Disk → Deadlock possible

Prevention (All at Once):
Request {Printer, Scanner, Disk}
If all available → Grant all
Else → Wait and retry
```

**Method 2: Release Before Requesting**

- Process must release ALL currently held resources before requesting new ones
- Two-phase protocol:
  1. Request resources → Use → Release ALL
  2. Request new set → Use → Release ALL

**Example:**
```
Phase 1:
Request {File1, Printer} → Use → Release {File1, Printer}

Phase 2:
Request {File2, Scanner} → Use → Release {File2, Scanner}
```

### Advantages
Deadlock prevented
Easy to implement

### Disadvantages
**Low resource utilization** (resources held but not used immediately)
**Starvation possible** (if resource always unavailable)
**Difficult to predict needs** (process may not know all resources in advance)
Repeated release and re-acquisition overhead

**Practical Use:** Limited - processes often don't know all needs upfront

---

## 4. BREAKING NO PREEMPTION

### Concept
Allow resources to be **forcibly taken** (preempted) from processes.

### Methods

**Method 1: Preempt if Waiting**

```
If process P1 holds R1 and requests R2:
    If R2 not available:
        Preempt R1 from P1
        Add R1 to available resources
        P1 waits for {R1, R2}
```

**Method 2: Preempt from Waiting Process**

```
If process P1 requests R1:
    If R1 held by P2 that is waiting for other resources:
        Preempt R1 from P2
        Give R1 to P1
        P2 waits for {R1, other resources}
```

**Example:**
```
P1 holds Printer, requests Scanner
P2 holds Scanner, requests Disk

Without Preemption: Possible deadlock

With Preemption:
- Preempt Printer from P1
- P1 waits for {Printer, Scanner}
- P2 gets resources and completes
- P2 releases Scanner
- P1 gets {Printer, Scanner}
```

### Advantages
Prevents deadlock
Better resource utilization

### Disadvantages
**Only applicable to resources with saved state** (CPU registers, memory)
**NOT applicable to:** Printers, tape drives, databases
**Overhead of saving and restoring state**
**May cause inconsistency** (preempting during critical operations)
**Increased context switching**

**Practical Use:** Limited to preemptable resources (CPU, memory)

---

## 5. BREAKING CIRCULAR WAIT

### Concept
Impose **total ordering** on resource types. Processes must request resources in **increasing order**.

### Method: Resource Ordering

**Define a function F: R → N** (maps each resource type to a unique number)

**Rule:** Process can request resource Rⱼ only if:
```
F(Rⱼ) > F(Rᵢ) for all currently held resources Rᵢ
```

**Example Ordering:**
```
Resource    Order Number
Keyboard    F(Keyboard) = 1
Mouse       F(Mouse) = 2
Printer     F(Printer) = 3
Scanner     F(Scanner) = 4
Disk        F(Disk) = 5
```

**Process Requests:**
```
Allowed:
Request Keyboard(1) → then Mouse(2) → then Printer(3)

Not Allowed:
Request Printer(3) → then Mouse(2)  [Decreasing order]
```

### Why This Works

**Without Ordering (Circular Wait Possible):**
```
P1: holds R1, waits for R2
P2: holds R2, waits for R3
P3: holds R3, waits for R1
→ Circular wait → Deadlock
```

**With Ordering:**
```
Assume F(R1)=1, F(R2)=2, F(R3)=3

P1 holds R1(1), can only request R2(2) or R3(3)
P2 holds R2(2), can only request R3(3)
P3 holds R3(3), cannot request R1(1) [decreasing order]

→ No circular wait possible!
```

### Alternative: Release Before Lower Number

Process holding Rⱼ can request Rᵢ where F(Rᵢ) < F(Rⱼ) only if:
- First release ALL resources Rₖ where F(Rₖ) ≥ F(Rᵢ)

### Advantages
**Most practical** prevention method
No preemption needed
No starvation
Works for all resource types

### Disadvantages
**Difficult to find optimal ordering**
**Restricts flexibility** (cannot request in natural order)
**Application rewriting** may be needed
May cause **resource inefficiency** (must request early even if needed later)

**Practical Use:** Most widely used prevention technique

---

## 6. COMPARISON OF PREVENTION METHODS

| Condition to Break | Method | Practical? | Main Issue |
|-------------------|--------|------------|------------|
| **Mutual Exclusion** | Make resources sharable | No | Many resources inherently non-sharable |
| **Hold & Wait** | Request all at once | No | Don't know all needs; low utilization |
| **No Preemption** | Force preemption | Limited | Only for CPU, memory; not for I/O |
| **Circular Wait** | Resource ordering | Yes | Most practical but restricts flexibility |

---

## 7. DEADLOCK IGNORANCE (OSTRICH ALGORITHM)

### What is Ostrich Algorithm?

**Definition:** Pretend deadlocks never occur (like an ostrich burying its head in sand).

**Strategy:** 
- Do nothing to prevent, avoid, or detect deadlocks
- If deadlock occurs → User notices system hang → Reboot

### Why Ignore Deadlocks?

**Reasons:**

1. **Deadlocks are RARE**
   - In most systems, deadlocks occur infrequently
   - Cost of prevention/avoidance > Cost of occasional reboot

2. **Prevention/Avoidance is EXPENSIVE**
   - Reduces system performance
   - Lowers resource utilization
   - Adds complexity

3. **Other Failures More Common**
   - Hardware failures
   - Software bugs
   - Power failures
   - These already require reboots

4. **User Acceptance**
   - Users accept occasional reboots
   - Better than slow system

**Trade-off:**
```
Prevention Cost > Deadlock Cost → Ignore deadlocks
Prevention Cost < Deadlock Cost → Handle deadlocks
```

### Used By

**UNIX / Linux**
**Windows**
**Most modern operating systems**

### Example Scenario

```
System runs for 1000 hours
Deadlock occurs once (1 hour lost to reboot)
Prevention would slow system by 5% always (50 hours lost)

Ignoring is better: 1 hour loss vs 50 hours loss
```

### Advantages
**Simple** - No deadlock handling code
**Efficient** - No runtime overhead
**High performance** - No restrictions on resource allocation
**Better resource utilization**

### Disadvantages
**System hangs** when deadlock occurs
**Data loss** possible
**User frustration** from unexpected hangs
**Not suitable for critical systems** (medical, aviation, space)

### When to Use Ostrich Algorithm?

**Use When:**
- Deadlocks are very rare
- System downtime is acceptable
- Performance is critical
- Cost of prevention > Cost of deadlock

**Don't Use When:**
- System is critical (life-support, flight control)
- Deadlocks are frequent
- Data integrity is paramount
- Downtime is unacceptable

---

## 8. PREVENTION vs AVOIDANCE vs IGNORANCE

| Aspect | Prevention | Avoidance | Ignorance |
|--------|-----------|-----------|-----------|
| **When applied** | System design | Runtime | Never |
| **Approach** | Make condition impossible | Check before granting | Do nothing |
| **Overhead** | Medium | High | None |
| **Resource use** | Low | Medium | High |
| **Flexibility** | Low | Medium | High |
| **Deadlock** | Cannot occur | Cannot occur | May occur |
| **Examples** | Resource ordering | Banker's algorithm | UNIX, Windows |

---

## 9. EXAM QUESTIONS & ANSWERS

### Q1. Explain breaking Circular Wait with example.

**Answer:**

**Method:** Impose ordering on resources. Request in increasing order only.

**Example:**
```
Resources: R1(order=1), R2(order=2), R3(order=3)

Process must request:
R1 → R2 → R3  ✓ (increasing)

NOT allowed:
R3 → R1  ✗ (decreasing)

Why it works:
If all processes follow ordering, circular wait cannot form.
Highest numbered resource holder cannot wait for lower numbered.
```

### Q2. Why is breaking Mutual Exclusion impractical?

**Answer:**

Many resources are **inherently non-sharable**:
- Printers (cannot print two documents simultaneously)
- Tape drives
- Databases (concurrent writes cause inconsistency)
- Critical sections

Only applicable to:
- Read-only files
- Reentrant code

**Conclusion:** Limited applicability.

### Q3. What is Ostrich Algorithm? Why do modern OS use it?

**Answer:**

**Ostrich Algorithm:** Ignore deadlocks completely.

**Why modern OS use it:**
1. Deadlocks are **rare** in practice
2. Prevention/Avoidance costs > Deadlock costs
3. Users accept **occasional reboots**
4. Better **performance** without restrictions
5. Other failures (bugs, hardware) also need reboots

**Example:** Windows, Linux ignore deadlocks for better performance.

### Q4. Compare breaking Hold & Wait methods.

**Answer:**

| Method | Description | Disadvantage |
|--------|-------------|--------------|
| **All at once** | Request all resources before start | Low utilization; may not know all needs |
| **Release before request** | Release all before requesting new | Overhead; repeated acquisition |

Both prevent deadlock but reduce efficiency.

### Q5. Which prevention method is most practical and why?

**Answer:**

**Breaking Circular Wait** (Resource Ordering)

**Reasons:**
Works for **all resource types**
No preemption needed
No starvation
Actually used in real systems

**Disadvantages:**
Restricts request order
Finding optimal ordering is difficult

**Example:** Device drivers often use ordered resource allocation.

---

## 10. IMPORTANT POINTS FOR EXAM

### Deadlock Prevention

✓ **Break at least ONE necessary condition**
✓ **Mutual Exclusion:** Use spooling/sharing (impractical)
✓ **Hold & Wait:** Request all at once (low utilization)
✓ **No Preemption:** Force preemption (limited to CPU/memory)
✓ **Circular Wait:** Resource ordering (MOST PRACTICAL)

### Ostrich Algorithm

✓ **Ignore deadlocks** completely
✓ Used by **UNIX, Linux, Windows**
✓ **Trade-off:** Performance vs Deadlock handling
✓ Acceptable when deadlocks are **rare**
✓ NOT for **critical systems**

---

## 11. NUMERICAL/SCENARIO QUESTIONS

### Q. Given resources R1, R2, R3 with ordering 1, 2, 3. Can following sequences cause deadlock?

**a) P1: R1→R2→R3**
Answer: No, increasing order ✓

**b) P2: R2→R1→R3**
Answer: Yes, decreasing (R2→R1) ✗

**c) P3: R1→R3, P4: R2**
Answer: No, both increasing ✓

**d) P5: R3→R2**
Answer: Yes, decreasing ✗

### Q. System has 10% deadlock prevention overhead. Deadlock occurs once per 200 hours. Reboot takes 1 hour. Is Ostrich algorithm better?

**Answer:**

**With Prevention:**
- Overhead: 10% always
- In 200 hours: 200 × 0.10 = 20 hours lost

**With Ostrich (Ignore):**
- Deadlock once in 200 hours
- Reboot: 1 hour lost

**Comparison:** 1 hour < 20 hours

**Conclusion:** Ostrich algorithm is BETTER ✓

---
