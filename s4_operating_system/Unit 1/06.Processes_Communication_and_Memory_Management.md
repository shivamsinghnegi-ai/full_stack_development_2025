# Processes, Communication & Memory Management

---

## Part 1: Processes and Communication

---

### What is a Process?

> **Definition**: A **Process** is a **program in execution**. It is an active entity unlike a program which is a passive entity stored on disk.

### Program vs Process

| Program | Process |
|---------|---------|
| Passive entity (file on disk) | Active entity (in execution) |
| Static | Dynamic |
| Stored on secondary storage | Resides in main memory |
| One program can create multiple processes | One instance of execution |

**Example:**
- **Program**: `chrome.exe` (file stored on hard disk)
- **Process**: Running instance of Chrome browser (active in memory)

---

### Components of a Process

A process consists of:

```
┌─────────────────────────────┐
│          PROCESS            │
├─────────────────────────────┤
│  1. Program Code (Text)     │  → Instructions to execute
├─────────────────────────────┤
│  2. Program Counter         │  → Address of next instruction
├─────────────────────────────┤
│  3. CPU Registers           │  → Current working variables
├─────────────────────────────┤
│  4. Stack                   │  → Temporary data (function calls)
├─────────────────────────────┤
│  5. Data Section            │  → Global variables
├─────────────────────────────┤
│  6. Heap                    │  → Dynamically allocated memory
└─────────────────────────────┘
```

---

### Process States (Brief Overview)

A process goes through different **states** during its lifetime:

```
[NEW] → [READY] → [RUNNING] → [TERMINATED]
              ↑        ↓
              └─ [WAITING] ←┘
```

| State | Description |
|-------|-------------|
| **New** | Process is being created |
| **Ready** | Process is waiting to be assigned to CPU |
| **Running** | Process is currently being executed |
| **Waiting** | Process is waiting for some event (I/O completion) |
| **Terminated** | Process has finished execution |

---

### Process Control Block (PCB)

> **Definition**: PCB is a **data structure** maintained by OS that contains all information about a process.

**PCB Contains:**
- Process ID (PID)
- Process State
- Program Counter
- CPU Registers
- Memory Information
- I/O Status
- Accounting Information

```
┌──────────────────────────┐
│   PROCESS CONTROL BLOCK  │
├──────────────────────────┤
│  Process ID: 1234        │
│  State: Running          │
│  Program Counter: 0x4521 │
│  CPU Registers: [...]    │
│  Memory Limits: [...]    │
│  Open Files: [...]       │
└──────────────────────────┘
```

---

### Process Communication (Inter-Process Communication - IPC)

> **Definition**: **IPC** is a mechanism that allows processes to communicate and share data with each other.

#### Why is IPC Needed?

- Processes need to **share data**
- Processes need to **coordinate** their activities
- To achieve **parallel processing**
- For **modularity** (breaking tasks into separate processes)

---

#### Methods of Process Communication

| Method | Description | Example |
|--------|-------------|---------|
| **Shared Memory** | Processes share a common memory region | Database systems |
| **Message Passing** | Processes send/receive messages through OS | Client-Server systems |
| **Pipes** | Unidirectional data channel between processes | `ls \| grep file` in shell |
| **Sockets** | Communication over network | Web browsers |

---

#### 1. Shared Memory

```
┌─────────────┐    ┌──────────────────┐    ┌─────────────┐
│  Process A  │←──→│  SHARED MEMORY   │←──→│  Process B  │
└─────────────┘    │  (Common Area)   │    └─────────────┘
                   └──────────────────┘
```

- **Fast** communication (direct memory access)
- Requires **synchronization** to avoid conflicts

---

#### 2. Message Passing

```
┌─────────────┐         ┌─────────────┐
│  Process A  │──MSG───→│  Process B  │
│   (Sender)  │         │  (Receiver) │
└─────────────┘         └─────────────┘
```

- OS handles message delivery
- **Easier** to implement
- Works for **distributed systems**

---

### Key Points for Exam (Process & Communication)

1. **Process** = Program in execution
2. **Process has 5 states**: New, Ready, Running, Waiting, Terminated
3. **PCB** stores all information about a process
4. **IPC** allows processes to communicate
5. **Two main IPC methods**: Shared Memory (fast) and Message Passing (easy)

---

## Part 2: Memory Management (Brief Introduction)

---

### What is Memory Management?

> **Definition**: **Memory Management** is the functionality of an operating system that handles and manages primary memory (RAM). It controls the allocation and deallocation of memory to processes.

---

### Why is Memory Management Needed?

```
┌─────────────────────────────────────────────┐
│           WHY MEMORY MANAGEMENT?            │
├─────────────────────────────────────────────┤
│ 1. Multiple programs need memory            │
│ 2. Memory (RAM) is limited                  │
│ 3. Need to allocate memory efficiently      │
│ 4. Prevent processes from accessing each    │
│    other's memory (Protection)              │
│ 5. Allow sharing when needed                │
└─────────────────────────────────────────────┘
```

---

### Memory Hierarchy

```
        ┌─────────────────┐
        │  CPU Registers  │  ← Fastest, Smallest, Most Expensive
        └────────┬────────┘
                 ↓
        ┌─────────────────┐
        │  Cache Memory   │
        └────────┬────────┘
                 ↓
        ┌─────────────────┐
        │  Main Memory    │  ← RAM (Primary Memory)
        │     (RAM)       │
        └────────┬────────┘
                 ↓
        ┌─────────────────┐
        │ Secondary       │  ← Hard Disk (Slowest, Largest, Cheapest)
        │ Storage (HDD)   │
        └─────────────────┘
```

**Key Point**: As we go down, speed decreases but capacity increases!

---

### Functions of Memory Management

| Function | Description |
|----------|-------------|
| **1. Memory Allocation** | Assign memory to processes when they need it |
| **2. Memory Deallocation** | Free memory when process terminates |
| **3. Memory Protection** | Prevent processes from accessing unauthorized memory |
| **4. Memory Sharing** | Allow multiple processes to share same memory region |
| **5. Address Translation** | Convert logical addresses to physical addresses |

---

### Memory Allocation

When a process needs memory, OS must decide **where** to allocate it.

#### Allocation Strategies:

| Strategy | How it Works |
|----------|--------------|
| **First Fit** | Allocate the **first** available block that is big enough |
| **Best Fit** | Allocate the **smallest** block that is big enough |
| **Worst Fit** | Allocate the **largest** available block |

```
Example: Process needs 20 KB

Memory Blocks Available:
┌────────┬────────┬────────┬────────┐
│ 15 KB  │ 30 KB  │ 25 KB  │ 50 KB  │
└────────┴────────┴────────┴────────┘

First Fit → Allocates 30 KB block (first one that fits)
Best Fit  → Allocates 25 KB block (smallest that fits)
Worst Fit → Allocates 50 KB block (largest available)
```

---

### Memory Protection

> Prevents one process from accessing another process's memory area.

**How it works:**
- Each process has **base register** (starting address) and **limit register** (size)
- OS checks every memory access
- If access is outside allowed range → **Error!**

```
┌─────────────────────────────────────────────┐
│                   MEMORY                    │
├──────────────┬──────────────────────────────┤
│              │  Process A's Memory          │
│   Base = 100 │  (100 to 200)                │
│              ├──────────────────────────────┤
│  Limit = 100 │  Process B's Memory          │
│              │  (200 to 350)                │
└──────────────┴──────────────────────────────┘

Process A cannot access memory beyond address 200!
```

---

### Logical vs Physical Address

| Logical Address | Physical Address |
|-----------------|------------------|
| Generated by CPU | Actual location in memory |
| Also called **Virtual Address** | Also called **Real Address** |
| Seen by the program | Seen by the memory unit |
| Translated by **MMU** | Used to access memory |

**MMU (Memory Management Unit)**: Hardware that translates logical addresses to physical addresses.

```
┌─────────┐    Logical     ┌─────────┐    Physical    ┌─────────┐
│   CPU   │───Address────→ │   MMU   │───Address────→ │ Memory  │
└─────────┘                └─────────┘                └─────────┘
```

---

### Brief Introduction to Key Concepts

These concepts will be covered in **detail in Unit 4**:

| Concept | Brief Description |
|---------|-------------------|
| **Paging** | Divide memory into fixed-size pages |
| **Segmentation** | Divide memory into variable-size segments |
| **Swapping** | Move processes between memory and disk |
| **Virtual Memory** | Use disk as extension of RAM |

---

### Key Points for Exam (Memory Management)

1. **Memory Management** = Handling primary memory (RAM)
2. **Memory Hierarchy**: Registers → Cache → RAM → Hard Disk
3. **Three allocation strategies**: First Fit, Best Fit, Worst Fit
4. **Memory Protection** using Base and Limit registers
5. **Logical Address** (CPU generated) → **MMU** → **Physical Address** (actual memory)
6. **Key techniques**: Paging, Segmentation, Swapping, Virtual Memory (detailed in Unit 4)

---

## Possible Exam Questions (Unit 1 Level)

1. **What is a process? How is it different from a program?**
2. **Explain the different states of a process.**
3. **What is PCB? What information does it contain?**
4. **What is IPC? Explain any two methods of IPC.**
5. **What is Memory Management? Why is it needed?**
6. **Explain the memory hierarchy.**
7. **Differentiate between logical and physical address.**
8. **Explain First Fit, Best Fit, and Worst Fit allocation strategies.**

---

---
