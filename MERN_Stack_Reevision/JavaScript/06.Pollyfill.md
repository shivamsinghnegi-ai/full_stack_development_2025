# JavaScript Advanced Concepts

This document provides detailed explanations of important JavaScript concepts including Memoization, Event Delegation, DOM, BOM, Event Bubbling and Capturing, and Polyfills.

---

## Table of Contents
1. [Memoization](#memoization)
2. [Event Delegation](#event-delegation)
3. [DOM (Document Object Model)](#dom-document-object-model)
4. [BOM (Browser Object Model)](#bom-browser-object-model)
5. [Event Bubbling and Event Capturing](#event-bubbling-and-event-capturing)
6. [Polyfills](#polyfills)

---

## Memoization

### What is Memoization?

**Memoization** is an optimization technique used in programming to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again.

### Key Concepts

- **Cache**: A storage mechanism to keep previously computed results
- **Cache Hit**: When the function is called with previously seen arguments, return cached result
- **Cache Miss**: When the function is called with new arguments, compute and cache the result

### Why Use Memoization?

1. **Performance Improvement**: Avoids redundant calculations
2. **Time Optimization**: Reduces execution time for repeated operations
3. **Resource Efficiency**: Saves computational resources

### Implementation Examples

#### Example 1: Basic Memoization for Fibonacci

```javascript
// Without memoization (inefficient)
function fibonacci(n) {
    if (n <= 1) return n;
    return fibonacci(n - 1) + fibonacci(n - 2);
}

// With memoization (efficient)
function memoizedFibonacci() {
    const cache = {};
    
    return function fib(n) {
        if (n in cache) {
            return cache[n];
        }
        
        if (n <= 1) {
            cache[n] = n;
            return n;
        }
        
        cache[n] = fib(n - 1) + fib(n - 2);
        return cache[n];
    };
}

const fib = memoizedFibonacci();
console.log(fib(40)); // Much faster than without memoization
```

#### Example 2: Generic Memoization Function

```javascript
function memoize(fn) {
    const cache = {};
    
    return function(...args) {
        const key = JSON.stringify(args);
        
        if (key in cache) {
            console.log('Cache hit!');
            return cache[key];
        }
        
        console.log('Computing...');
        const result = fn.apply(this, args);
        cache[key] = result;
        return result;
    };
}

// Usage
function expensiveCalculation(a, b) {
    // Simulating expensive operation
    let sum = 0;
    for (let i = 0; i < 1000000; i++) {
        sum += a + b;
    }
    return sum;
}

const memoizedCalculation = memoize(expensiveCalculation);
console.log(memoizedCalculation(5, 3)); // Computing...
console.log(memoizedCalculation(5, 3)); // Cache hit!
```

#### Example 3: Memoization with Map

```javascript
function memoizeWithMap(fn) {
    const cache = new Map();
    
    return function(...args) {
        const key = JSON.stringify(args);
        
        if (cache.has(key)) {
            return cache.get(key);
        }
        
        const result = fn.apply(this, args);
        cache.set(key, result);
        return result;
    };
}
```

### When to Use Memoization

**✅ Good for:**
- Pure functions (same input always produces same output)
- Expensive computations
- Recursive functions with overlapping subproblems
- Functions called frequently with same arguments

**❌ Avoid for:**
- Functions with side effects
- Functions that need different results for same inputs
- Simple functions where overhead exceeds benefit
- Functions with many unique arguments (cache becomes too large)

---

## Event Delegation

### What is Event Delegation?

**Event Delegation** is a technique where instead of attaching event listeners to individual child elements, you attach a single event listener to a parent element and handle events for all children through that parent. This leverages event bubbling.

### Why Use Event Delegation?

1. **Performance**: Reduces memory usage by having fewer event listeners
2. **Dynamic Elements**: Automatically handles elements added after page load
3. **Simplified Code**: Less code to maintain
4. **Better Performance**: Especially beneficial for lists with many items

### How It Works

When an event occurs on a child element, it bubbles up to the parent. The parent's event listener can check which child element triggered the event using `event.target` or `event.currentTarget`.

### Implementation Examples

#### Example 1: Basic Event Delegation

```javascript
// Without event delegation (inefficient)
const listItems = document.querySelectorAll('li');
listItems.forEach(item => {
    item.addEventListener('click', function(e) {
        console.log('Item clicked:', e.target.textContent);
    });
});

// With event delegation (efficient)
const list = document.getElementById('myList');
list.addEventListener('click', function(e) {
    // Check if the clicked element is a list item
    if (e.target.tagName === 'LI') {
        console.log('Item clicked:', e.target.textContent);
    }
});
```

#### Example 2: Event Delegation with Dynamic Elements

```html
<ul id="todoList">
    <li>Task 1</li>
    <li>Task 2</li>
    <li>Task 3</li>
</ul>
<button id="addTask">Add Task</button>
```

```javascript
// This works even for dynamically added elements
const todoList = document.getElementById('todoList');
const addButton = document.getElementById('addTask');
let taskCount = 4;

// Event delegation on parent
todoList.addEventListener('click', function(e) {
    if (e.target.tagName === 'LI') {
        e.target.style.textDecoration = 'line-through';
        console.log('Completed:', e.target.textContent);
    }
    
    // Handle delete button if it exists
    if (e.target.classList.contains('delete')) {
        e.target.parentElement.remove();
    }
});

// Add new tasks dynamically
addButton.addEventListener('click', function() {
    const newLi = document.createElement('li');
    newLi.textContent = `Task ${taskCount++}`;
    todoList.appendChild(newLi);
    // No need to add event listener - delegation handles it!
});
```

#### Example 3: Event Delegation with Multiple Actions

```javascript
const container = document.getElementById('container');

container.addEventListener('click', function(e) {
    const target = e.target;
    
    // Handle different actions based on element
    if (target.classList.contains('delete-btn')) {
        target.closest('.item').remove();
    } else if (target.classList.contains('edit-btn')) {
        const item = target.closest('.item');
        item.contentEditable = true;
    } else if (target.classList.contains('save-btn')) {
        const item = target.closest('.item');
        item.contentEditable = false;
    }
});
```

### Key Methods

- **`event.target`**: The element that triggered the event
- **`event.currentTarget`**: The element that has the event listener attached
- **`event.stopPropagation()`**: Prevents event from bubbling up
- **`element.closest(selector)`**: Finds the nearest ancestor matching selector

### Best Practices

1. Use event delegation for lists, tables, and dynamic content
2. Check the target element to ensure it's the intended element
3. Use `closest()` for complex nested structures
4. Consider performance for very deep DOM trees

---

## DOM (Document Object Model)

### What is DOM?

The **Document Object Model (DOM)** is a programming interface for HTML and XML documents. It represents the page so that programs can change the document structure, style, and content. The DOM represents the document as nodes and objects, enabling programming languages to interact with the page.

### DOM Structure

The DOM is a tree-like structure where:
- **Document**: The root node
- **Elements**: HTML tags (div, p, span, etc.)
- **Text Nodes**: Text content within elements
- **Attributes**: Properties of elements (id, class, src, etc.)

### DOM Tree Example

```html
<html>
  <head>
    <title>My Page</title>
  </head>
  <body>
    <div id="container">
      <p>Hello World</p>
    </div>
  </body>
</html>
```

This creates a tree structure:

```text
Document
└── html
    ├── head
    │   └── title
    │       └── "My Page"
    └── body
        └── div#container
            └── p
                └── "Hello World"
```

### DOM Methods and Properties

#### Selecting Elements

```javascript
// By ID
const element = document.getElementById('myId');

// By class name (returns NodeList)
const elements = document.getElementsByClassName('myClass');

// By tag name (returns NodeList)
const divs = document.getElementsByTagName('div');

// By CSS selector (returns first match)
const element = document.querySelector('.myClass');

// By CSS selector (returns NodeList)
const elements = document.querySelectorAll('.myClass');
```

#### Creating and Modifying Elements

```javascript
// Create element
const div = document.createElement('div');
const text = document.createTextNode('Hello World');

// Append child
div.appendChild(text);
document.body.appendChild(div);

// Set attributes
div.setAttribute('id', 'myDiv');
div.setAttribute('class', 'container');

// Modify content
div.textContent = 'New Text';
div.innerHTML = '<strong>Bold Text</strong>';

// Modify style
div.style.color = 'red';
div.style.backgroundColor = 'blue';
div.style.fontSize = '20px';

// Add/remove classes
div.classList.add('new-class');
div.classList.remove('old-class');
div.classList.toggle('active');
```

#### Traversing the DOM

```javascript
const element = document.querySelector('.myElement');

// Parent
const parent = element.parentElement;
const parentNode = element.parentNode;

// Children
const children = element.children; // HTMLCollection
const childNodes = element.childNodes; // NodeList (includes text nodes)

// Siblings
const nextSibling = element.nextElementSibling;
const previousSibling = element.previousElementSibling;

// First and last child
const firstChild = element.firstElementChild;
const lastChild = element.lastElementChild;
```

#### DOM Events

```javascript
// Add event listener
element.addEventListener('click', function(e) {
    console.log('Clicked!');
});

// Remove event listener
function handleClick() {
    console.log('Clicked!');
}
element.addEventListener('click', handleClick);
element.removeEventListener('click', handleClick);

// Common events
element.addEventListener('click', handler);
element.addEventListener('mouseenter', handler);
element.addEventListener('mouseleave', handler);
element.addEventListener('focus', handler);
element.addEventListener('blur', handler);
element.addEventListener('submit', handler);
element.addEventListener('keydown', handler);
element.addEventListener('keyup', handler);
element.addEventListener('change', handler);
```

### DOM Manipulation Examples

#### Example 1: Dynamic List Creation

```javascript
function createList(items) {
    const ul = document.createElement('ul');
    
    items.forEach(item => {
        const li = document.createElement('li');
        li.textContent = item;
        ul.appendChild(li);
    });
    
    document.body.appendChild(ul);
}

createList(['Apple', 'Banana', 'Orange']);
```

#### Example 2: Form Handling

```javascript
const form = document.getElementById('myForm');

form.addEventListener('submit', function(e) {
    e.preventDefault(); // Prevent form submission
    
    const formData = new FormData(form);
    const data = Object.fromEntries(formData);
    
    console.log('Form data:', data);
    
    // Process form data
    processFormData(data);
});
```

#### Example 3: Dynamic Content Updates

```javascript
function updateCounter(count) {
    const counter = document.getElementById('counter');
    counter.textContent = count;
    
    // Add animation
    counter.classList.add('pulse');
    setTimeout(() => {
        counter.classList.remove('pulse');
    }, 300);
}
```

### DOM Performance Tips

1. **Cache DOM queries**: Store frequently accessed elements
2. **Use DocumentFragment**: For multiple DOM operations
3. **Batch DOM updates**: Make changes off-screen, then append
4. **Use event delegation**: Reduce number of event listeners
5. **Avoid layout thrashing**: Read and write separately

```javascript
// Good: Batch DOM updates
const fragment = document.createDocumentFragment();
for (let i = 0; i < 100; i++) {
    const div = document.createElement('div');
    div.textContent = `Item ${i}`;
    fragment.appendChild(div);
}
document.body.appendChild(fragment);
```

---

## BOM (Browser Object Model)

### What is BOM?

The **Browser Object Model (BOM)** is a browser-specific convention referring to all the objects exposed by the web browser. Unlike the DOM, the BOM is not standardized and varies between browsers. The `window` object is the main object in the BOM.

### Window Object

The `window` object represents the browser window and is the global object in JavaScript for browser environments.

#### Window Properties

```javascript
// Window dimensions
console.log(window.innerWidth);   // Inner width of window
console.log(window.innerHeight);  // Inner height of window
console.log(window.outerWidth);   // Outer width of window
console.log(window.outerHeight);  // Outer height of window

// Screen information
console.log(window.screen.width);
console.log(window.screen.height);
console.log(window.screen.availWidth);
console.log(window.screen.availHeight);
```

#### Window Methods

```javascript
// Alert, Confirm, Prompt
window.alert('Hello!');
const confirmed = window.confirm('Are you sure?');
const name = window.prompt('Enter your name:', 'Default');

// Opening and closing windows
const newWindow = window.open('https://example.com', '_blank', 'width=800,height=600');
newWindow.close();

// Scrolling
window.scrollTo(0, 100);
window.scrollTo({ top: 100, left: 0, behavior: 'smooth' });
window.scrollBy(0, 100);

// Focus and blur
window.focus();
window.blur();
```

### Location Object

The `location` object contains information about the current URL.

```javascript
// Location properties
console.log(window.location.href);      // Full URL
console.log(window.location.protocol);  // http: or https:
console.log(window.location.host);      // hostname:port
console.log(window.location.hostname);  // hostname
console.log(window.location.port);      // port number
console.log(window.location.pathname);  // path
console.log(window.location.search);    // query string
console.log(window.location.hash);      // hash fragment

// Location methods
window.location.assign('https://example.com');
window.location.replace('https://example.com'); // Doesn't create history entry
window.location.reload(); // Reload current page
window.location.reload(true); // Force reload from server
```

### History Object

The `history` object allows you to manipulate the browser's session history.

```javascript
// History methods
window.history.back();      // Go back
window.history.forward();   // Go forward
window.history.go(-2);      // Go back 2 pages
window.history.go(1);       // Go forward 1 page
window.history.go(0);       // Reload current page

// History length
console.log(window.history.length); // Number of entries

// Push state (HTML5 History API)
window.history.pushState({ page: 1 }, 'Title', '/page1');
window.history.replaceState({ page: 2 }, 'Title', '/page2');

// Popstate event
window.addEventListener('popstate', function(e) {
    console.log('State:', e.state);
});
```

### Navigator Object

The `navigator` object contains information about the browser.

```javascript
// Browser information
console.log(navigator.userAgent);      // User agent string
console.log(navigator.platform);       // Platform
console.log(navigator.language);       // Language
console.log(navigator.cookieEnabled);  // Cookie support
console.log(navigator.onLine);         // Online status

// Browser capabilities
console.log(navigator.geolocation);    // Geolocation API
console.log(navigator.mediaDevices);   // Media devices

// Geolocation example
if (navigator.geolocation) {
    navigator.geolocation.getCurrentPosition(function(position) {
        console.log('Latitude:', position.coords.latitude);
        console.log('Longitude:', position.coords.longitude);
    });
}
```

### Screen Object

The `screen` object contains information about the user's screen.

```javascript
console.log(screen.width);        // Screen width
console.log(screen.height);       // Screen height
console.log(screen.availWidth);   // Available width
console.log(screen.availHeight);  // Available height
console.log(screen.colorDepth);   // Color depth
console.log(screen.pixelDepth);   // Pixel depth
```

### Timing Functions

```javascript
// setTimeout - Execute once after delay
const timeoutId = setTimeout(function() {
    console.log('This runs after 2 seconds');
}, 2000);

// Clear timeout
clearTimeout(timeoutId);

// setInterval - Execute repeatedly
const intervalId = setInterval(function() {
    console.log('This runs every second');
}, 1000);

// Clear interval
clearInterval(intervalId);

// RequestAnimationFrame - For animations
function animate() {
    // Animation code
    requestAnimationFrame(animate);
}
requestAnimationFrame(animate);
```

### Local Storage and Session Storage

```javascript
// Local Storage (persists across sessions)
localStorage.setItem('key', 'value');
const value = localStorage.getItem('key');
localStorage.removeItem('key');
localStorage.clear();

// Session Storage (cleared when tab closes)
sessionStorage.setItem('key', 'value');
const value = sessionStorage.getItem('key');
sessionStorage.removeItem('key');
sessionStorage.clear();

// Store objects
const data = { name: 'John', age: 30 };
localStorage.setItem('user', JSON.stringify(data));
const user = JSON.parse(localStorage.getItem('user'));
```

### BOM Examples

#### Example 1: URL Manipulation

```javascript
function getQueryParams() {
    const params = new URLSearchParams(window.location.search);
    return Object.fromEntries(params);
}

// URL: https://example.com?name=John&age=30
console.log(getQueryParams()); // { name: 'John', age: '30' }
```

#### Example 2: Page Visibility API

```javascript
document.addEventListener('visibilitychange', function() {
    if (document.hidden) {
        console.log('Page is hidden');
    } else {
        console.log('Page is visible');
    }
});
```

#### Example 3: Online/Offline Detection

```javascript
window.addEventListener('online', function() {
    console.log('Connection restored');
});

window.addEventListener('offline', function() {
    console.log('Connection lost');
});

console.log('Online status:', navigator.onLine);
```

---

## Event Bubbling and Event Capturing

### Event Flow

When an event occurs on an element, it doesn't just happen on that element. The event follows a specific flow through the DOM:

1. **Capturing Phase**: Event travels from root to target
2. **Target Phase**: Event reaches the target element
3. **Bubbling Phase**: Event travels from target back to root

**Event Flow Diagram:**

```text
         [Window]
            |
         [Document]
            |
         [html]
            |
         [body]
            |
        [div] <- Event occurs here
            |
         [p] <- Target element
```

### Event Bubbling

**Event Bubbling** is the default behavior where events propagate upward from the target element to its ancestors.

```html
<div id="grandparent">
    <div id="parent">
        <div id="child">
            Click me!
        </div>
    </div>
</div>
```

```javascript
const grandparent = document.getElementById('grandparent');
const parent = document.getElementById('parent');
const child = document.getElementById('child');

// Event bubbling (default)
child.addEventListener('click', function(e) {
    console.log('Child clicked');
});

parent.addEventListener('click', function(e) {
    console.log('Parent clicked');
});

grandparent.addEventListener('click', function(e) {
    console.log('Grandparent clicked');
});

// Output when child is clicked:
// Child clicked
// Parent clicked
// Grandparent clicked
```

### Event Capturing

**Event Capturing** (also called Trickling) is the opposite phase where events propagate downward from root to target.

```javascript
// Event capturing (set third parameter to true)
child.addEventListener('click', function(e) {
    console.log('Child clicked');
}, true); // true enables capturing

parent.addEventListener('click', function(e) {
    console.log('Parent clicked');
}, true);

grandparent.addEventListener('click', function(e) {
    console.log('Grandparent clicked');
}, true);

// Output when child is clicked:
// Grandparent clicked
// Parent clicked
// Child clicked
```

### Stopping Event Propagation

```javascript
// Stop bubbling
child.addEventListener('click', function(e) {
    e.stopPropagation(); // Prevents event from bubbling up
    console.log('Child clicked');
});

// Stop immediate propagation
child.addEventListener('click', function(e) {
    e.stopImmediatePropagation(); // Stops all handlers on this element
    console.log('Child clicked');
});
```

### Event Object Properties

```javascript
element.addEventListener('click', function(e) {
    console.log(e.target);        // Element that triggered event
    console.log(e.currentTarget); // Element with event listener
    console.log(e.type);          // Event type ('click', 'mouseover', etc.)
    
    // Methods
    e.preventDefault();    // Prevent default behavior
    e.stopPropagation();   // Stop propagation
});
```

### Practical Examples

#### Example 1: Event Bubbling Use Case

```html
<ul id="menu">
    <li><a href="/home">Home</a></li>
    <li><a href="/about">About</a></li>
    <li><a href="/contact">Contact</a></li>
</ul>
```

```javascript
const menu = document.getElementById('menu');

// Single event listener on parent (event delegation)
menu.addEventListener('click', function(e) {
    // Check if clicked element is a link
    if (e.target.tagName === 'A') {
        e.preventDefault();
        console.log('Navigating to:', e.target.href);
        // Handle navigation
    }
});
```

#### Example 2: Preventing Default Behavior

```javascript
const form = document.getElementById('myForm');

form.addEventListener('submit', function(e) {
    e.preventDefault(); // Prevent form submission
    // Custom validation and submission
    validateAndSubmit();
});
```

#### Example 3: Handling Nested Elements

```html
<div class="card">
    <h2>Card Title</h2>
    <p>Card content</p>
    <button class="delete-btn">Delete</button>
</div>
```

```javascript
const card = document.querySelector('.card');
const deleteBtn = document.querySelector('.delete-btn');

card.addEventListener('click', function(e) {
    console.log('Card clicked');
});

deleteBtn.addEventListener('click', function(e) {
    e.stopPropagation(); // Prevent card click from firing
    console.log('Delete button clicked');
    // Delete logic
});
```

### Event Delegation vs Direct Binding

```javascript
// Direct binding (each element gets its own listener)
const buttons = document.querySelectorAll('.btn');
buttons.forEach(btn => {
    btn.addEventListener('click', handleClick);
});

// Event delegation (single listener on parent)
const container = document.querySelector('.container');
container.addEventListener('click', function(e) {
    if (e.target.classList.contains('btn')) {
        handleClick(e);
    }
});
```

### Best Practices

1. **Use event delegation** for dynamic content and multiple elements
2. **Stop propagation carefully** - only when necessary
3. **Understand the difference** between `target` and `currentTarget`
4. **Use capturing phase** when you need to handle events before they reach target
5. **Prevent default behavior** when implementing custom functionality

---

## Polyfills

### What is a Polyfill?

A **Polyfill** is a piece of code (usually JavaScript) that provides functionality that is not natively supported by a browser. It "fills in" the gaps to provide backward compatibility for older browsers.

### Why Use Polyfills?

1. **Browser Compatibility**: Support features in older browsers
2. **Progressive Enhancement**: Use modern APIs while maintaining compatibility
3. **Feature Detection**: Provide alternatives when features aren't available
4. **Smooth Migration**: Use new features before all browsers support them

### How Polyfills Work

1. **Feature Detection**: Check if feature exists
2. **Implementation**: Provide implementation if missing
3. **Native Preference**: Use native implementation if available

### Common Polyfill Examples

#### Example 1: Array.forEach() Polyfill

```javascript
// Polyfill for Array.forEach (for IE8 and below)
if (!Array.prototype.forEach) {
    Array.prototype.forEach = function(callback, thisArg) {
        if (this == null) {
            throw new TypeError('Array.prototype.forEach called on null or undefined');
        }
        
        if (typeof callback !== 'function') {
            throw new TypeError(callback + ' is not a function');
        }
        
        const O = Object(this);
        const len = O.length >>> 0; // Convert to 32-bit integer
        let k = 0;
        
        while (k < len) {
            if (k in O) {
                callback.call(thisArg, O[k], k, O);
            }
            k++;
        }
    };
}
```

#### Example 2: Array.map() Polyfill

```javascript
// Polyfill for Array.map
if (!Array.prototype.map) {
    Array.prototype.map = function(callback, thisArg) {
        if (this == null) {
            throw new TypeError('Array.prototype.map called on null or undefined');
        }
        
        if (typeof callback !== 'function') {
            throw new TypeError(callback + ' is not a function');
        }
        
        const O = Object(this);
        const len = O.length >>> 0;
        const A = new Array(len);
        let k = 0;
        
        while (k < len) {
            if (k in O) {
                const kValue = O[k];
                const mappedValue = callback.call(thisArg, kValue, k, O);
                A[k] = mappedValue;
            }
            k++;
        }
        
        return A;
    };
}
```

#### Example 3: Array.filter() Polyfill

```javascript
// Polyfill for Array.filter
if (!Array.prototype.filter) {
    Array.prototype.filter = function(callback, thisArg) {
        if (this == null) {
            throw new TypeError('Array.prototype.filter called on null or undefined');
        }
        
        if (typeof callback !== 'function') {
            throw new TypeError(callback + ' is not a function');
        }
        
        const O = Object(this);
        const len = O.length >>> 0;
        const A = [];
        let k = 0;
        
        while (k < len) {
            if (k in O) {
                const kValue = O[k];
                if (callback.call(thisArg, kValue, k, O)) {
                    A.push(kValue);
                }
            }
            k++;
        }
        
        return A;
    };
}
```

#### Example 4: Array.find() Polyfill

```javascript
// Polyfill for Array.find
if (!Array.prototype.find) {
    Array.prototype.find = function(callback, thisArg) {
        if (this == null) {
            throw new TypeError('Array.prototype.find called on null or undefined');
        }
        
        if (typeof callback !== 'function') {
            throw new TypeError(callback + ' is not a function');
        }
        
        const O = Object(this);
        const len = O.length >>> 0;
        let k = 0;
        
        while (k < len) {
            if (k in O) {
                const kValue = O[k];
                if (callback.call(thisArg, kValue, k, O)) {
                    return kValue;
                }
            }
            k++;
        }
        
        return undefined;
    };
}
```

#### Example 5: Object.assign() Polyfill

```javascript
// Polyfill for Object.assign
if (typeof Object.assign !== 'function') {
    Object.assign = function(target) {
        if (target == null) {
            throw new TypeError('Cannot convert undefined or null to object');
        }
        
        const to = Object(target);
        
        for (let index = 1; index < arguments.length; index++) {
            const nextSource = arguments[index];
            
            if (nextSource != null) {
                for (const nextKey in nextSource) {
                    if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
                        to[nextKey] = nextSource[nextKey];
                    }
                }
            }
        }
        
        return to;
    };
}
```

#### Example 6: Promise Polyfill (Simplified)

```javascript
// Simplified Promise polyfill
(function() {
    function Promise(executor) {
        const self = this;
        self.state = 'pending';
        self.value = undefined;
        self.handlers = [];
        
        function resolve(result) {
            if (self.state === 'pending') {
                self.state = 'fulfilled';
                self.value = result;
                self.handlers.forEach(handle);
            }
        }
        
        function reject(error) {
            if (self.state === 'pending') {
                self.state = 'rejected';
                self.value = error;
                self.handlers.forEach(handle);
            }
        }
        
        function handle(handler) {
            if (self.state === 'pending') {
                self.handlers.push(handler);
            } else {
                if (self.state === 'fulfilled' && typeof handler.onFulfilled === 'function') {
                    handler.onFulfilled(self.value);
                }
                if (self.state === 'rejected' && typeof handler.onRejected === 'function') {
                    handler.onRejected(self.value);
                }
            }
        }
        
        self.then = function(onFulfilled, onRejected) {
            return new Promise(function(resolve, reject) {
                handle({
                    onFulfilled: function(result) {
                        try {
                            resolve(onFulfilled ? onFulfilled(result) : result);
                        } catch (ex) {
                            reject(ex);
                        }
                    },
                    onRejected: function(error) {
                        try {
                            resolve(onRejected ? onRejected(error) : error);
                        } catch (ex) {
                            reject(ex);
                        }
                    }
                });
            });
        };
        
        executor(resolve, reject);
    }
    
    if (typeof window !== 'undefined' && !window.Promise) {
        window.Promise = Promise;
    }
})();
```

#### Example 7: String.trim() Polyfill

```javascript
// Polyfill for String.trim
if (!String.prototype.trim) {
    String.prototype.trim = function() {
        return this.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');
    };
}
```

#### Example 8: Function.bind() Polyfill

```javascript
// Polyfill for Function.bind
if (!Function.prototype.bind) {
    Function.prototype.bind = function(oThis) {
        if (typeof this !== 'function') {
            throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
        }
        
        const aArgs = Array.prototype.slice.call(arguments, 1);
        const fToBind = this;
        const fNOP = function() {};
        const fBound = function() {
            return fToBind.apply(
                this instanceof fNOP ? this : oThis,
                aArgs.concat(Array.prototype.slice.call(arguments))
            );
        };
        
        if (this.prototype) {
            fNOP.prototype = this.prototype;
        }
        fBound.prototype = new fNOP();
        
        return fBound;
    };
}
```

### Using Polyfill Libraries

Instead of writing polyfills manually, you can use libraries:

#### Core-js

```bash
npm install core-js
```

```javascript
// Import specific polyfills
import 'core-js/features/array/from';
import 'core-js/features/promise';
import 'core-js/features/object/assign';

// Or import all
import 'core-js/stable';
```

#### Polyfill.io

Add to HTML:

```html
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6,Array.prototype.includes"></script>
```

### Feature Detection Pattern

```javascript
// Feature detection before using polyfill
if (!Array.prototype.includes) {
    // Provide polyfill
    Array.prototype.includes = function(searchElement) {
        // Implementation
    };
}

// Use feature
[1, 2, 3].includes(2); // Works in all browsers
```

### Best Practices

1. **Feature Detection First**: Always check if feature exists before polyfilling
2. **Use Well-Tested Libraries**: Prefer established polyfill libraries
3. **Conditional Loading**: Only load polyfills for browsers that need them
4. **Performance**: Consider polyfill performance impact
5. **Keep Updated**: Update polyfills as browsers add native support
6. **Test Thoroughly**: Test polyfills in target browsers

### Modern Alternatives

Instead of polyfills, consider:

1. **Transpilation**: Use Babel to convert modern code to older syntax
2. **Progressive Enhancement**: Build for modern browsers, enhance for older ones
3. **Browser Support Policy**: Define minimum browser versions
4. **Feature Flags**: Detect and use features when available

---

## Summary

### Key Takeaways

1. **Memoization**: Cache function results to improve performance for repeated calculations
2. **Event Delegation**: Use parent elements to handle events for multiple children, improving performance
3. **DOM**: Tree structure representing HTML documents, enabling programmatic manipulation
4. **BOM**: Browser-specific objects (`window`, `location`, `history`, `navigator`) for browser interaction
5. **Event Bubbling/Capturing**: Event propagation mechanisms enabling event delegation and precise event handling
6. **Polyfills**: Code that provides modern functionality in older browsers

### When to Use Each

- **Memoization**: Expensive computations, recursive functions, caching API responses
- **Event Delegation**: Lists, dynamic content, multiple similar elements
- **DOM Manipulation**: Dynamic content creation, form handling, UI updates
- **BOM**: Browser navigation, storage, screen information, timing
- **Event Bubbling/Capturing**: Event delegation, custom event handling, nested components
- **Polyfills**: Supporting older browsers, progressive enhancement, feature compatibility

---

## Resources

- [MDN Web Docs](https://developer.mozilla.org/) - Comprehensive JavaScript documentation
- [JavaScript.info](https://javascript.info/) - Modern JavaScript tutorials
- [Can I Use](https://caniuse.com/) - Browser compatibility checker
- [Polyfill.io](https://polyfill.io/) - Polyfill service
- [Core-js](https://github.com/zloirock/core-js) - Modular polyfill library

---

*Last updated: 2024*

