# JavaScript Object-Oriented Programming (OOP)

## 1. ENCAPSULATION

### What is Encapsulation?
Encapsulation is the bundling of data (properties) and methods (functions) that operate on that data into a single unit called an object. It also involves hiding internal implementation details and exposing only what's necessary through a controlled interface.

### Key Concepts:
- **Data Hiding**: Private properties/methods that can't be accessed directly from outside
- **Controlled Access**: Public methods that allow controlled interaction with private data
- **Modularity**: Related functionality is grouped together

### Implementation in JavaScript:

#### Using Closures (Traditional Approach)
```javascript
// Example 1: Bank Account with Encapsulation
function BankAccount(initialBalance) {
    // Private variable
    let balance = initialBalance;
    
    // Private method
    function validateAmount(amount) {
        return amount > 0 && typeof amount === 'number';
    }
    
    // Public methods (returned interface)
    return {
        // Getter method
        getBalance: function() {
            return balance;
        },
        
        // Setter method with validation
        deposit: function(amount) {
            if (validateAmount(amount)) {
                balance += amount;
                return `Deposited ${amount}. New balance: ${balance}`;
            }
            return 'Invalid deposit amount';
        },
        
        // Setter method with validation
        withdraw: function(amount) {
            if (validateAmount(amount)) {
                if (amount <= balance) {
                    balance -= amount;
                    return `Withdrawn ${amount}. New balance: ${balance}`;
                }
                return 'Insufficient funds';
            }
            return 'Invalid withdrawal amount';
        }
    };
}

// Usage
const account1 = BankAccount(1000);
console.log(account1.getBalance()); // 1000
console.log(account1.deposit(500));  // Deposited 500. New balance: 1500
console.log(account1.withdraw(200)); // Withdrawn 200. New balance: 1300
// console.log(account1.balance); // undefined - can't access private variable
```

#### Using ES6 Classes with Private Fields (Modern Approach)
```javascript
// Example 2: User Profile with Encapsulation
class UserProfile {
    // Private fields (using #)
    #password;
    #email;
    #loginAttempts;
    
    // Public field
    username;
    
    constructor(username, email, password) {
        this.username = username;
        this.#email = email;
        this.#password = password;
        this.#loginAttempts = 0;
    }
    
    // Private method
    #hashPassword(password) {
        // Simulated password hashing
        return `hashed_${password}_${Date.now()}`;
    }
    
    // Public method
    getEmail() {
        return this.#email;
    }
    
    // Public method with validation
    updatePassword(oldPassword, newPassword) {
        if (this.#password === this.#hashPassword(oldPassword)) {
            this.#password = this.#hashPassword(newPassword);
            return 'Password updated successfully';
        }
        return 'Invalid old password';
    }
    
    // Public method
    login(enteredPassword) {
        if (this.#loginAttempts >= 3) {
            return 'Account locked. Too many failed attempts.';
        }
        
        if (this.#password === this.#hashPassword(enteredPassword)) {
            this.#loginAttempts = 0;
            return 'Login successful';
        }
        
        this.#loginAttempts++;
        return `Login failed. Attempts: ${this.#loginAttempts}/3`;
    }
}

// Usage
const user = new UserProfile('john_doe', 'john@example.com', 'secret123');
console.log(user.username);      // john_doe (public)
// console.log(user.#password);  // Error: Private field
console.log(user.getEmail());    // john@example.com
```

#### Using WeakMap for Private Properties
```javascript
// Example 3: Shopping Cart with Encapsulation
const privateData = new WeakMap();

class ShoppingCart {
    constructor(customerId) {
        // Store private data in WeakMap
        privateData.set(this, {
            items: [],
            customerId: customerId,
            discountCode: null,
            total: 0
        });
    }
    
    // Helper method to get private data
    #getPrivate() {
        return privateData.get(this);
    }
    
    // Public method
    addItem(product, quantity = 1) {
        const data = this.#getPrivate();
        
        const existingItem = data.items.find(item => item.product.id === product.id);
        
        if (existingItem) {
            existingItem.quantity += quantity;
        } else {
            data.items.push({ product, quantity });
        }
        
        this.#calculateTotal();
        return `${quantity} x ${product.name} added to cart`;
    }
    
    // Private method
    #calculateTotal() {
        const data = this.#getPrivate();
        data.total = data.items.reduce((sum, item) => {
            return sum + (item.product.price * item.quantity);
        }, 0);
        
        // Apply discount if exists
        if (data.discountCode) {
            data.total *= 0.9; // 10% discount
        }
    }
    
    // Public method
    applyDiscount(code) {
        const data = this.#getPrivate();
        if (code === 'SAVE10') {
            data.discountCode = code;
            this.#calculateTotal();
            return 'Discount applied!';
        }
        return 'Invalid discount code';
    }
    
    // Public method
    getTotal() {
        return this.#getPrivate().total;
    }
    
    // Public method
    getItems() {
        return this.#getPrivate().items.map(item => ({
            name: item.product.name,
            quantity: item.quantity,
            price: item.product.price
        }));
    }
}

// Usage
const cart = new ShoppingCart('CUST001');
cart.addItem({ id: 1, name: 'Laptop', price: 999 }, 1);
cart.addItem({ id: 2, name: 'Mouse', price: 25 }, 2);
cart.applyDiscount('SAVE10');
console.log(cart.getTotal()); // 919.1 (10% discount applied)
```

### Benefits of Encapsulation:
1. **Data Protection**: Prevents accidental modification of internal state
2. **Controlled Access**: Validation and business logic can be enforced
3. **Maintainability**: Changes to implementation don't affect external code
4. **Code Organization**: Related functionality is grouped together

---

## 2. ABSTRACTION

### What is Abstraction?
Abstraction is the concept of hiding complex implementation details and showing only the essential features of an object. It focuses on what an object does rather than how it does it. Users interact with a simplified interface without needing to understand the underlying complexity.

### Key Concepts:
- **Simplified Interface**: Only expose necessary methods and properties
- **Hide Complexity**: Internal implementation details are hidden
- **Focus on Functionality**: Users care about what it does, not how
- **Contract-Based**: Defines a contract that classes must follow

### Implementation in JavaScript:

#### Using Abstract Classes (Simulated)
```javascript
// Example 1: Abstract Vehicle Class
class Vehicle {
    constructor(brand, model) {
        if (this.constructor === Vehicle) {
            throw new Error('Cannot instantiate abstract class Vehicle');
        }
        this.brand = brand;
        this.model = model;
    }
    
    // Abstract method - must be implemented by subclasses
    start() {
        throw new Error('Method start() must be implemented');
    }
    
    // Abstract method - must be implemented by subclasses
    stop() {
        throw new Error('Method stop() must be implemented');
    }
    
    // Concrete method - can be used as-is
    getInfo() {
        return `${this.brand} ${this.model}`;
    }
    
    // Abstract method for fuel type
    getFuelType() {
        throw new Error('Method getFuelType() must be implemented');
    }
}

// Concrete implementation
class Car extends Vehicle {
    constructor(brand, model, fuelType) {
        super(brand, model);
        this.#fuelType = fuelType;
        this.#engineStatus = 'off';
    }
    
    #fuelType;
    #engineStatus;
    
    // Implementing abstract method
    start() {
        this.#engineStatus = 'on';
        return `${this.getInfo()} engine started`;
    }
    
    // Implementing abstract method
    stop() {
        this.#engineStatus = 'off';
        return `${this.getInfo()} engine stopped`;
    }
    
    // Implementing abstract method
    getFuelType() {
        return this.#fuelType;
    }
    
    // Additional specific method
    honk() {
        return 'Beep beep!';
    }
}

// Another concrete implementation
class ElectricBike extends Vehicle {
    constructor(brand, model, batteryLevel) {
        super(brand, model);
        this.#batteryLevel = batteryLevel;
        this.#powerStatus = false;
    }
    
    #batteryLevel;
    #powerStatus;
    
    // Implementing abstract method
    start() {
        if (this.#batteryLevel > 0) {
            this.#powerStatus = true;
            return `${this.getInfo()} powered on. Battery: ${this.#batteryLevel}%`;
        }
        return `${this.getInfo()} - Battery too low to start`;
    }
    
    // Implementing abstract method
    stop() {
        this.#powerStatus = false;
        return `${this.getInfo()} powered off`;
    }
    
    // Implementing abstract method
    getFuelType() {
        return 'Electric';
    }
    
    // Additional specific method
    checkBattery() {
        return `Battery level: ${this.#batteryLevel}%`;
    }
}

// Usage
const car = new Car('Toyota', 'Camry', 'Gasoline');
console.log(car.start());        // Toyota Camry engine started
console.log(car.getFuelType());  // Gasoline
console.log(car.honk());          // Beep beep!

const bike = new ElectricBike('Tesla', 'Model E', 85);
console.log(bike.start());        // Tesla Model E powered on. Battery: 85%
console.log(bike.getFuelType());  // Electric
```

#### Using Interfaces (Simulated with Abstract Methods)
```javascript
// Example 2: Payment Processing Abstraction
class PaymentProcessor {
    constructor() {
        if (this.constructor === PaymentProcessor) {
            throw new Error('PaymentProcessor is an abstract class');
        }
    }
    
    // Abstract method - payment processing
    processPayment(amount) {
        throw new Error('processPayment() must be implemented');
    }
    
    // Abstract method - refund processing
    processRefund(transactionId) {
        throw new Error('processRefund() must be implemented');
    }
    
    // Abstract method - validation
    validatePayment(amount) {
        throw new Error('validatePayment() must be implemented');
    }
    
    // Concrete utility method
    formatCurrency(amount) {
        return `$${amount.toFixed(2)}`;
    }
}

// Concrete implementation - Credit Card
class CreditCardProcessor extends PaymentProcessor {
    #cardNumber;
    #cvv;
    
    constructor(cardNumber, cvv) {
        super();
        this.#cardNumber = cardNumber;
        this.#cvv = cvv;
    }
    
    // Hidden complexity - card validation
    #validateCard() {
        return this.#cardNumber.length === 16 && this.#cvv.length === 3;
    }
    
    // Hidden complexity - card processing logic
    #chargeCard(amount) {
        // Simulated API call
        console.log('Connecting to payment gateway...');
        console.log(`Verifying card ${this.#maskCardNumber()}...`);
        return { success: true, transactionId: `CC-${Date.now()}` };
    }
    
    // Hidden complexity - masking
    #maskCardNumber() {
        return `****-****-****-${this.#cardNumber.slice(-4)}`;
    }
    
    // Public interface - simple for users
    processPayment(amount) {
        if (!this.validatePayment(amount)) {
            return { success: false, error: 'Invalid payment amount' };
        }
        
        if (!this.#validateCard()) {
            return { success: false, error: 'Invalid card details' };
        }
        
        const result = this.#chargeCard(amount);
        return {
            success: result.success,
            message: `Credit card payment of ${this.formatCurrency(amount)} processed`,
            transactionId: result.transactionId
        };
    }
    
    processRefund(transactionId) {
        console.log(`Processing refund for transaction ${transactionId}...`);
        return {
            success: true,
            message: `Refund processed for ${transactionId}`
        };
    }
    
    validatePayment(amount) {
        return amount > 0 && amount <= 10000;
    }
}

// Concrete implementation - PayPal
class PayPalProcessor extends PaymentProcessor {
    #email;
    
    constructor(email) {
        super();
        this.#email = email;
    }
    
    // Hidden complexity - PayPal authentication
    #authenticatePayPal() {
        console.log(`Authenticating PayPal account: ${this.#email}...`);
        return true;
    }
    
    // Hidden complexity - PayPal API call
    #paypalCharge(amount) {
        console.log('Connecting to PayPal API...');
        return { success: true, transactionId: `PP-${Date.now()}` };
    }
    
    // Public interface - simple for users
    processPayment(amount) {
        if (!this.validatePayment(amount)) {
            return { success: false, error: 'Invalid payment amount' };
        }
        
        if (!this.#authenticatePayPal()) {
            return { success: false, error: 'PayPal authentication failed' };
        }
        
        const result = this.#paypalCharge(amount);
        return {
            success: result.success,
            message: `PayPal payment of ${this.formatCurrency(amount)} processed`,
            transactionId: result.transactionId
        };
    }
    
    processRefund(transactionId) {
        console.log(`Processing PayPal refund for ${transactionId}...`);
        return {
            success: true,
            message: `PayPal refund processed for ${transactionId}`
        };
    }
    
    validatePayment(amount) {
        return amount > 0 && amount <= 5000;
    }
}

// Usage - User doesn't need to know implementation details
const creditCard = new CreditCardProcessor('1234567890123456', '123');
console.log(creditCard.processPayment(100));
// Output: Connecting to payment gateway...
//         Verifying card ****-****-****-3456...
//         { success: true, message: 'Credit card payment of $100.00 processed', ... }

const paypal = new PayPalProcessor('user@example.com');
console.log(paypal.processPayment(50));
// Output: Authenticating PayPal account: user@example.com...
//         Connecting to PayPal API...
//         { success: true, message: 'PayPal payment of $50.00 processed', ... }
```

#### Using Composition for Abstraction
```javascript
// Example 3: Notification System Abstraction
class NotificationService {
    constructor() {
        if (this.constructor === NotificationService) {
            throw new Error('NotificationService is abstract');
        }
    }
    
    // Abstract method
    send(message, recipient) {
        throw new Error('send() must be implemented');
    }
    
    // Concrete utility
    formatMessage(message) {
        return `[${new Date().toISOString()}] ${message}`;
    }
}

class EmailNotification extends NotificationService {
    #smtpConfig;
    
    constructor(smtpConfig) {
        super();
        this.#smtpConfig = smtpConfig;
    }
    
    // Hidden complexity - SMTP connection
    #connectToSMTP() {
        console.log(`Connecting to ${this.#smtpConfig.host}:${this.#smtpConfig.port}...`);
        return true;
    }
    
    // Hidden complexity - email formatting
    #formatEmail(message, recipient) {
        return {
            to: recipient,
            subject: 'Notification',
            body: this.formatMessage(message),
            headers: {
                'From': this.#smtpConfig.from,
                'Content-Type': 'text/plain'
            }
        };
    }
    
    // Simple public interface
    send(message, recipient) {
        if (!this.#connectToSMTP()) {
            return { success: false, error: 'SMTP connection failed' };
        }
        
        const email = this.#formatEmail(message, recipient);
        console.log(`Sending email to ${recipient}...`);
        return { success: true, message: 'Email sent successfully' };
    }
}

class SMSNotification extends NotificationService {
    #apiKey;
    
    constructor(apiKey) {
        super();
        this.#apiKey = apiKey;
    }
    
    // Hidden complexity - SMS API integration
    #sendViaSMS(message, recipient) {
        console.log(`Using API key: ${this.#apiKey.substring(0, 5)}...`);
        console.log(`Sending SMS to ${recipient}...`);
        return true;
    }
    
    // Simple public interface
    send(message, recipient) {
        const formatted = this.formatMessage(message);
        const success = this.#sendViaSMS(formatted, recipient);
        return { success, message: 'SMS sent successfully' };
    }
}

// Abstraction layer - user doesn't care about implementation
class NotificationManager {
    #services;
    
    constructor() {
        this.#services = [];
    }
    
    addService(service) {
        if (!(service instanceof NotificationService)) {
            throw new Error('Service must extend NotificationService');
        }
        this.#services.push(service);
    }
    
    // Simple interface - hides complexity
    notifyAll(message, recipients) {
        const results = [];
        recipients.forEach(recipient => {
            this.#services.forEach(service => {
                results.push(service.send(message, recipient));
            });
        });
        return results;
    }
}

// Usage
const emailService = new EmailNotification({
    host: 'smtp.example.com',
    port: 587,
    from: 'noreply@example.com'
});

const smsService = new SMSNotification('API_KEY_12345');

const manager = new NotificationManager();
manager.addService(emailService);
manager.addService(smsService);

// User just calls notify - doesn't need to know about SMTP or SMS APIs
manager.notifyAll('Order confirmed!', ['user@example.com', '+1234567890']);
```

### Benefits of Abstraction:
1. **Simplified Interface**: Users interact with simple, clear methods
2. **Complexity Hiding**: Internal details are hidden, reducing cognitive load
3. **Flexibility**: Implementation can change without affecting users
4. **Reusability**: Abstract interfaces can be implemented in multiple ways
5. **Maintainability**: Easier to modify and extend systems

---

## 3. INHERITANCE

### What is Inheritance?
Inheritance is a mechanism where a class (child/subclass) can acquire properties and methods from another class (parent/superclass). It promotes code reusability and establishes an "is-a" relationship between classes. The child class can extend or override the parent's functionality.

### Key Concepts:
- **Code Reusability**: Inherit common properties and methods
- **IS-A Relationship**: Child class is a type of parent class
- **Method Overriding**: Child can provide its own implementation
- **Hierarchical Structure**: Classes can be organized in levels
- **Extends Keyword**: Used to create inheritance in JavaScript

### Implementation in JavaScript:

#### Basic Inheritance with ES6 Classes
```javascript
// Example 1: Animal Hierarchy
class Animal {
    constructor(name, species) {
        this.name = name;
        this.species = species;
        this.#isAlive = true;
    }
    
    #isAlive;
    
    // Method inherited by all subclasses
    eat(food) {
        return `${this.name} is eating ${food}`;
    }
    
    // Method inherited by all subclasses
    sleep() {
        return `${this.name} is sleeping`;
    }
    
    // Method that can be overridden
    makeSound() {
        return `${this.name} makes a sound`;
    }
    
    // Getter method
    getInfo() {
        return `Name: ${this.name}, Species: ${this.species}`;
    }
}

// Child class - Dog inherits from Animal
class Dog extends Animal {
    constructor(name, breed) {
        super(name, 'Canine'); // Call parent constructor
        this.breed = breed;
        this.#loyaltyLevel = 10;
    }
    
    #loyaltyLevel;
    
    // Override parent method
    makeSound() {
        return `${this.name} barks: Woof! Woof!`;
    }
    
    // Additional method specific to Dog
    fetch(item) {
        return `${this.name} fetches the ${item}`;
    }
    
    // Additional method specific to Dog
    wagTail() {
        return `${this.name} wags its tail happily`;
    }
    
    // Override and extend parent method
    getInfo() {
        return `${super.getInfo()}, Breed: ${this.breed}`;
    }
}

// Child class - Cat inherits from Animal
class Cat extends Animal {
    constructor(name, breed) {
        super(name, 'Feline');
        this.breed = breed;
        this.#independenceLevel = 10;
    }
    
    #independenceLevel;
    
    // Override parent method
    makeSound() {
        return `${this.name} meows: Meow! Meow!`;
    }
    
    // Additional method specific to Cat
    scratch() {
        return `${this.name} scratches the furniture`;
    }
    
    // Additional method specific to Cat
    purr() {
        return `${this.name} purrs contentedly`;
    }
    
    // Override and extend parent method
    getInfo() {
        return `${super.getInfo()}, Breed: ${this.breed}`;
    }
}

// Usage
const dog = new Dog('Buddy', 'Golden Retriever');
console.log(dog.eat('bone'));        // Buddy is eating bone (inherited)
console.log(dog.makeSound());        // Buddy barks: Woof! Woof! (overridden)
console.log(dog.fetch('ball'));       // Buddy fetches the ball (specific to Dog)
console.log(dog.getInfo());          // Name: Buddy, Species: Canine, Breed: Golden Retriever

const cat = new Cat('Whiskers', 'Persian');
console.log(cat.eat('fish'));        // Whiskers is eating fish (inherited)
console.log(cat.makeSound());        // Whiskers meows: Meow! Meow! (overridden)
console.log(cat.purr());             // Whiskers purrs contentedly (specific to Cat)
```

#### Multi-level Inheritance
```javascript
// Example 2: Employee Management System
class Person {
    constructor(name, age, email) {
        this.name = name;
        this.age = age;
        this.email = email;
    }
    
    getPersonalInfo() {
        return `Name: ${this.name}, Age: ${this.age}, Email: ${this.email}`;
    }
    
    introduce() {
        return `Hi, I'm ${this.name}`;
    }
}

// First level inheritance
class Employee extends Person {
    constructor(name, age, email, employeeId, department) {
        super(name, age, email);
        this.employeeId = employeeId;
        this.department = department;
        this.#salary = 0;
    }
    
    #salary;
    
    setSalary(amount) {
        this.#salary = amount;
        return `Salary set to ${amount}`;
    }
    
    getSalary() {
        return this.#salary;
    }
    
    work() {
        return `${this.name} is working in ${this.department} department`;
    }
    
    getEmployeeInfo() {
        return `${super.getPersonalInfo()}, ID: ${this.employeeId}, Dept: ${this.department}`;
    }
    
    introduce() {
        return `${super.introduce()}, and I work in ${this.department}`;
    }
}

// Second level inheritance - Manager extends Employee
class Manager extends Employee {
    constructor(name, age, email, employeeId, department, teamSize) {
        super(name, age, email, employeeId, department);
        this.teamSize = teamSize;
        this.#managedEmployees = [];
    }
    
    #managedEmployees;
    
    addTeamMember(employee) {
        if (employee instanceof Employee && !(employee instanceof Manager)) {
            this.#managedEmployees.push(employee);
            return `${employee.name} added to team`;
        }
        return 'Invalid team member';
    }
    
    getTeamMembers() {
        return this.#managedEmployees.map(emp => emp.name);
    }
    
    conductMeeting() {
        return `${this.name} is conducting a meeting with ${this.teamSize} team members`;
    }
    
    // Override work method
    work() {
        return `${this.name} is managing the ${this.department} department with ${this.teamSize} team members`;
    }
    
    introduce() {
        return `${super.introduce()}, and I'm a Manager managing ${this.teamSize} people`;
    }
}

// Second level inheritance - Developer extends Employee
class Developer extends Employee {
    constructor(name, age, email, employeeId, department, programmingLanguage) {
        super(name, age, email, employeeId, department);
        this.programmingLanguage = programmingLanguage;
        this.#projectsCompleted = 0;
    }
    
    #projectsCompleted;
    
    writeCode() {
        return `${this.name} is writing code in ${this.programmingLanguage}`;
    }
    
    completeProject() {
        this.#projectsCompleted++;
        return `${this.name} completed project #${this.#projectsCompleted}`;
    }
    
    getProjectsCount() {
        return this.#projectsCompleted;
    }
    
    // Override work method
    work() {
        return `${this.name} is developing software using ${this.programmingLanguage}`;
    }
    
    introduce() {
        return `${super.introduce()}, and I'm a Developer specializing in ${this.programmingLanguage}`;
    }
}

// Usage
const manager = new Manager('Alice', 35, 'alice@company.com', 'EMP001', 'Engineering', 5);
manager.setSalary(120000);
console.log(manager.work());              // Alice is managing the Engineering department with 5 team members
console.log(manager.conductMeeting());    // Alice is conducting a meeting with 5 team members
console.log(manager.introduce());         // Hi, I'm Alice, and I work in Engineering, and I'm a Manager managing 5 people

const developer = new Developer('Bob', 28, 'bob@company.com', 'EMP002', 'Engineering', 'JavaScript');
developer.setSalary(95000);
console.log(developer.writeCode());        // Bob is writing code in JavaScript
console.log(developer.completeProject());  // Bob completed project #1
console.log(developer.work());             // Bob is developing software using JavaScript
console.log(developer.introduce());        // Hi, I'm Bob, and I work in Engineering, and I'm a Developer specializing in JavaScript

// Manager can add developer to team
manager.addTeamMember(developer);
console.log(manager.getTeamMembers());     // ['Bob']
```

#### Prototype-based Inheritance (Traditional JavaScript)
```javascript
// Example 3: Shape Hierarchy using Prototypes
function Shape(color) {
    this.color = color;
}

Shape.prototype.getColor = function() {
    return this.color;
};

Shape.prototype.getArea = function() {
    throw new Error('getArea() must be implemented by subclass');
};

Shape.prototype.getPerimeter = function() {
    throw new Error('getPerimeter() must be implemented by subclass');
};

// Rectangle inherits from Shape
function Rectangle(color, width, height) {
    Shape.call(this, color); // Call parent constructor
    this.width = width;
    this.height = height;
}

// Set up inheritance
Rectangle.prototype = Object.create(Shape.prototype);
Rectangle.prototype.constructor = Rectangle;

Rectangle.prototype.getArea = function() {
    return this.width * this.height;
};

Rectangle.prototype.getPerimeter = function() {
    return 2 * (this.width + this.height);
};

Rectangle.prototype.getInfo = function() {
    return `Rectangle: ${this.color}, ${this.width}x${this.height}, Area: ${this.getArea()}`;
};

// Circle inherits from Shape
function Circle(color, radius) {
    Shape.call(this, color);
    this.radius = radius;
}

Circle.prototype = Object.create(Shape.prototype);
Circle.prototype.constructor = Circle;

Circle.prototype.getArea = function() {
    return Math.PI * this.radius * this.radius;
};

Circle.prototype.getPerimeter = function() {
    return 2 * Math.PI * this.radius;
};

Circle.prototype.getInfo = function() {
    return `Circle: ${this.color}, Radius: ${this.radius}, Area: ${this.getArea().toFixed(2)}`;
};

// Usage
const rect = new Rectangle('red', 10, 5);
console.log(rect.getColor());      // red (inherited)
console.log(rect.getArea());       // 50
console.log(rect.getPerimeter());  // 30
console.log(rect.getInfo());       // Rectangle: red, 10x5, Area: 50

const circle = new Circle('blue', 7);
console.log(circle.getColor());    // blue (inherited)
console.log(circle.getArea());     // ~153.94
console.log(circle.getPerimeter()); // ~43.98
console.log(circle.getInfo());     // Circle: blue, Radius: 7, Area: 153.94
```

#### Inheritance with ES6 Classes and Method Overriding
```javascript
// Example 4: Banking System with Inheritance
class BankAccount {
    constructor(accountNumber, accountHolder, initialBalance = 0) {
        this.accountNumber = accountNumber;
        this.accountHolder = accountHolder;
        this.#balance = initialBalance;
        this.#transactionHistory = [];
    }
    
    #balance;
    #transactionHistory;
    
    deposit(amount) {
        if (amount > 0) {
            this.#balance += amount;
            this.#logTransaction('Deposit', amount);
            return `Deposited ${amount}. Balance: ${this.#balance}`;
        }
        return 'Invalid deposit amount';
    }
    
    withdraw(amount) {
        if (amount > 0 && amount <= this.#balance) {
            this.#balance -= amount;
            this.#logTransaction('Withdrawal', amount);
            return `Withdrawn ${amount}. Balance: ${this.#balance}`;
        }
        return 'Invalid withdrawal amount or insufficient funds';
    }
    
    #logTransaction(type, amount) {
        this.#transactionHistory.push({
            type,
            amount,
            date: new Date(),
            balance: this.#balance
        });
    }
    
    getBalance() {
        return this.#balance;
    }
    
    getTransactionHistory() {
        return this.#transactionHistory;
    }
    
    // Method to be overridden in child classes
    calculateInterest() {
        return 0; // Base class has no interest
    }
    
    getAccountInfo() {
        return `Account: ${this.accountNumber}, Holder: ${this.accountHolder}, Balance: ${this.#balance}`;
    }
}

// Savings Account inherits from BankAccount
class SavingsAccount extends BankAccount {
    constructor(accountNumber, accountHolder, initialBalance, interestRate = 0.02) {
        super(accountNumber, accountHolder, initialBalance);
        this.interestRate = interestRate;
    }
    
    // Override calculateInterest
    calculateInterest() {
        return this.getBalance() * this.interestRate;
    }
    
    // Override withdraw to add minimum balance requirement
    withdraw(amount) {
        const minBalance = 500;
        if (this.getBalance() - amount >= minBalance) {
            return super.withdraw(amount);
        }
        return `Cannot withdraw. Must maintain minimum balance of ${minBalance}`;
    }
    
    addInterest() {
        const interest = this.calculateInterest();
        return this.deposit(interest);
    }
    
    getAccountInfo() {
        return `${super.getAccountInfo()}, Type: Savings, Interest Rate: ${this.interestRate * 100}%`;
    }
}

// Checking Account inherits from BankAccount
class CheckingAccount extends BankAccount {
    constructor(accountNumber, accountHolder, initialBalance, overdraftLimit = 500) {
        super(accountNumber, accountHolder, initialBalance);
        this.overdraftLimit = overdraftLimit;
    }
    
    // Override withdraw to allow overdraft
    withdraw(amount) {
        const currentBalance = this.getBalance();
        if (amount > 0 && (currentBalance - amount) >= -this.overdraftLimit) {
            const newBalance = currentBalance - amount;
            // Direct balance modification for overdraft
            this.#balance = newBalance;
            this.#logTransaction('Withdrawal (with overdraft)', amount);
            return `Withdrawn ${amount}. Balance: ${newBalance} (Overdraft: ${Math.abs(Math.min(0, newBalance))})`;
        }
        return 'Invalid withdrawal or exceeds overdraft limit';
    }
    
    getAccountInfo() {
        return `${super.getAccountInfo()}, Type: Checking, Overdraft Limit: ${this.overdraftLimit}`;
    }
}

// Usage
const savings = new SavingsAccount('SAV001', 'John Doe', 1000, 0.03);
console.log(savings.getAccountInfo());
// Account: SAV001, Holder: John Doe, Balance: 1000, Type: Savings, Interest Rate: 3%

savings.deposit(500);
console.log(savings.withdraw(200));    // Withdrawn 200. Balance: 1300
console.log(savings.calculateInterest()); // 39 (1300 * 0.03)
console.log(savings.addInterest());     // Deposited 39. Balance: 1339

const checking = new CheckingAccount('CHK001', 'Jane Smith', 500, 1000);
console.log(checking.getAccountInfo());
// Account: CHK001, Holder: Jane Smith, Balance: 500, Type: Checking, Overdraft Limit: 1000

console.log(checking.withdraw(1200));  // Withdrawn 1200. Balance: -700 (Overdraft: 700)
```

### Benefits of Inheritance:
1. **Code Reusability**: Avoid duplicating common code
2. **Hierarchical Organization**: Natural representation of relationships
3. **Polymorphism**: Child classes can be used where parent is expected
4. **Extensibility**: Easy to add new subclasses
5. **Maintainability**: Changes to parent class affect all children

### Types of Inheritance:
- **Single Inheritance**: A class inherits from one parent (JavaScript supports this)
- **Multi-level Inheritance**: Class inherits from a class that inherits from another
- **Hierarchical Inheritance**: Multiple classes inherit from one parent
- **Multiple Inheritance**: A class inherits from multiple parents (Not directly supported in JavaScript, but can be achieved with mixins)

---

## 4. POLYMORPHISM

### What is Polymorphism?
Polymorphism means "many forms" - it allows objects of different classes to be treated as objects of a common parent class. The same method can behave differently for different classes. This enables one interface to represent different underlying forms.

### Key Concepts:
- **Method Overriding**: Child classes provide their own implementation of parent methods
- **Runtime Polymorphism**: JavaScript determines which method to call at runtime
- **Interface Polymorphism**: Different classes implement the same interface differently
- **Duck Typing**: "If it walks like a duck and quacks like a duck, it's a duck"
- **Flexible Design**: Code can work with objects of different types through a common interface

### Types of Polymorphism:

#### 1. Compile-time Polymorphism (Method Overloading - Not directly supported in JS)
JavaScript doesn't support traditional method overloading, but we can simulate it:

```javascript
// Example 1: Simulating Method Overloading
class Calculator {
    // JavaScript uses default parameters and variable arguments
    add(...numbers) {
        if (numbers.length === 0) return 0;
        if (numbers.length === 1 && typeof numbers[0] === 'number') {
            return numbers[0];
        }
        if (numbers.length === 2) {
            return numbers[0] + numbers[1];
        }
        return numbers.reduce((sum, num) => sum + num, 0);
    }
    
    multiply(a, b = 1) {
        if (b === 1 && Array.isArray(a)) {
            return a.reduce((prod, num) => prod * num, 1);
        }
        return a * b;
    }
}

const calc = new Calculator();
console.log(calc.add());           // 0
console.log(calc.add(5));          // 5
console.log(calc.add(5, 10));      // 15
console.log(calc.add(1, 2, 3, 4)); // 10
```

#### 2. Runtime Polymorphism (Method Overriding)
```javascript
// Example 2: Runtime Polymorphism with Method Overriding
class Shape {
    constructor(name) {
        this.name = name;
    }
    
    // Method to be overridden
    calculateArea() {
        return 0;
    }
    
    // Method to be overridden
    draw() {
        return `Drawing a ${this.name}`;
    }
    
    // Method that uses polymorphism
    displayInfo() {
        return `${this.name} - Area: ${this.calculateArea()}`;
    }
}

class Circle extends Shape {
    constructor(radius) {
        super('Circle');
        this.radius = radius;
    }
    
    // Override parent method
    calculateArea() {
        return Math.PI * this.radius * this.radius;
    }
    
    // Override parent method
    draw() {
        return `Drawing a circle with radius ${this.radius}`;
    }
}

class Rectangle extends Shape {
    constructor(width, height) {
        super('Rectangle');
        this.width = width;
        this.height = height;
    }
    
    // Override parent method
    calculateArea() {
        return this.width * this.height;
    }
    
    // Override parent method
    draw() {
        return `Drawing a rectangle ${this.width}x${this.height}`;
    }
}

class Triangle extends Shape {
    constructor(base, height) {
        super('Triangle');
        this.base = base;
        this.height = height;
    }
    
    // Override parent method
    calculateArea() {
        return 0.5 * this.base * this.height;
    }
    
    // Override parent method
    draw() {
        return `Drawing a triangle with base ${this.base} and height ${this.height}`;
    }
}

// Polymorphic behavior - same interface, different implementations
const shapes = [
    new Circle(5),
    new Rectangle(4, 6),
    new Triangle(3, 4)
];

// Same method call, different behavior based on object type
shapes.forEach(shape => {
    console.log(shape.draw());        // Different output for each shape
    console.log(shape.displayInfo()); // Uses overridden calculateArea()
});
```

#### 3. Interface Polymorphism (Duck Typing)
- Duck Typing is a type of polymorphism mostly used in dynamic languages like JavaScript and Python.

- “If it walks like a duck and quacks like a duck, then it is treated like a duck.”

- Meaning → We don’t care about the actual type of object.
- We only care whether the object has the required method or property.
```javascript
// Example 3: Duck Typing - If it has the method, it works
class Bird {
    fly() {
        return 'Flying in the sky';
    }
    
    makeSound() {
        return 'Some bird sound';
    }
}

class Airplane {
    fly() {
        return 'Flying at 30,000 feet';
    }
    
    makeSound() {
        return 'Engine roar';
    }
}

class Superhero {
    fly() {
        return 'Flying with superpowers';
    }
    
    makeSound() {
        return 'Superhero catchphrase';
    }
}

// Polymorphic function - works with any object that has fly() method
function makeItFly(flyingObject) {
    return flyingObject.fly();
}

// All these work because they have the fly() method
console.log(makeItFly(new Bird()));        // Flying in the sky
console.log(makeItFly(new Airplane()));    // Flying at 30,000 feet
console.log(makeItFly(new Superhero()));   // Flying with superpowers
```
#### 3.1 Example 2
```javascript
function processPayment(paymentMethod) {
  paymentMethod.pay();
}

class CreditCard {
  pay() {
    console.log("Paid by Credit Card");
  }
}

class UPI {
  pay() {
    console.log("Paid by UPI");
  }
}

processPayment(new CreditCard());
processPayment(new UPI());
```
### Abstract Classes
- An Abstract Class is a class that cannot be instantiated (you can't create objects from it).
- It is only meant to act as a base / blueprint for other classes.
#### Why "Abstract"?
- Because it contains incomplete methods called abstract methods
- They only have the name (signature)
- No implementation (body)
- Child classes must provide the implementation.
```javascript
abstract class Animal {
    abstract void sound(); // no body → must be implemented
}

class Dog extends Animal {
    void sound() {
        console.log("Woof!");
    }
}

const a = new Animal(); // Not allowed
const d = new Dog();    //  Allowed
d.sound();               // Woof!
```
#### 4. Polymorphism with Abstract Classes
```javascript
// Example 4: Database Connection Polymorphism
class DatabaseConnection {
    constructor(connectionString) {
        if (this.constructor === DatabaseConnection) {
            throw new Error('Cannot instantiate abstract class');
        }
        this.connectionString = connectionString;
        this.#isConnected = false;
    }
    
    #isConnected;
    
    // Abstract methods - must be implemented
    connect() {
        throw new Error('connect() must be implemented');
    }
    
    disconnect() {
        throw new Error('disconnect() must be implemented');
    }
    
    executeQuery(query) {
        throw new Error('executeQuery() must be implemented');
    }
    
    // Common method
    getConnectionStatus() {
        return this.#isConnected ? 'Connected' : 'Disconnected';
    }
    
    setConnected(status) {
        this.#isConnected = status;
    }
}

class MySQLConnection extends DatabaseConnection {
    connect() {
        console.log(`Connecting to MySQL: ${this.connectionString}`);
        this.setConnected(true);
        return 'MySQL connection established';
    }
    
    disconnect() {
        console.log('Closing MySQL connection');
        this.setConnected(false);
        return 'MySQL connection closed';
    }
    
    executeQuery(query) {
        if (!this.getConnectionStatus() === 'Connected') {
            return 'Error: Not connected to MySQL';
        }
        return `[MySQL] Executing: ${query}`;
    }
}

class MongoDBConnection extends DatabaseConnection {
    connect() {
        console.log(`Connecting to MongoDB: ${this.connectionString}`);
        this.setConnected(true);
        return 'MongoDB connection established';
    }
    
    disconnect() {
        console.log('Closing MongoDB connection');
        this.setConnected(false);
        return 'MongoDB connection closed';
    }
    
    executeQuery(query) {
        if (!this.getConnectionStatus() === 'Connected') {
            return 'Error: Not connected to MongoDB';
        }
        // MongoDB uses different syntax
        return `[MongoDB] Executing: db.${query}`;
    }
}

class PostgreSQLConnection extends DatabaseConnection {
    connect() {
        console.log(`Connecting to PostgreSQL: ${this.connectionString}`);
        this.setConnected(true);
        return 'PostgreSQL connection established';
    }
    
    disconnect() {
        console.log('Closing PostgreSQL connection');
        this.setConnected(false);
        return 'PostgreSQL connection closed';
    }
    
    executeQuery(query) {
        if (!this.getConnectionStatus() === 'Connected') {
            return 'Error: Not connected to PostgreSQL';
        }
        return `[PostgreSQL] Executing: ${query}`;
    }
}

// Polymorphic database manager
class DatabaseManager {
    #connection;
    
    setConnection(connection) {
        if (!(connection instanceof DatabaseConnection)) {
            throw new Error('Invalid database connection');
        }
        this.#connection = connection;
    }
    
    // Works with any DatabaseConnection subclass
    execute(query) {
        if (!this.#connection) {
            return 'No database connection set';
        }
        return this.#connection.executeQuery(query);
    }
}

// Usage - same interface, different implementations
const manager = new DatabaseManager();

// Use MySQL
const mysql = new MySQLConnection('mysql://localhost:3306/mydb');
mysql.connect();
manager.setConnection(mysql);
console.log(manager.execute('SELECT * FROM users')); // [MySQL] Executing: SELECT * FROM users

// Switch to MongoDB - no code change needed!
const mongo = new MongoDBConnection('mongodb://localhost:27017/mydb');
mongo.connect();
manager.setConnection(mongo);
console.log(manager.execute('users.find()')); // [MongoDB] Executing: db.users.find()
```

#### 5. Polymorphism with Strategy Pattern
```javascript
// Example 5: Payment Processing with Polymorphism
class PaymentStrategy {
    processPayment(amount) {
        throw new Error('processPayment() must be implemented');
    }
}

class CreditCardStrategy extends PaymentStrategy {
    #cardNumber;
    #cvv;
    
    constructor(cardNumber, cvv) {
        super();
        this.#cardNumber = cardNumber;
        this.#cvv = cvv;
    }
    
    processPayment(amount) {
        console.log(`Processing credit card payment of $${amount}`);
        return `Credit card payment successful. Transaction ID: CC-${Date.now()}`;
    }
}

class PayPalStrategy extends PaymentStrategy {
    #email;
    
    constructor(email) {
        super();
        this.#email = email;
    }
    
    processPayment(amount) {
        console.log(`Processing PayPal payment of $${amount} for ${this.#email}`);
        return `PayPal payment successful. Transaction ID: PP-${Date.now()}`;
    }
}

class CryptocurrencyStrategy extends PaymentStrategy {
    #walletAddress;
    
    constructor(walletAddress) {
        super();
        this.#walletAddress = walletAddress;
    }
    
    processPayment(amount) {
        console.log(`Processing cryptocurrency payment of $${amount} to ${this.#walletAddress}`);
        return `Cryptocurrency payment successful. Transaction ID: BTC-${Date.now()}`;
    }
}

// Payment processor uses polymorphism
class PaymentProcessor {
    #strategy;
    
    setPaymentStrategy(strategy) {
        if (!(strategy instanceof PaymentStrategy)) {
            throw new Error('Invalid payment strategy');
        }
        this.#strategy = strategy;
    }
    
    // Same method works with different payment strategies
    pay(amount) {
        if (!this.#strategy) {
            return 'No payment method selected';
        }
        return this.#strategy.processPayment(amount);
    }
}

// Usage
const processor = new PaymentProcessor();

// Use credit card
processor.setPaymentStrategy(new CreditCardStrategy('1234567890123456', '123'));
console.log(processor.pay(100));

// Switch to PayPal - same interface!
processor.setPaymentStrategy(new PayPalStrategy('user@example.com'));
console.log(processor.pay(50));

// Switch to cryptocurrency - same interface!
processor.setPaymentStrategy(new CryptocurrencyStrategy('1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa'));
console.log(processor.pay(200));
```

### Benefits of Polymorphism:
1. **Code Flexibility**: Same code works with different object types
2. **Extensibility**: Easy to add new types without modifying existing code
3. **Maintainability**: Changes to one class don't affect others using the same interface
4. **Code Reusability**: Write generic code that works with multiple types
5. **Runtime Behavior**: Methods are selected at runtime based on object type

### Key Points:
- **Method Overriding**: Child classes redefine parent methods
- **Super Keyword**: Can call parent method using `super.methodName()`
- **Dynamic Dispatch**: JavaScript determines which method to call at runtime
- **Duck Typing**: JavaScript focuses on what methods/properties exist, not the type
- **Interface Consistency**: Polymorphism relies on consistent method signatures

---

## REAL-WORLD EXAMPLES: COMBINING ALL FOUR PRINCIPLES

The following examples demonstrate how all four OOP principles work together in practical scenarios.

---

## Example 1: E-Commerce Product Management System

This example shows an e-commerce system managing different types of products with a complete OOP implementation.

```javascript
// ============================================
// ABSTRACTION & INHERITANCE: Base Product Class
// ============================================
class Product {
    constructor(id, name, price, category) {
        if (this.constructor === Product) {
            throw new Error('Product is an abstract class and cannot be instantiated');
        }
        
        // ENCAPSULATION: Private fields for data protection
        this.#id = id;
        this.#name = name;
        this.#price = price;
        this.#category = category;
        this.#inStock = true;
        this.#quantity = 0;
        this.#reviews = [];
    }
    
    // ENCAPSULATION: Private fields
    #id;
    #name;
    #price;
    #category;
    #inStock;
    #quantity;
    #reviews;
    
    // ENCAPSULATION: Private method
    #validatePrice(price) {
        return price > 0 && typeof price === 'number';
    }
    
    // ENCAPSULATION: Public getters (controlled access)
    getId() {
        return this.#id;
    }
    
    getName() {
        return this.#name;
    }
    
    getPrice() {
        return this.#price;
    }
    
    getCategory() {
        return this.#category;
    }
    
    getQuantity() {
        return this.#quantity;
    }
    
    // ENCAPSULATION: Public setters with validation
    setPrice(newPrice) {
        if (this.#validatePrice(newPrice)) {
            this.#price = newPrice;
            return `Price updated to $${newPrice}`;
        }
        return 'Invalid price';
    }
    
    updateQuantity(amount) {
        this.#quantity = Math.max(0, this.#quantity + amount);
        this.#inStock = this.#quantity > 0;
        return `Quantity updated to ${this.#quantity}`;
    }
    
    // ABSTRACTION: Abstract method - implementation hidden from users
    calculateShipping() {
        throw new Error('calculateShipping() must be implemented by subclass');
    }
    
    // ABSTRACTION: Abstract method
    getProductDetails() {
        throw new Error('getProductDetails() must be implemented by subclass');
    }
    
    // Common method (INHERITANCE)
    addReview(review) {
        this.#reviews.push({
            ...review,
            date: new Date()
        });
        return 'Review added successfully';
    }
    
    getReviews() {
        return this.#reviews;
    }
    
    getAverageRating() {
        if (this.#reviews.length === 0) return 0;
        const sum = this.#reviews.reduce((acc, review) => acc + review.rating, 0);
        return (sum / this.#reviews.length).toFixed(1);
    }
    
    // Common method (INHERITANCE)
    isAvailable() {
        return this.#inStock && this.#quantity > 0;
    }
}

// ============================================
// INHERITANCE: Physical Product extends Product
// ============================================
class PhysicalProduct extends Product {
    constructor(id, name, price, category, weight, dimensions) {
        super(id, name, price, category);
        
        // ENCAPSULATION: Private fields
        this.#weight = weight;
        this.#dimensions = dimensions;
    }
    
    #weight;
    #dimensions;
    
    // POLYMORPHISM: Override abstract method
    calculateShipping() {
        // ABSTRACTION: Complex shipping calculation hidden
        const baseShipping = 5;
        const weightCost = this.#weight * 0.5;
        const dimensionCost = (this.#dimensions.length * 
                            this.#dimensions.width * 
                            this.#dimensions.height) * 0.01;
        return baseShipping + weightCost + dimensionCost;
    }
    
    // POLYMORPHISM: Override abstract method
    getProductDetails() {
        return {
            id: this.getId(),
            name: this.getName(),
            price: this.getPrice(),
            category: this.getCategory(),
            weight: this.#weight,
            dimensions: this.#dimensions,
            inStock: this.isAvailable(),
            quantity: this.getQuantity(),
            shippingCost: this.calculateShipping(),
            averageRating: this.getAverageRating()
        };
    }
    
    // Specific method for physical products
    getShippingInfo() {
        return `Weight: ${this.#weight}kg, Dimensions: ${this.#dimensions.length}x${this.#dimensions.width}x${this.#dimensions.height}cm`;
    }
}

// ============================================
// INHERITANCE: Digital Product extends Product
// ============================================
class DigitalProduct extends Product {
    constructor(id, name, price, category, fileSize, downloadLink) {
        super(id, name, price, category);
        
        // ENCAPSULATION: Private fields
        this.#fileSize = fileSize;
        this.#downloadLink = downloadLink;
        this.#downloadCount = 0;
    }
    
    #fileSize;
    #downloadLink;
    #downloadCount;
    
    // POLYMORPHISM: Override abstract method
    calculateShipping() {
        return 0; // Digital products have no shipping
    }
    
    // POLYMORPHISM: Override abstract method
    getProductDetails() {
        return {
            id: this.getId(),
            name: this.getName(),
            price: this.getPrice(),
            category: this.getCategory(),
            fileSize: this.#fileSize,
            downloadLink: this.#downloadLink,
            downloadCount: this.#downloadCount,
            shippingCost: 0,
            averageRating: this.getAverageRating()
        };
    }
    
    // Specific method for digital products
    download() {
        this.#downloadCount++;
        return {
            success: true,
            message: `Download started for ${this.getName()}`,
            link: this.#downloadLink,
            fileSize: this.#fileSize
        };
    }
    
    getDownloadCount() {
        return this.#downloadCount;
    }
}

// ============================================
// INHERITANCE: Subscription Product extends Product
// ============================================
class SubscriptionProduct extends Product {
    constructor(id, name, price, category, billingCycle, duration) {
        super(id, name, price, category);
        
        // ENCAPSULATION: Private fields
        this.#billingCycle = billingCycle; // 'monthly', 'yearly'
        this.#duration = duration; // in months
        this.#activeSubscriptions = 0;
    }
    
    #billingCycle;
    #duration;
    #activeSubscriptions;
    
    // POLYMORPHISM: Override abstract method
    calculateShipping() {
        return 0; // Subscriptions have no shipping
    }
    
    // POLYMORPHISM: Override abstract method
    getProductDetails() {
        const totalPrice = this.getPrice() * this.#duration;
        return {
            id: this.getId(),
            name: this.getName(),
            price: this.getPrice(),
            category: this.getCategory(),
            billingCycle: this.#billingCycle,
            duration: this.#duration,
            totalPrice: totalPrice,
            activeSubscriptions: this.#activeSubscriptions,
            shippingCost: 0,
            averageRating: this.getAverageRating()
        };
    }
    
    // Specific method for subscriptions
    subscribe() {
        this.#activeSubscriptions++;
        return {
            success: true,
            message: `Subscribed to ${this.getName()} for ${this.#duration} months`,
            nextBilling: this.#calculateNextBilling()
        };
    }
    
    #calculateNextBilling() {
        const nextDate = new Date();
        if (this.#billingCycle === 'monthly') {
            nextDate.setMonth(nextDate.getMonth() + 1);
        } else {
            nextDate.setFullYear(nextDate.getFullYear() + 1);
        }
        return nextDate;
    }
}

// ============================================
// POLYMORPHISM: Product Manager (Works with all Product types)
// ============================================
class ProductManager {
    #products;
    
    constructor() {
        // ENCAPSULATION: Private storage
        this.#products = [];
    }
    
    // POLYMORPHISM: Works with any Product subclass
    addProduct(product) {
        if (!(product instanceof Product)) {
            throw new Error('Invalid product type');
        }
        this.#products.push(product);
        return `Product ${product.getName()} added successfully`;
    }
    
    // POLYMORPHISM: Process any product type
    processOrder(productId, quantity) {
        const product = this.#products.find(p => p.getId() === productId);
        
        if (!product) {
            return { success: false, error: 'Product not found' };
        }
        
        if (!product.isAvailable() || product.getQuantity() < quantity) {
            return { success: false, error: 'Insufficient stock' };
        }
        
        // ABSTRACTION: Calculate total cost (hides complexity)
        const subtotal = product.getPrice() * quantity;
        const shipping = product.calculateShipping(); // POLYMORPHISM: Different for each type
        const total = subtotal + shipping;
        
        product.updateQuantity(-quantity);
        
        return {
            success: true,
            productName: product.getName(),
            quantity,
            subtotal,
            shipping,
            total,
            details: product.getProductDetails() // POLYMORPHISM: Different details for each type
        };
    }
    
    // POLYMORPHISM: Get all products regardless of type
    getAllProducts() {
        return this.#products.map(product => product.getProductDetails());
    }
    
    // POLYMORPHISM: Filter by type but work with base class
    getProductsByCategory(category) {
        return this.#products
            .filter(product => product.getCategory() === category)
            .map(product => product.getProductDetails());
    }
}

// ============================================
// USAGE EXAMPLE
// ============================================
const manager = new ProductManager();

// Create different product types (POLYMORPHISM)
const laptop = new PhysicalProduct(
    'PHY001',
    'Gaming Laptop',
    1299.99,
    'Electronics',
    2.5,
    { length: 35, width: 25, height: 2 }
);

const ebook = new DigitalProduct(
    'DIG001',
    'JavaScript Guide',
    19.99,
    'Books',
    '5MB',
    'https://example.com/download/js-guide.pdf'
);

const premium = new SubscriptionProduct(
    'SUB001',
    'Premium Membership',
    9.99,
    'Services',
    'monthly',
    12
);

// Add products (POLYMORPHISM - all treated as Product)
manager.addProduct(laptop);
manager.addProduct(ebook);
manager.addProduct(premium);

// Update quantities
laptop.updateQuantity(10);
ebook.updateQuantity(1000); // Digital products have unlimited "quantity"
premium.updateQuantity(1);

// Add reviews (INHERITANCE - common method)
laptop.addReview({ rating: 5, comment: 'Great laptop!' });
ebook.addReview({ rating: 4, comment: 'Very helpful guide' });

// Process orders (POLYMORPHISM - different behavior for each type)
console.log(manager.processOrder('PHY001', 1));
// Different shipping calculation for physical product

console.log(manager.processOrder('DIG001', 1));
// No shipping for digital product

console.log(ebook.download()); // Digital-specific method

console.log(premium.subscribe()); // Subscription-specific method

// Get all products (POLYMORPHISM - unified interface)
console.log(manager.getAllProducts());
```

---

## Example 2: Vehicle Rental System

This example demonstrates a vehicle rental system with different vehicle types, showcasing all four principles.

```javascript
// ============================================
// ABSTRACTION & INHERITANCE: Base Vehicle Class
// ============================================
class Vehicle {
    constructor(licensePlate, make, model, year) {
        if (this.constructor === Vehicle) {
            throw new Error('Vehicle is an abstract class');
        }
        
        // ENCAPSULATION: Private fields
        this.#licensePlate = licensePlate;
        this.#make = make;
        this.#model = model;
        this.#year = year;
        this.#isRented = false;
        this.#mileage = 0;
        this.#maintenanceHistory = [];
    }
    
    // ENCAPSULATION: Private fields
    #licensePlate;
    #make;
    #model;
    #year;
    #isRented;
    #mileage;
    #maintenanceHistory;
    
    // ENCAPSULATION: Public getters
    getLicensePlate() {
        return this.#licensePlate;
    }
    
    getMake() {
        return this.#make;
    }
    
    getModel() {
        return this.#make + ' ' + this.#model;
    }
    
    getYear() {
        return this.#year;
    }
    
    getMileage() {
        return this.#mileage;
    }
    
    isAvailable() {
        return !this.#isRented;
    }
    
    // ENCAPSULATION: Private method
    #logMaintenance(service) {
        this.#maintenanceHistory.push({
            service,
            date: new Date(),
            mileage: this.#mileage
        });
    }
    
    // ABSTRACTION: Abstract methods
    calculateRentalCost(days) {
        throw new Error('calculateRentalCost() must be implemented');
    }
    
    getVehicleInfo() {
        throw new Error('getVehicleInfo() must be implemented');
    }
    
    // Common method (INHERITANCE)
    rent() {
        if (this.#isRented) {
            return { success: false, error: 'Vehicle already rented' };
        }
        this.#isRented = true;
        return { success: true, message: `${this.getModel()} is now rented` };
    }
    
    returnVehicle(newMileage) {
        if (!this.#isRented) {
            return { success: false, error: 'Vehicle not rented' };
        }
        
        if (newMileage < this.#mileage) {
            return { success: false, error: 'Invalid mileage' };
        }
        
        const milesDriven = newMileage - this.#mileage;
        this.#mileage = newMileage;
        this.#isRented = false;
        
        return {
            success: true,
            message: `${this.getModel()} returned`,
            milesDriven
        };
    }
    
    performMaintenance(service) {
        this.#logMaintenance(service);
        return `Maintenance performed: ${service}`;
    }
    
    getMaintenanceHistory() {
        return this.#maintenanceHistory;
    }
}

// ============================================
// INHERITANCE: Car extends Vehicle
// ============================================
class Car extends Vehicle {
    constructor(licensePlate, make, model, year, seats, fuelType) {
        super(licensePlate, make, model, year);
        
        // ENCAPSULATION: Private fields
        this.#seats = seats;
        this.#fuelType = fuelType;
        this.#fuelLevel = 100; // percentage
    }
    
    #seats;
    #fuelType;
    #fuelLevel;
    
    // POLYMORPHISM: Override abstract method
    calculateRentalCost(days) {
        const baseRate = 50; // per day
        const fuelSurcharge = this.#fuelType === 'Electric' ? 0 : 5;
        return (baseRate + fuelSurcharge) * days;
    }
    
    // POLYMORPHISM: Override abstract method
    getVehicleInfo() {
        return {
            licensePlate: this.getLicensePlate(),
            make: this.getMake(),
            model: this.getModel(),
            year: this.getYear(),
            type: 'Car',
            seats: this.#seats,
            fuelType: this.#fuelType,
            fuelLevel: this.#fuelLevel,
            mileage: this.getMileage(),
            isAvailable: this.isAvailable()
        };
    }
    
    // Car-specific method
    refuel(percentage) {
        this.#fuelLevel = Math.min(100, this.#fuelLevel + percentage);
        return `Fuel level: ${this.#fuelLevel}%`;
    }
    
    getFuelLevel() {
        return this.#fuelLevel;
    }
}

// ============================================
// INHERITANCE: Truck extends Vehicle
// ============================================
class Truck extends Vehicle {
    constructor(licensePlate, make, model, year, cargoCapacity, hasHydraulics) {
        super(licensePlate, make, model, year);
        
        // ENCAPSULATION: Private fields
        this.#cargoCapacity = cargoCapacity;
        this.#hasHydraulics = hasHydraulics;
    }
    
    #cargoCapacity;
    #hasHydraulics;
    
    // POLYMORPHISM: Override abstract method
    calculateRentalCost(days) {
        const baseRate = 150; // per day
        const hydraulicsFee = this.#hasHydraulics ? 25 : 0;
        return (baseRate + hydraulicsFee) * days;
    }
    
    // POLYMORPHISM: Override abstract method
    getVehicleInfo() {
        return {
            licensePlate: this.getLicensePlate(),
            make: this.getMake(),
            model: this.getModel(),
            year: this.getYear(),
            type: 'Truck',
            cargoCapacity: this.#cargoCapacity,
            hasHydraulics: this.#hasHydraulics,
            mileage: this.getMileage(),
            isAvailable: this.isAvailable()
        };
    }
    
    // Truck-specific method
    loadCargo(weight) {
        if (weight > this.#cargoCapacity) {
            return { success: false, error: 'Cargo exceeds capacity' };
        }
        return { success: true, message: `Loaded ${weight}kg of cargo` };
    }
}

// ============================================
// INHERITANCE: Motorcycle extends Vehicle
// ============================================
class Motorcycle extends Vehicle {
    constructor(licensePlate, make, model, year, engineSize, hasSidecar) {
        super(licensePlate, make, model, year);
        
        // ENCAPSULATION: Private fields
        this.#engineSize = engineSize;
        this.#hasSidecar = hasSidecar;
    }
    
    #engineSize;
    #hasSidecar;
    
    // POLYMORPHISM: Override abstract method
    calculateRentalCost(days) {
        const baseRate = 30; // per day
        const sidecarFee = this.#hasSidecar ? 10 : 0;
        return (baseRate + sidecarFee) * days;
    }
    
    // POLYMORPHISM: Override abstract method
    getVehicleInfo() {
        return {
            licensePlate: this.getLicensePlate(),
            make: this.getMake(),
            model: this.getModel(),
            year: this.getYear(),
            type: 'Motorcycle',
            engineSize: this.#engineSize,
            hasSidecar: this.#hasSidecar,
            mileage: this.getMileage(),
            isAvailable: this.isAvailable()
        };
    }
    
    // Motorcycle-specific method
    getHelmetSize() {
        return 'Standard size available';
    }
}

// ============================================
// POLYMORPHISM: Rental Agency (Works with all Vehicle types)
// ============================================
class RentalAgency {
    #vehicles;
    #rentals;
    
    constructor() {
        // ENCAPSULATION: Private storage
        this.#vehicles = [];
        this.#rentals = [];
    }
    
    // POLYMORPHISM: Add any vehicle type
    addVehicle(vehicle) {
        if (!(vehicle instanceof Vehicle)) {
            throw new Error('Invalid vehicle type');
        }
        this.#vehicles.push(vehicle);
        return `Vehicle ${vehicle.getModel()} added to fleet`;
    }
    
    // POLYMORPHISM: Rent any vehicle type
    rentVehicle(licensePlate, customerName, days) {
        const vehicle = this.#vehicles.find(v => v.getLicensePlate() === licensePlate);
        
        if (!vehicle) {
            return { success: false, error: 'Vehicle not found' };
        }
        
        const rentResult = vehicle.rent();
        if (!rentResult.success) {
            return rentResult;
        }
        
        // ABSTRACTION: Calculate cost (hides complex calculation)
        const dailyRate = vehicle.calculateRentalCost(1); // POLYMORPHISM: Different rates
        const totalCost = vehicle.calculateRentalCost(days);
        
        const rental = {
            id: `RENT-${Date.now()}`,
            vehicle: vehicle.getModel(),
            licensePlate: vehicle.getLicensePlate(),
            customerName,
            days,
            dailyRate,
            totalCost,
            startDate: new Date(),
            endDate: new Date(Date.now() + days * 24 * 60 * 60 * 1000)
        };
        
        this.#rentals.push(rental);
        
        return {
            success: true,
            rental,
            vehicleInfo: vehicle.getVehicleInfo() // POLYMORPHISM: Different info for each type
        };
    }
    
    // POLYMORPHISM: Return any vehicle type
    returnVehicle(licensePlate, newMileage) {
        const vehicle = this.#vehicles.find(v => v.getLicensePlate() === licensePlate);
        
        if (!vehicle) {
            return { success: false, error: 'Vehicle not found' };
        }
        
        const returnResult = vehicle.returnVehicle(newMileage);
        if (!returnResult.success) {
            return returnResult;
        }
        
        // Find and close rental
        const rental = this.#rentals.find(r => 
            r.licensePlate === licensePlate && 
            !r.returned
        );
        
        if (rental) {
            rental.returned = true;
            rental.returnDate = new Date();
            rental.milesDriven = returnResult.milesDriven;
        }
        
        return {
            success: true,
            message: returnResult.message,
            rental
        };
    }
    
    // POLYMORPHISM: Get all available vehicles
    getAvailableVehicles() {
        return this.#vehicles
            .filter(v => v.isAvailable())
            .map(v => v.getVehicleInfo());
    }
    
    // POLYMORPHISM: Get vehicles by type
    getVehiclesByType(type) {
        return this.#vehicles
            .filter(v => {
                const info = v.getVehicleInfo();
                return info.type.toLowerCase() === type.toLowerCase();
            })
            .map(v => v.getVehicleInfo());
    }
}

// ============================================
// USAGE EXAMPLE
// ============================================
const agency = new RentalAgency();

// Add different vehicle types (POLYMORPHISM)
const sedan = new Car('ABC-123', 'Toyota', 'Camry', 2023, 5, 'Gasoline');
const suv = new Car('XYZ-789', 'Tesla', 'Model Y', 2023, 7, 'Electric');
const deliveryTruck = new Truck('TRK-001', 'Ford', 'F-150', 2022, 2000, true);
const sportBike = new Motorcycle('MOT-456', 'Yamaha', 'R1', 2023, '1000cc', false);

// Add to agency (POLYMORPHISM - all treated as Vehicle)
agency.addVehicle(sedan);
agency.addVehicle(suv);
agency.addVehicle(deliveryTruck);
agency.addVehicle(sportBike);

// Rent different vehicles (POLYMORPHISM - different costs)
console.log(agency.rentVehicle('ABC-123', 'John Doe', 3));
// Car rental cost

console.log(agency.rentVehicle('TRK-001', 'Construction Co', 7));
// Truck rental cost (higher)

console.log(agency.rentVehicle('MOT-456', 'Jane Smith', 2));
// Motorcycle rental cost (lower)

// Get available vehicles (POLYMORPHISM - unified interface)
console.log(agency.getAvailableVehicles());

// Use vehicle-specific methods
sedan.refuel(50);
deliveryTruck.loadCargo(1500);
```

---

## Example 3: Media Player System with Different Media Types

This example shows a media player that handles different types of media files using all four OOP principles.

```javascript
// ============================================
// ABSTRACTION & INHERITANCE: Base Media Class
// ============================================
class Media {
    constructor(title, artist, duration, filePath) {
        if (this.constructor === Media) {
            throw new Error('Media is an abstract class');
        }
        
        // ENCAPSULATION: Private fields
        this.#title = title;
        this.#artist = artist;
        this.#duration = duration; // in seconds
        this.#filePath = filePath;
        this.#playCount = 0;
        this.#lastPlayed = null;
        this.#isPlaying = false;
        this.#currentPosition = 0;
    }
    
    // ENCAPSULATION: Private fields
    #title;
    #artist;
    #duration;
    #filePath;
    #playCount;
    #lastPlayed;
    #isPlaying;
    #currentPosition;
    
    // ENCAPSULATION: Public getters
    getTitle() {
        return this.#title;
    }
    
    getArtist() {
        return this.#artist;
    }
    
    getDuration() {
        return this.#duration;
    }
    
    getPlayCount() {
        return this.#playCount;
    }
    
    getLastPlayed() {
        return this.#lastPlayed;
    }
    
    isCurrentlyPlaying() {
        return this.#isPlaying;
    }
    
    getCurrentPosition() {
        return this.#currentPosition;
    }
    
    // ENCAPSULATION: Private method
    #updatePlayStatistics() {
        this.#playCount++;
        this.#lastPlayed = new Date();
    }
    
    // ABSTRACTION: Abstract methods
    play() {
        throw new Error('play() must be implemented by subclass');
    }
    
    pause() {
        throw new Error('pause() must be implemented by subclass');
    }
    
    stop() {
        throw new Error('stop() must be implemented by subclass');
    }
    
    getMediaInfo() {
        throw new Error('getMediaInfo() must be implemented by subclass');
    }
    
    // Common method (INHERITANCE)
    getFormattedDuration() {
        const minutes = Math.floor(this.#duration / 60);
        const seconds = this.#duration % 60;
        return `${minutes}:${seconds.toString().padStart(2, '0')}`;
    }
    
    // Common method (INHERITANCE)
    getProgress() {
        if (this.#duration === 0) return 0;
        return (this.#currentPosition / this.#duration) * 100;
    }
}

// ============================================
// INHERITANCE: AudioFile extends Media
// ============================================
class AudioFile extends Media {
    constructor(title, artist, duration, filePath, format, bitrate) {
        super(title, artist, duration, filePath);
        
        // ENCAPSULATION: Private fields
        this.#format = format; // 'mp3', 'flac', 'wav', etc.
        this.#bitrate = bitrate; // kbps
        this.#volume = 50; // 0-100
    }
    
    #format;
    #bitrate;
    #volume;
    
    // POLYMORPHISM: Override abstract method
    play() {
        this.#isPlaying = true;
        this.#updatePlayStatistics();
        return {
            success: true,
            message: `Playing audio: ${this.getTitle()} by ${this.getArtist()}`,
            format: this.#format,
            bitrate: `${this.#bitrate}kbps`,
            volume: `${this.#volume}%`
        };
    }
    
    pause() {
        this.#isPlaying = false;
        return `Paused: ${this.getTitle()}`;
    }
    
    stop() {
        this.#isPlaying = false;
        this.#currentPosition = 0;
        return `Stopped: ${this.getTitle()}`;
    }
    
    // POLYMORPHISM: Override abstract method
    getMediaInfo() {
        return {
            title: this.getTitle(),
            artist: this.getArtist(),
            type: 'Audio',
            format: this.#format,
            bitrate: `${this.#bitrate}kbps`,
            duration: this.getFormattedDuration(),
            playCount: this.getPlayCount(),
            lastPlayed: this.getLastPlayed()
        };
    }
    
    // Audio-specific method
    setVolume(level) {
        this.#volume = Math.max(0, Math.min(100, level));
        return `Volume set to ${this.#volume}%`;
    }
    
    getVolume() {
        return this.#volume;
    }
}

// ============================================
// INHERITANCE: VideoFile extends Media
// ============================================
class VideoFile extends Media {
    constructor(title, artist, duration, filePath, resolution, codec) {
        super(title, artist, duration, filePath);
        
        // ENCAPSULATION: Private fields
        this.#resolution = resolution; // '1080p', '4K', etc.
        this.#codec = codec; // 'h264', 'h265', etc.
        this.#subtitlesEnabled = false;
        this.#quality = 'auto';
    }
    
    #resolution;
    #codec;
    #subtitlesEnabled;
    #quality;
    
    // POLYMORPHISM: Override abstract method
    play() {
        this.#isPlaying = true;
        this.#updatePlayStatistics();
        return {
            success: true,
            message: `Playing video: ${this.getTitle()} by ${this.getArtist()}`,
            resolution: this.#resolution,
            codec: this.#codec,
            quality: this.#quality,
            subtitles: this.#subtitlesEnabled ? 'Enabled' : 'Disabled'
        };
    }
    
    pause() {
        this.#isPlaying = false;
        return `Paused: ${this.getTitle()}`;
    }
    
    stop() {
        this.#isPlaying = false;
        this.#currentPosition = 0;
        return `Stopped: ${this.getTitle()}`;
    }
    
    // POLYMORPHISM: Override abstract method
    getMediaInfo() {
        return {
            title: this.getTitle(),
            artist: this.getArtist(),
            type: 'Video',
            resolution: this.#resolution,
            codec: this.#codec,
            duration: this.getFormattedDuration(),
            playCount: this.getPlayCount(),
            lastPlayed: this.getLastPlayed()
        };
    }
    
    // Video-specific methods
    toggleSubtitles() {
        this.#subtitlesEnabled = !this.#subtitlesEnabled;
        return `Subtitles ${this.#subtitlesEnabled ? 'enabled' : 'disabled'}`;
    }
    
    setQuality(quality) {
        const validQualities = ['auto', 'low', 'medium', 'high', '4K'];
        if (validQualities.includes(quality)) {
            this.#quality = quality;
            return `Quality set to ${quality}`;
        }
        return 'Invalid quality setting';
    }
}

// ============================================
// INHERITANCE: Podcast extends Media
// ============================================
class Podcast extends Media {
    constructor(title, artist, duration, filePath, episodeNumber, series) {
        super(title, artist, duration, filePath);
        
        // ENCAPSULATION: Private fields
        this.#episodeNumber = episodeNumber;
        this.#series = series;
        this.#playbackSpeed = 1.0; // 1.0x, 1.5x, 2.0x, etc.
        this.#bookmarks = [];
    }
    
    #episodeNumber;
    #series;
    #playbackSpeed;
    #bookmarks;
    
    // POLYMORPHISM: Override abstract method
    play() {
        this.#isPlaying = true;
        this.#updatePlayStatistics();
        return {
            success: true,
            message: `Playing podcast: ${this.getTitle()}`,
            series: this.#series,
            episode: this.#episodeNumber,
            speed: `${this.#playbackSpeed}x`
        };
    }
    
    pause() {
        this.#isPlaying = false;
        return `Paused: ${this.getTitle()}`;
    }
    
    stop() {
        this.#isPlaying = false;
        this.#currentPosition = 0;
        return `Stopped: ${this.getTitle()}`;
    }
    
    // POLYMORPHISM: Override abstract method
    getMediaInfo() {
        return {
            title: this.getTitle(),
            artist: this.getArtist(),
            type: 'Podcast',
            series: this.#series,
            episode: this.#episodeNumber,
            duration: this.getFormattedDuration(),
            playCount: this.getPlayCount(),
            lastPlayed: this.getLastPlayed()
        };
    }
    
    // Podcast-specific methods
    setPlaybackSpeed(speed) {
        const validSpeeds = [0.5, 0.75, 1.0, 1.25, 1.5, 2.0];
        if (validSpeeds.includes(speed)) {
            this.#playbackSpeed = speed;
            return `Playback speed set to ${speed}x`;
        }
        return 'Invalid playback speed';
    }
    
    addBookmark(timestamp, note) {
        this.#bookmarks.push({ timestamp, note, date: new Date() });
        return `Bookmark added at ${timestamp}`;
    }
    
    getBookmarks() {
        return this.#bookmarks;
    }
}

// ============================================
// POLYMORPHISM: Media Player (Works with all Media types)
// ============================================
class MediaPlayer {
    #playlist;
    #currentMedia;
    #playbackHistory;
    
    constructor() {
        // ENCAPSULATION: Private storage
        this.#playlist = [];
        this.#currentMedia = null;
        this.#playbackHistory = [];
    }
    
    // POLYMORPHISM: Add any media type
    addToPlaylist(media) {
        if (!(media instanceof Media)) {
            throw new Error('Invalid media type');
        }
        this.#playlist.push(media);
        return `Added ${media.getTitle()} to playlist`;
    }
    
    // POLYMORPHISM: Play any media type
    play(mediaTitle) {
        // Stop current media if playing
        if (this.#currentMedia && this.#currentMedia.isCurrentlyPlaying()) {
            this.#currentMedia.stop();
        }
        
        // Find media in playlist
        const media = this.#playlist.find(m => m.getTitle() === mediaTitle);
        
        if (!media) {
            return { success: false, error: 'Media not found in playlist' };
        }
        
        this.#currentMedia = media;
        const playResult = media.play(); // POLYMORPHISM: Different play behavior
        
        // ABSTRACTION: Track history (hides complexity)
        this.#playbackHistory.push({
            media: media.getTitle(),
            started: new Date(),
            type: media.getMediaInfo().type
        });
        
        return {
            success: true,
            ...playResult,
            playlistPosition: this.#playlist.indexOf(media) + 1,
            totalInPlaylist: this.#playlist.length
        };
    }
    
    // POLYMORPHISM: Control any media type
    pause() {
        if (!this.#currentMedia) {
            return { success: false, error: 'No media playing' };
        }
        return { success: true, message: this.#currentMedia.pause() };
    }
    
    stop() {
        if (!this.#currentMedia) {
            return { success: false, error: 'No media playing' };
        }
        return { success: true, message: this.#currentMedia.stop() };
    }
    
    // POLYMORPHISM: Get info for any media type
    getPlaylist() {
        return this.#playlist.map(media => media.getMediaInfo());
    }
    
    // POLYMORPHISM: Get media by type
    getMediaByType(type) {
        return this.#playlist
            .filter(media => {
                const info = media.getMediaInfo();
                return info.type.toLowerCase() === type.toLowerCase();
            })
            .map(media => media.getMediaInfo());
    }
    
    // ABSTRACTION: Get statistics
    getStatistics() {
        const totalPlays = this.#playlist.reduce((sum, media) => 
            sum + media.getPlayCount(), 0
        );
        
        const byType = {};
        this.#playlist.forEach(media => {
            const type = media.getMediaInfo().type;
            byType[type] = (byType[type] || 0) + 1;
        });
        
        return {
            totalMedia: this.#playlist.length,
            totalPlays,
            mediaByType: byType,
            playbackHistory: this.#playbackHistory
        };
    }
}

// ============================================
// USAGE EXAMPLE
// ============================================
const player = new MediaPlayer();

// Create different media types (POLYMORPHISM)
const song = new AudioFile(
    'Bohemian Rhapsody',
    'Queen',
    355,
    '/music/queen-bohemian.mp3',
    'mp3',
    320
);

const movie = new VideoFile(
    'Inception',
    'Christopher Nolan',
    8880,
    '/videos/inception.mp4',
    '1080p',
    'h264'
);

const podcast = new Podcast(
    'JavaScript Mastery',
    'Tech Talk',
    3600,
    '/podcasts/js-mastery-ep5.mp3',
    5,
    'Advanced JavaScript'
);

// Add to playlist (POLYMORPHISM - all treated as Media)
player.addToPlaylist(song);
player.addToPlaylist(movie);
player.addToPlaylist(podcast);

// Play different media types (POLYMORPHISM - different behavior)
console.log(player.play('Bohemian Rhapsody'));
// Audio-specific play behavior

console.log(player.play('Inception'));
// Video-specific play behavior

console.log(player.play('JavaScript Mastery'));
// Podcast-specific play behavior

// Use type-specific methods
song.setVolume(75);
movie.toggleSubtitles();
podcast.setPlaybackSpeed(1.5);
podcast.addBookmark(1200, 'Important concept about closures');

// Get playlist (POLYMORPHISM - unified interface)
console.log(player.getPlaylist());

// Get statistics (ABSTRACTION - hides complexity)
console.log(player.getStatistics());
```

---

### Summary: How All Four Principles Work Together

1. **Encapsulation**: Private fields and methods protect data, public methods provide controlled access
2. **Abstraction**: Abstract classes define contracts, complex implementation details are hidden
3. **Inheritance**: Child classes inherit common functionality from parent classes
4. **Polymorphism**: Different classes can be treated uniformly through a common interface, with each providing its own implementation

These principles work together to create:
- **Maintainable Code**: Easy to modify and extend
- **Reusable Components**: Common functionality is shared
- **Flexible Systems**: Can work with different types through unified interfaces
- **Protected Data**: Internal state is safely encapsulated

---

